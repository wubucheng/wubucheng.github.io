<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴编程</title>
  
  <subtitle>wubc的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="wbc.wiki/"/>
  <updated>2023-06-07T13:53:38.124Z</updated>
  <id>wbc.wiki/</id>
  
  <author>
    <name>wubc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring源码解析读书笔记之二:默认标签的解析</title>
    <link href="wbc.wiki/2023/06/07/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C-%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>wbc.wiki/2023/06/07/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C-%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE%E7%9A%84%E8%A7%A3%E6%9E%90/</id>
    <published>2023-06-07T13:50:53.000Z</published>
    <updated>2023-06-07T13:53:38.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、默认标签的解析"><a href="#二、默认标签的解析" class="headerlink" title="二、默认标签的解析"></a>二、默认标签的解析</h1><h2 id="bean标签的解析和注册"><a href="#bean标签的解析和注册" class="headerlink" title="bean标签的解析和注册"></a>bean标签的解析和注册</h2><p>DefaultBeanDefinitionDocumentReader#processBeanDefinition</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解析Bean定义资源Document对象的普通元素</span><br><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">&#x2F;&#x2F; 解析成BeanDefinitionHolder</span><br><span class="line">BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">&#x2F;&#x2F; BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类</span><br><span class="line">&#x2F;&#x2F;对Document对象中&lt;Bean&gt;元素的解析由BeanDefinitionParserDelegate实现</span><br><span class="line">if (bdHolder !&#x3D; null) &#123;</span><br><span class="line">bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; Register the final decorated instance.</span><br><span class="line">&#x2F;&#x2F;向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +</span><br><span class="line">bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在完成向Spring IOC容器注册解析得到的Bean定义之后，发送注册事件</span><br><span class="line">getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解析成BeanDefinitionHolder</li><li>对自定义节点进行解析</li><li>对BeanDefinitionHolder进行注册</li><li>发送注册事件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解析&lt;Bean&gt;元素的入口</span><br><span class="line">@Nullable</span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123;</span><br><span class="line">&#x2F;&#x2F;获取&lt;Bean&gt;元素中的id属性值</span><br><span class="line">String id &#x3D; ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">&#x2F;&#x2F;获取&lt;Bean&gt;元素中的name属性值</span><br><span class="line">String nameAttr &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取&lt;Bean&gt;元素中的alias属性值</span><br><span class="line">List&lt;String&gt; aliases &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将&lt;Bean&gt;元素中的所有name属性值存放到别名中</span><br><span class="line">if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr &#x3D; StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String beanName &#x3D; id;</span><br><span class="line">&#x2F;&#x2F;如果&lt;Bean&gt;元素中没有配置id属性时，并且设置了别名，将别名中的第一个值赋值给beanName</span><br><span class="line">if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName &#x3D; aliases.remove(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查&lt;Bean&gt;元素所配置的id或者name的唯一性，containingBean标识&lt;Bean&gt;</span><br><span class="line">&#x2F;&#x2F;元素中是否包含子&lt;Bean&gt;元素</span><br><span class="line">if (containingBean &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;检查&lt;Bean&gt;元素所配置的id、name或者别名是否重复</span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;详细对&lt;Bean&gt;元素中配置的Bean定义进行解析的地方</span><br><span class="line">AbstractBeanDefinition beanDefinition &#x3D; parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">if (beanDefinition !&#x3D; null) &#123;</span><br><span class="line">if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (containingBean !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;如果&lt;Bean&gt;元素中没有配置id、别名或者name，且没有包含子元素</span><br><span class="line">&#x2F;&#x2F;&lt;Bean&gt;元素，为解析的Bean生成一个唯一beanName并注册</span><br><span class="line">beanName &#x3D; BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F;如果&lt;Bean&gt;元素中没有配置id、别名或者name，且包含了子元素</span><br><span class="line">&#x2F;&#x2F;&lt;Bean&gt;元素，为解析的Bean使用别名向IOC容器注册</span><br><span class="line">beanName &#x3D; this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">&#x2F;&#x2F;为解析的Bean使用别名注册时，为了向后兼容</span><br><span class="line">&#x2F;&#x2F;Spring1.2&#x2F;2.0，给别名添加类名后缀</span><br><span class="line">String beanClassName &#x3D; beanDefinition.getBeanClassName();</span><br><span class="line">if (beanClassName !&#x3D; null &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray &#x3D; StringUtils.toStringArray(aliases);</span><br><span class="line">return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当解析出错时，返回null</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提取元素中的id以及name属性</li><li>bean没有指定beanName，那么使用默认规则为此bean生成beanName</li><li>将获取到的信息封装到BeanDefinitionHolder实例中</li></ul><p>上面处理了id、name和别名属性，接着里面调用了BeanDefinitionParserDelegate#parseBeanDefinitionElement(Element, String, BeanDefinition)，这个方法是处理其他属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123;</span><br><span class="line">&#x2F;&#x2F;记录解析的&lt;Bean&gt;</span><br><span class="line">this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里只读取&lt;Bean&gt;元素中配置的class名字，然后载入到BeanDefinition中去</span><br><span class="line">&#x2F;&#x2F;只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成</span><br><span class="line">String className &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果&lt;Bean&gt;元素中配置了parent属性，则获取parent属性的值</span><br><span class="line">if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className &#x3D; ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line">String parent &#x3D; null;</span><br><span class="line">if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent &#x3D; ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;根据&lt;Bean&gt;元素配置的class名称和parent属性值创建BeanDefinition</span><br><span class="line">&#x2F;&#x2F;为载入Bean定义信息做准备</span><br><span class="line">AbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">&#x2F;&#x2F;为&lt;Bean&gt;元素解析的Bean设置description信息</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对&lt;Bean&gt;元素的meta(元信息)属性解析</span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">&#x2F;&#x2F;对&lt;Bean&gt;元素的lookup-method属性解析</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">&#x2F;&#x2F;对&lt;Bean&gt;元素的replaced-method属性解析</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解析&lt;Bean&gt;元素的构造方法设置</span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">&#x2F;&#x2F;解析&lt;Bean&gt;元素的&lt;property&gt;设置</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">&#x2F;&#x2F;解析&lt;Bean&gt;元素的qualifier属性</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为当前解析的Bean设置所需的资源和依赖对象</span><br><span class="line">bd.setResource(this.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">return bd;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line">catch (NoClassDefFoundError err) &#123;</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">this.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解析&lt;Bean&gt;元素出错时，返回null</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBeanDefinition创建的是GenericBeanDefinition示例，是AbstractBeanDefinition的子类，BeanDefinition的实现类，BeanDefinition是配置文件&lt;bean&gt;元素在容器中的内部实现，有三种实现，RootBeanDefinition、ChildBeanDefinition、GenericBeanDefinition。</p><p>parseBeanDefinitionAttributes方法是解析scope、singleton、abstract、lazy-init、autowire、depends-on等属性。</p><h3 id="解析-lt-Bean-gt-元素的-lt-property-gt"><a href="#解析-lt-Bean-gt-元素的-lt-property-gt" class="headerlink" title="解析&lt;Bean&gt;元素的&lt;property&gt;"></a>解析<code>&lt;Bean&gt;</code>元素的<code>&lt;property&gt;</code></h3><p>BeanDefinitionParserDelegate#parsePropertyElements—-&gt;BeanDefinitionParserDelegate#parsePropertyElement</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解析&lt;property&gt;元素</span><br><span class="line">public void parsePropertyElement(Element ele, BeanDefinition bd) &#123;</span><br><span class="line">&#x2F;&#x2F;获取&lt;property&gt;元素的名字</span><br><span class="line">String propertyName &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">if (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">error(&quot;Tag &#39;property&#39; must have a &#39;name&#39; attribute&quot;, ele);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">this.parseState.push(new PropertyEntry(propertyName));</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。</span><br><span class="line">&#x2F;&#x2F;即如果在同一个Bean中配置同名的property，则只有第一个起作用</span><br><span class="line">if (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">error(&quot;Multiple &#39;property&#39; definitions for property &#39;&quot; + propertyName + &quot;&#39;&quot;, ele);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;解析获取property的值</span><br><span class="line">Object val &#x3D; parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">&#x2F;&#x2F;根据property的名字和值创建property实例</span><br><span class="line">PropertyValue pv &#x3D; new PropertyValue(propertyName, val);</span><br><span class="line">&#x2F;&#x2F;解析&lt;property&gt;元素中的属性</span><br><span class="line">parseMetaElements(ele, pv);</span><br><span class="line">pv.setSource(extractSource(ele));</span><br><span class="line">bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">this.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用了parsePropertyValue方法，这个是获取property的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) &#123;</span><br><span class="line">String elementName &#x3D; (propertyName !&#x3D; null) ?</span><br><span class="line">&quot;&lt;property&gt; element for property &#39;&quot; + propertyName + &quot;&#39;&quot; :</span><br><span class="line">&quot;&lt;constructor-arg&gt; element&quot;;</span><br><span class="line">&#x2F;&#x2F;获取&lt;property&gt;的所有子元素，只能是其中一种类型:ref,value,list,etc等</span><br><span class="line">NodeList nl &#x3D; ele.getChildNodes();</span><br><span class="line">Element subElement &#x3D; null;</span><br><span class="line">for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node &#x3D; nl.item(i);</span><br><span class="line">&#x2F;&#x2F;子元素不是description和meta属性</span><br><span class="line">if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">!nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">&#x2F;&#x2F; Child element is what we&#39;re looking for.</span><br><span class="line">if (subElement !&#x3D; null) &#123;</span><br><span class="line">error(elementName + &quot; must not contain more than one sub-element&quot;, ele);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F;当前&lt;property&gt;元素包含有子元素</span><br><span class="line">subElement &#x3D; (Element) node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断property的属性值是ref还是value，不允许既是ref又是value</span><br><span class="line">boolean hasRefAttribute &#x3D; ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">boolean hasValueAttribute &#x3D; ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement !&#x3D; null)) &#123;</span><br><span class="line">error(elementName +</span><br><span class="line">&quot; is only allowed to contain either &#39;ref&#39; attribute OR &#39;value&#39; attribute OR sub-element&quot;, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果属性是ref，创建一个ref的数据对象RuntimeBeanReference</span><br><span class="line">&#x2F;&#x2F;这个对象封装了ref信息</span><br><span class="line">if (hasRefAttribute) &#123;</span><br><span class="line">String refName &#x3D; ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">error(elementName + &quot; contains empty &#39;ref&#39; attribute&quot;, ele);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;一个指向运行时所依赖对象的引用</span><br><span class="line">RuntimeBeanReference ref &#x3D; new RuntimeBeanReference(refName);</span><br><span class="line">&#x2F;&#x2F;设置这个ref的数据对象是被当前的property对象所引用</span><br><span class="line">ref.setSource(extractSource(ele));</span><br><span class="line">return ref;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果属性是value，创建一个value的数据对象TypedStringValue</span><br><span class="line">&#x2F;&#x2F;这个对象封装了value信息</span><br><span class="line">else if (hasValueAttribute) &#123;</span><br><span class="line">&#x2F;&#x2F;一个持有String类型值的对象</span><br><span class="line">TypedStringValue valueHolder &#x3D; new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">&#x2F;&#x2F;设置这个value数据对象是被当前的property对象所引用</span><br><span class="line">valueHolder.setSource(extractSource(ele));</span><br><span class="line">return valueHolder;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果当前&lt;property&gt;元素还有子元素</span><br><span class="line">else if (subElement !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;解析&lt;property&gt;的子元素</span><br><span class="line">return parsePropertySubElement(subElement, bd);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F;propery属性中既不是ref，也不是value属性，解析出错返回null</span><br><span class="line">error(elementName + &quot; must specify a ref or value&quot;, ele);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析默认标签中的自定义标签元素"><a href="#解析默认标签中的自定义标签元素" class="headerlink" title="解析默认标签中的自定义标签元素"></a>解析默认标签中的自定义标签元素</h3><p>注意这里所说的是自定义类型是属性，不是bean。</p><p>BeanDefinitionParserDelegate#decorateBeanDefinitionIfRequired(Element, BeanDefinitionHolder)</p><p>这个方法是如果需要就对beanDefinition进行装饰，根据调用链，其调用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder decorateBeanDefinitionIfRequired(</span><br><span class="line">Element ele, BeanDefinitionHolder definitionHolder, @Nullable BeanDefinition containingBd) &#123;</span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder finalDefinition &#x3D; definitionHolder;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Decorate based on custom attributes first.</span><br><span class="line">&#x2F;&#x2F; 判断是否有适用于修饰的属性</span><br><span class="line">NamedNodeMap attributes &#x3D; ele.getAttributes();</span><br><span class="line">for (int i &#x3D; 0; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">Node node &#x3D; attributes.item(i);</span><br><span class="line">finalDefinition &#x3D; decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Decorate based on custom nested elements.</span><br><span class="line">&#x2F;&#x2F; 是否有适用于修饰的子元素</span><br><span class="line">NodeList children &#x3D; ele.getChildNodes();</span><br><span class="line">for (int i &#x3D; 0; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">Node node &#x3D; children.item(i);</span><br><span class="line">if (node.getNodeType() &#x3D;&#x3D; Node.ELEMENT_NODE) &#123;</span><br><span class="line">finalDefinition &#x3D; decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return finalDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder decorateIfRequired(</span><br><span class="line">Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) &#123;</span><br><span class="line">&#x2F;&#x2F; 获取自定义标签的命名空间</span><br><span class="line">String namespaceUri &#x3D; getNamespaceURI(node);</span><br><span class="line">if (namespaceUri !&#x3D; null &amp;&amp; !isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">&#x2F;&#x2F; 根据命名空间找到对应的处理器</span><br><span class="line">NamespaceHandler handler &#x3D; this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">if (handler !&#x3D; null) &#123;</span><br><span class="line">BeanDefinitionHolder decorated &#x3D;</span><br><span class="line">handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">if (decorated !&#x3D; null) &#123;</span><br><span class="line">return decorated;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (namespaceUri.startsWith(&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;&quot;)) &#123;</span><br><span class="line">error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, node);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return originalDef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanDefinition(</span><br><span class="line">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">throws BeanDefinitionStoreException &#123;</span><br><span class="line">&#x2F;&#x2F;获取解析的BeanDefinition的名称</span><br><span class="line">String beanName &#x3D; definitionHolder.getBeanName();</span><br><span class="line">&#x2F;&#x2F;向IOC容器注册BeanDefinition</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果解析的BeanDefinition有别名，向容器为其注册别名</span><br><span class="line">String[] aliases &#x3D; definitionHolder.getAliases();</span><br><span class="line">if (aliases !&#x3D; null) &#123;</span><br><span class="line">for (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinitionRegistry是一个接口，这里实际用这个方法处理：DefaultListableBeanFactory#registerBeanDefinition。</p><h4 id="通过beanName注册："><a href="#通过beanName注册：" class="headerlink" title="通过beanName注册："></a>通过beanName注册：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;校验解析的BeanDefiniton</span><br><span class="line">if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; 这里校验methodOverrides是否与工厂方法并存或者methodOverrides对象方法不存在</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">&quot;Validation of bean definition failed&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">oldBeanDefinition &#x3D; this.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">if (oldBeanDefinition !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 处理重复名称bean定义问题</span><br><span class="line">if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">&#x2F;&#x2F; 配置了bean不允许覆盖，则将抛出异常</span><br><span class="line">throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">&quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &#39;&quot; + beanName +</span><br><span class="line">&quot;&#39;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">&#x2F;&#x2F; e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span><br><span class="line">if (this.logger.isWarnEnabled()) &#123;</span><br><span class="line">this.logger.warn(&quot;Overriding user-defined bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">&quot;&#39; with a framework-generated bean definition: replacing [&quot; +</span><br><span class="line">oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">this.logger.info(&quot;Overriding bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">&quot;&#39; with a different definition: replacing [&quot; + oldBeanDefinition +</span><br><span class="line">&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">this.logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">&quot;&#39; with an equivalent definition: replacing [&quot; + oldBeanDefinition +</span><br><span class="line">&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; map中没有，则将beanName和beanDefinition存放到map中</span><br><span class="line">if (hasBeanCreationStarted()) &#123;</span><br><span class="line">&#x2F;&#x2F; Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">&#x2F;&#x2F;注册的过程中需要线程同步，以保证数据的一致性</span><br><span class="line">synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions &#x3D; new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line">this.beanDefinitionNames &#x3D; updatedDefinitions;</span><br><span class="line">if (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">Set&lt;String&gt; updatedSingletons &#x3D; new LinkedHashSet&lt;&gt;(this.manualSingletonNames);</span><br><span class="line">updatedSingletons.remove(beanName);</span><br><span class="line">this.manualSingletonNames &#x3D; updatedSingletons;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; Still in startup registration phase</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">this.beanDefinitionNames.add(beanName);</span><br><span class="line">this.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">this.frozenBeanDefinitionNames &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查是否有同名的BeanDefinition已经在IOC容器中注册</span><br><span class="line">if (oldBeanDefinition !&#x3D; null || containsSingleton(beanName)) &#123;</span><br><span class="line">&#x2F;&#x2F;重置所有已经注册过的BeanDefinition的缓存</span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要做了：</p><ul><li>对AbstractBeanDefinition校验</li><li>对beanName已注册情况处理，如果不允许bean的覆盖，则抛出异常</li><li>将beanName作为key，将beanDefinition作为value加入到beanDefinitionMap</li><li>清除之前解析留下对应的beanName缓存</li></ul><h4 id="通过别名注册："><a href="#通过别名注册：" class="headerlink" title="通过别名注册："></a>通过别名注册：</h4><p>SimpleAliasRegistry#registerAlias</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void registerAlias(String name, String alias) &#123;</span><br><span class="line">Assert.hasText(name, &quot;&#39;name&#39; must not be empty&quot;);</span><br><span class="line">Assert.hasText(alias, &quot;&#39;alias&#39; must not be empty&quot;);</span><br><span class="line">if (alias.equals(name)) &#123;</span><br><span class="line">&#x2F;&#x2F; beanName和别名相同，则移除该别名</span><br><span class="line">this.aliasMap.remove(alias);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">String registeredName &#x3D; this.aliasMap.get(alias);</span><br><span class="line">if (registeredName !&#x3D; null) &#123;</span><br><span class="line">if (registeredName.equals(name)) &#123;</span><br><span class="line">&#x2F;&#x2F; 已经注册过了，则直接返回</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (!allowAliasOverriding()) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Cannot register alias &#39;&quot; + alias + &quot;&#39; for name &#39;&quot; +</span><br><span class="line">name + &quot;&#39;: It is already registered for name &#39;&quot; + registeredName + &quot;&#39;.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 检查是否有别名循环了</span><br><span class="line">checkForAliasCircle(name, alias);</span><br><span class="line">this.aliasMap.put(alias, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alias标签的解析"><a href="#alias标签的解析" class="headerlink" title="alias标签的解析"></a>alias标签的解析</h2><p>DefaultBeanDefinitionDocumentReader#processAliasRegistration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解析&lt;Alias&gt;别名元素，为Bean向Spring IoC容器注册别名</span><br><span class="line">protected void processAliasRegistration(Element ele) &#123;</span><br><span class="line">&#x2F;&#x2F;获取&lt;Alias&gt;别名元素中name的属性值</span><br><span class="line">String name &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">&#x2F;&#x2F;获取&lt;Alias&gt;别名元素中alias的属性值</span><br><span class="line">String alias &#x3D; ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">boolean valid &#x3D; true;</span><br><span class="line">&#x2F;&#x2F;&lt;alias&gt;别名元素的name属性值为空</span><br><span class="line">if (!StringUtils.hasText(name)) &#123;</span><br><span class="line">getReaderContext().error(&quot;Name must not be empty&quot;, ele);</span><br><span class="line">valid &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&lt;alias&gt;别名元素的alias属性值为空</span><br><span class="line">if (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">getReaderContext().error(&quot;Alias must not be empty&quot;, ele);</span><br><span class="line">valid &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">if (valid) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;向容器的资源读入器注册别名</span><br><span class="line">getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在解析完&lt;Alias&gt;元素之后，发送容器别名处理完成事件</span><br><span class="line">getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="import标签的解析"><a href="#import标签的解析" class="headerlink" title="import标签的解析"></a>import标签的解析</h2><p>DefaultBeanDefinitionDocumentReader#importBeanDefinitionResource</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解析&lt;Import&gt;导入元素，从给定的导入路径加载Bean定义资源到Spring IoC容器中</span><br><span class="line">protected void importBeanDefinitionResource(Element ele) &#123;</span><br><span class="line">&#x2F;&#x2F;获取给定的导入元素的location属性</span><br><span class="line">String location &#x3D; ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">&#x2F;&#x2F;如果导入元素的location属性值为空，则没有导入任何资源，直接返回</span><br><span class="line">if (!StringUtils.hasText(location)) &#123;</span><br><span class="line">getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用系统变量值解析location属性值</span><br><span class="line">location &#x3D; getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">Set&lt;Resource&gt; actualResources &#x3D; new LinkedHashSet&lt;&gt;(4);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;标识给定的导入元素的location是否是绝对路径</span><br><span class="line">boolean absoluteLocation &#x3D; false;</span><br><span class="line">try &#123;</span><br><span class="line">absoluteLocation &#x3D; ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">&#125;</span><br><span class="line">catch (URISyntaxException ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Absolute or relative?</span><br><span class="line">&#x2F;&#x2F;给定的导入元素的location是绝对路径</span><br><span class="line">if (absoluteLocation) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;使用资源读入器加载给定路径的Bean定义资源</span><br><span class="line">int importCount &#x3D; getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; No URL -&gt; considering resource location as relative to the current file.</span><br><span class="line">&#x2F;&#x2F;给定的导入元素的location是相对路径，则需要计算出绝对路径</span><br><span class="line">try &#123;</span><br><span class="line">int importCount;</span><br><span class="line">&#x2F;&#x2F;将给定导入元素的location封装为相对路径资源</span><br><span class="line">&#x2F;&#x2F; 先用子类的方法尝试解析</span><br><span class="line">Resource relativeResource &#x3D; getReaderContext().getResource().createRelative(location);</span><br><span class="line">&#x2F;&#x2F;封装的相对路径资源存在</span><br><span class="line">if (relativeResource.exists()) &#123;</span><br><span class="line">&#x2F;&#x2F;使用资源读入器加载Bean定义资源</span><br><span class="line">importCount &#x3D; getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">actualResources.add(relativeResource);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;封装的相对路径资源不存在</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F;获取Spring IOC容器资源读入器的基本路径</span><br><span class="line">String baseLocation &#x3D; getReaderContext().getResource().getURL().toString();</span><br><span class="line">&#x2F;&#x2F;根据Spring IOC容器资源读入器的基本路径加载给定导入路径的资源</span><br><span class="line">importCount &#x3D; getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Resource[] actResArray &#x3D; actualResources.toArray(new Resource[actualResources.size()]);</span><br><span class="line">&#x2F;&#x2F;在解析完&lt;Import&gt;元素之后，发送容器导入其他资源处理完成事件</span><br><span class="line">getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取resource属性所表示的路径</li><li>解析路径中的系统属性</li><li>判断location是否为绝对路径<ul><li>绝对路径：递归调用bean的解析过程</li><li>相对路径：计算出绝对路径</li></ul></li><li>通知监听器，解析完成</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二、默认标签的解析&quot;&gt;&lt;a href=&quot;#二、默认标签的解析&quot; class=&quot;headerlink&quot; title=&quot;二、默认标签的解析&quot;&gt;&lt;/a&gt;二、默认标签的解析&lt;/h1&gt;&lt;h2 id=&quot;bean标签的解析和注册&quot;&gt;&lt;a href=&quot;#bean标签的解析和注册&quot;
      
    
    </summary>
    
    
      <category term="Spring" scheme="wbc.wiki/categories/Spring/"/>
    
    
      <category term="Spring" scheme="wbc.wiki/tags/Spring/"/>
    
      <category term="源码解析" scheme="wbc.wiki/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码解析读书笔记之一、容器的基本实现</title>
    <link href="wbc.wiki/2023/06/07/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/"/>
    <id>wbc.wiki/2023/06/07/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-06-07T13:35:00.000Z</published>
    <updated>2023-06-07T13:50:04.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、容器的基本实现"><a href="#一、容器的基本实现" class="headerlink" title="一、容器的基本实现"></a>一、容器的基本实现</h1><h2 id="容器的基础XmlBeanFactory"><a href="#容器的基础XmlBeanFactory" class="headerlink" title="容器的基础XmlBeanFactory"></a>容器的基础XmlBeanFactory</h2><h3 id="配置文件的封装"><a href="#配置文件的封装" class="headerlink" title="配置文件的封装"></a>配置文件的封装</h3><p>通过ClassPathResource进行封装，该类间接实现了Resource接口，这个接口定义了底层资源的方法，对于不同资源都有着不同的是吸纳，例如ClassPathResource（ClassPath资源）、FileSystemResource（文件资源）</p><h3 id="加载Bean"><a href="#加载Bean" class="headerlink" title="加载Bean"></a>加载Bean</h3><p>资源加载入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到：XmlBeanDefinitionReader#loadBeanDefinitions(EncodedResource) <em>省略掉无关代码</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是载入XML形式Bean定义资源文件方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">// 记录已加载的资源</span></span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"><span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//将资源文件转为InputStream的IO流</span></span><br><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//从InputStream中得到XML的解析源</span></span><br><span class="line">InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是具体的读取过程</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//关闭从Resource中得到的IO流</span></span><br><span class="line">inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这上面主要作用是获取InputSource，在这里调用了XmlBeanDefinitionReader#doLoadBeanDefinitions，是具体的读取过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从特定XML文件中实际载入Bean定义资源的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//将XML文件转换为DOM对象，解析过程由documentLoader实现</span></span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="comment">//这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则</span></span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要做了三件事情：</p><ul><li>获取XML文件的验证模式</li><li>加载XML文件，并得到对应的Document</li><li>根据返回的Document注册Bean信息</li></ul><h2 id="注册和解析BeanDefinitions"><a href="#注册和解析BeanDefinitions" class="headerlink" title="注册和解析BeanDefinitions"></a>注册和解析BeanDefinitions</h2><p>XmlBeanDefinitionReader#registerBeanDefinitions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">//得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析</span></span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="comment">//获得容器中注册的Bean数量</span></span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line"><span class="comment">//解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口,</span></span><br><span class="line"><span class="comment">//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="comment">//统计解析的Bean数量</span></span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是使用BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader进行处理，走到这个类的registerBeanDefinitions方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获得XML描述符</span></span><br><span class="line"><span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line"><span class="comment">//获得Document的根元素</span></span><br><span class="line">Element root = doc.getDocumentElement();</span><br><span class="line"><span class="comment">// 解析的具体实现</span></span><br><span class="line">doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个很重要的目的是提取root。DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions是真正开始解析了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//具体的解析过程由BeanDefinitionParserDelegate实现，</span></span><br><span class="line"><span class="comment">//BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性</span></span><br><span class="line">preProcessXml(root);</span><br><span class="line"><span class="comment">//从Document的根元素开始进行解析Bean定义的Document对象</span></span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line"><span class="comment">//在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性</span></span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析并注册BeanDefinition：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Bean定义的Document对象使用了Spring默认的XML命名空间</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">//获取Bean定义的Document对象根元素的所有子节点</span></span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="comment">//获得Document节点是XML元素节点</span></span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="comment">//Bean定义的Document的元素节点使用的是Spring默认的XML命名空间</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"><span class="comment">//使用Spring的Bean规则解析元素节点</span></span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点</span></span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的</span></span><br><span class="line"><span class="comment">//解析规则解析Document根节点</span></span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、容器的基本实现&quot;&gt;&lt;a href=&quot;#一、容器的基本实现&quot; class=&quot;headerlink&quot; title=&quot;一、容器的基本实现&quot;&gt;&lt;/a&gt;一、容器的基本实现&lt;/h1&gt;&lt;h2 id=&quot;容器的基础XmlBeanFactory&quot;&gt;&lt;a href=&quot;#容器的基础X
      
    
    </summary>
    
    
      <category term="Spring" scheme="wbc.wiki/categories/Spring/"/>
    
    
      <category term="Spring" scheme="wbc.wiki/tags/Spring/"/>
    
      <category term="源码解析" scheme="wbc.wiki/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第六章 类文件结构</title>
    <link href="wbc.wiki/2020/10/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9A%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>wbc.wiki/2020/10/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9A%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2020-10-17T08:06:38.000Z</published>
    <updated>2020-10-17T09:32:00.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Java虚拟机：第六章（一）类文件结构"><a href="#深入理解Java虚拟机：第六章（一）类文件结构" class="headerlink" title="深入理解Java虚拟机：第六章（一）类文件结构"></a>深入理解Java虚拟机：第六章（一）类文件结构</h1><h2 id="Class文件的结构"><a href="#Class文件的结构" class="headerlink" title="Class文件的结构"></a>Class文件的结构</h2><p>class文件伪结构中有两种数据类型：</p><ul><li>无符号数</li><li>表</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=714093825,3040960142&fm=15&gp=0.jpg" alt="class文件图" title="">                </div>                <div class="image-caption">class文件图</div>            </figure><h3 id="魔数magic"><a href="#魔数magic" class="headerlink" title="魔数magic"></a>魔数magic</h3><p>占4个字节，作用是确定文件是否能被虚拟机接受</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>包括次版本号和主版本号</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>存放两大常量：</p><ul><li>字面量<ul><li>如文本字符串、final常量</li></ul></li><li>符号引用<ul><li>开放的包、全限定名、方法名称和描述、句柄、类型、动态调用点等</li></ul></li></ul><p>常量池项目类型：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2993888056,3922967470&fm=15&gp=0.jpg" alt="常量池项目类型" title="">                </div>                <div class="image-caption">常量池项目类型</div>            </figure><p>P221参照表，后面分析的内容要用到</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><blockquote><p>access_flag占两个字节，用于识别一些类或者接口层次的访问信息，例如是否定义为public、abstract、final类型</p></blockquote><p>各个值得含义如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/17/qsgQMPaDp32onHI.jpg" alt="访问标志.jpg" title="">                </div>                <div class="image-caption">访问标志.jpg</div>            </figure><p>没有使用到的标志位一律为0</p><h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><p><strong>类索引</strong>：确定类的全限定名</p><p><strong>父类索引</strong>：确定类的父类的全限定名，只有一个。除了java.lang.Object外，所有Java类的父类索引都不为0</p><p><strong>接口索引</strong>：集合就用来描述这个类实现了哪些接口</p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><blockquote><p>用于描述接口或类中声明的变量</p></blockquote><p><strong>字段表结构如下图</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/17/XJSjnMQLebHWBi7.jpg" alt="字段表结构.jpg" title="">                </div>                <div class="image-caption">字段表结构.jpg</div>            </figure><p><strong>字段访问标志如下图</strong><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/17/TQbxDmkXVaCh5iP.jpg" alt="字段访问标志.jpg" title="">                </div>                <div class="image-caption">字段访问标志.jpg</div>            </figure></p><p>由于java语法原因，有些标志位不能同时选择。</p><p>字段表后面两项是<strong>name_index</strong>和<strong>descriptor_indexx</strong>。分别代表字段的简单名称和方法描述符</p><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p><strong>方法表结构</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/17/ljOSdRMPHiuQU1V.jpg" alt="方法表结构.jpg" title="">                </div>                <div class="image-caption">方法表结构.jpg</div>            </figure><p>方法访问标志与属性访问标志类似。只是增加和减少了部分属性。而方法中代码存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目。</p><p>在java代码层面上，重载一个方法必须拥有一个与原方法不同的特征签名（<em>特征签名是指一个方法中各个参数在常量池中的字段符号</em>），该特征签名只包括方法名称、参数类型和顺序。</p><p>而在字节码层面上，特征签名还包括方法返回值和受检查异常表，因此，如果两个方法有相同的名称和特征签<br>名，但返回值不同，那么也是可以合法共存于同一个Class文件中的</p><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>属性表结构</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/24/5dMgoazTiSxFqvE.jpg" alt="属性表结构.jpg" title="">                </div>                <div class="image-caption">属性表结构.jpg</div>            </figure><h4 id="code属性"><a href="#code属性" class="headerlink" title="code属性"></a>code属性</h4><blockquote><p>方法体里的代码编译后会存储在字节码的code属性内，code属性出现在方法表里的属性集合之中，但接口或抽象类的方法就不存在code属性。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/24/H5uUDvgqZoKtIdi.jpg" alt="code属性表结构.jpg" title="">                </div>                <div class="image-caption">code属性表结构.jpg</div>            </figure><ul><li>attribute_name_index：属性名称索引，CONSTRANT_Utf8_info型常量索引</li><li>attribute_length：属性值长度。属性名称索引和该值长度共6个字节</li><li>max_stack：操作数栈深度最大值，在方法执行时操作数栈不会超过这个深度。虚拟机根据这个值分配栈帧中操作栈的深度。</li><li>max_locals：局部变量表所需的存储空间，单位是槽。长度不超过32位的局部变量用一个槽存储，64位的用2个槽。变量槽是可以进行复用的。</li><li>code_length：字节码长度。理论值可以达到2的32次幂，但实际上不能超过u2长度，否则编译器拒绝编译。</li><li>code：存储字节码指令的一些列字节流</li></ul><h4 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h4><blockquote><p>作用是列举出方法中可能抛出的受查异常</p></blockquote><h4 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h4><blockquote><p>用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。<br>它并不是运行时必需的属性</p></blockquote><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><ul><li>LocalV ariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。</li></ul><ul><li><p>LocalV ariableTypeTable。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名，用于准确描述泛型类型。</p></li><li><p>SourceFile属性用于记录生成这个Class文件的源码文件名称，可选。</p></li><li><p>SourceDebugExtension属性用于存储额外的代码调试信息，例如定位JSP的信息。</p></li><li><p>ConstantV alue属性的作用是通知虚拟机自动为静态变量赋值。</p></li><li><p>InnerClasses属性用于记录内部类与宿主类之间的关联。</p></li><li><p>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用。</p></li><li><p>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。</p></li><li><p>StackMapTable：</p></li><li><p>Sign：ature：记录泛型签名信息</p></li><li><p>BootstrapMethods：</p></li><li><p>MethodParameters：记录方法的各个形参名称和信息，jdk8新增的</p></li><li><p>模块化相关属性</p><ul><li>exports：每一元素都代表一个被模块所导出的包</li><li>export_to_count：导出包的限定器，为0则无限定，否则后面跟着的export_to_index是以计数器值为长度的数组，只有在这个数组范围内的模块才允许被访问。</li><li></li><li></li></ul></li><li><p>运行期注解相关属性：</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Java虚拟机：第六章（一）类文件结构&quot;&gt;&lt;a href=&quot;#深入理解Java虚拟机：第六章（一）类文件结构&quot; class=&quot;headerlink&quot; title=&quot;深入理解Java虚拟机：第六章（一）类文件结构&quot;&gt;&lt;/a&gt;深入理解Java虚拟机：第六章（一
      
    
    </summary>
    
    
      <category term="java虚拟机" scheme="wbc.wiki/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="wbc.wiki/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Nginx浅入浅出</title>
    <link href="wbc.wiki/2020/08/11/Nginx%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA/"/>
    <id>wbc.wiki/2020/08/11/Nginx%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA/</id>
    <published>2020-08-11T11:32:09.000Z</published>
    <updated>2020-08-11T11:35:19.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>Nginx是一个高性能的反向代理服务</p></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>启动：sudo nginx -s start</li><li>停止：sudo nginx -s stop 或./nginx -s stop</li><li>重启：sudo nginx -s reload</li></ul><h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">        user www-data; # 配置用户或组</span><br><span class="line">        worker_processes auto;  # 设置允许生成的进程数</span><br><span class="line">        pid &#x2F;run&#x2F;nginx.pid;  # 设置pid文件存放路径</span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;modules-enabled&#x2F;*.conf; # 全局块</span><br><span class="line"></span><br><span class="line"># events块</span><br><span class="line">        events &#123;</span><br><span class="line">                worker_connections 768;  # 设置最大连接数</span><br><span class="line">                # multi_accept on; # 设置一个进程能否接收多个网络连接</span><br><span class="line">                # accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class="line">                # use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|&#x2F;dev&#x2F;poll|eventport</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # http块，可以嵌套多个server块</span><br><span class="line">        http &#123;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Basic Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        sendfile on; #允许sendfile方式传输文件</span><br><span class="line">        tcp_nopush on;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">        keepalive_timeout 65; #连接超时时间</span><br><span class="line">        types_hash_max_size 2048;</span><br><span class="line">        # server_tokens off;</span><br><span class="line"></span><br><span class="line">        # server_names_hash_bucket_size 64;</span><br><span class="line">        # server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">        default_type application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # SSL Settings</span><br><span class="line">        ##</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Logging Settings</span><br><span class="line">        ## 日志存放路径，分为用户访问日志和错误日志</span><br><span class="line">        access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log;</span><br><span class="line">        error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Gzip Settings</span><br><span class="line">        ##</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"># 配置压缩信息，可以对静态资源进行压缩</span><br><span class="line">        gzip on;</span><br><span class="line"></span><br><span class="line">        # gzip_vary on;</span><br><span class="line">        # gzip_proxied any;</span><br><span class="line">        # gzip_comp_level 6;</span><br><span class="line">        # gzip_buffers 16 8k;</span><br><span class="line">        # gzip_http_version 1.1;</span><br><span class="line">        # gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Virtual Host Configs</span><br><span class="line">        ##  引用存放在其他路径的配置文件，例如server</span><br><span class="line"></span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>http</code>属性下有这样一行<code>include /etc/nginx/sites-enabled/*</code>，表示是引入了外部另一个配置文件，实际上我们也是这样做的，将相关的代理配置单独存放到另一个文件上，现在我们来看看这个文件中的内容是什么？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      # server块  </span><br><span class="line">server &#123;</span><br><span class="line">        # 监听端口与地址</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        root /var/www/html;</span><br><span class="line"></span><br><span class="line">        server_name _;</span><br><span class="line"># 配置请求的路由</span><br><span class="line">        location / &#123;</span><br><span class="line">                # First attempt to serve request as file, then</span><br><span class="line">                # as directory, then fall back to displaying a 404.</span><br><span class="line">                try_files $uri $uri/ =404;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">                try_files $uri $uri/ =404;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该配置文件中，我们可以设置被代理的服务器，通过location路由匹配则转发到被代理服务器，例如如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat &#123;   </span><br><span class="line">  server 127.0.0.1:7878;</span><br><span class="line">  server 192.168.10.121:3333 backup;  #热备</span><br><span class="line">&#125;</span><br><span class="line">error_page 404 https://www.baidu.com; #错误页</span><br><span class="line">server &#123;</span><br><span class="line">    keepalive_requests 120; #单连接请求上限次数。</span><br><span class="line">    listen       4545;   #监听端口</span><br><span class="line">    server_name  127.0.0.1;   #监听地址       </span><br><span class="line">    location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br><span class="line">       #root path;  #根目录</span><br><span class="line">       #index vv.txt;  #设置默认页</span><br><span class="line">       proxy_pass  tomcat:   #请求转向tomcat，即upstream定义的服务器</span><br><span class="line">       deny 127.0.0.1;  #拒绝的ip</span><br><span class="line">       allow 172.18.5.54; #允许的ip           </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="location配置语法"><a href="#location配置语法" class="headerlink" title="location配置语法"></a>location配置语法</h3><ul><li>location=/uri 精确匹配</li><li>localhost^~/uri前缀匹配</li><li>location / 通用匹配</li></ul><h3 id="参考配置项"><a href="#参考配置项" class="headerlink" title="参考配置项"></a>参考配置项</h3><ul><li>1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；</li><li>2.$remote_user ：用来记录客户端用户名称；</li><li>3.$time_local ： 用来记录访问时间与时区；</li><li>4.$request ： 用来记录请求的url与http协议；</li><li>5.$status ： 用来记录请求状态；成功是200；</li><li>6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；</li><li>7.$http_referer ：用来记录从那个页面链接访问过来的；</li><li>8.$http_user_agent ：记录客户端浏览器的相关信息；</li></ul><h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>安装方法：</p><blockquote><p>./configure –prefix=/安装目录 –add-module = /第三方模块的目录</p></blockquote><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><blockquote><p>负载均衡的大致原理是利用一定的分配策略将网络负载平衡地分摊到网络集群的各个操作单元上，使得单个重负载任务能够分担到多个单元上并行处理，使得大量并发访问或数据流量分担到多个单元上分别处理，从而减少用户的等待响应时间</p></blockquote><p>负载均衡器可以分为软件负载和硬件负载：</p><ul><li>软件负载：NGINX、LVS、HAProxy</li><li>硬件负载：F5、</li></ul><h3 id="NGINX的负载均衡"><a href="#NGINX的负载均衡" class="headerlink" title="NGINX的负载均衡"></a>NGINX的负载均衡</h3><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><ul><li>轮询</li><li>加权轮询</li><li>IP hash：可以解决session不共享的问题</li></ul><h4 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat &#123;   </span><br><span class="line">   server 192.168.11.161:8080 max_fails=2 fail_timeout=60s;  # max_fails最大失败次数；fail_timeout超#时时间</span><br><span class="line">   server 192.168.11.159:8080; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">server &#123;     </span><br><span class="line">   listen 80;    </span><br><span class="line">   server_name localhost;    </span><br><span class="line">   location / &#123;        </span><br><span class="line">   proxy_pass http://tomcat;       </span><br><span class="line">   proxy_set_header Host $host;     </span><br><span class="line">   proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    </span><br><span class="line">   proxy_next_upstream error timeout http_500 http_503;     </span><br><span class="line">   proxy_connect_timeout 60s;      </span><br><span class="line">   proxy_send_timeout 60s;     </span><br><span class="line">   proxy_read_timeout 60s;     </span><br><span class="line">   add_header 'Access-Control-Allow-Origin' '*';      </span><br><span class="line">   add_header 'Access-Control-Allow-Methods' 'GET,POST,DELETE';      </span><br><span class="line">   add_header 'Aceess-Control-Allow-Header' 'Content-Type,*';    </span><br><span class="line">   &#125;    </span><br><span class="line">   location ~ .*\.(js|css|png|svg|ico|jpg)$ &#123;   </span><br><span class="line">     # 防盗链设置</span><br><span class="line">     valid_referers none blocked 192.168.11.160 https://wubc.me;   </span><br><span class="line">     if ($invalid_referer) &#123;    </span><br><span class="line">     return 404;     </span><br><span class="line">     &#125;      </span><br><span class="line">     root static-resource;      </span><br><span class="line">     expires 1d;    </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>几个配置的说明：</p><ul><li>proxy_next_upstream：向一台服务器转发请求出现错误，换一台来处理请求获取直接返回错误状态码</li><li>proxy_connect_timeout：连接超时时间</li><li>proxy_send_timeout：发送数据超时时间</li><li>proxy_read_timeout：读取数据超时时间</li></ul><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><blockquote><p>意思是将服务器的静态文件资源直接存放到NGINX上，当客户端访问时直接返回静态资源，不用再一次转发请求到应用服务器上获取，以提高网站性能为目的</p></blockquote><p>实例，参照前面实例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(js|css|png|svg|ico|jpg)$ &#123;       </span><br><span class="line">   root static-resource;      </span><br><span class="line">   expires 1d;    </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><blockquote><p>将静态资源等设置缓存时间，并告诉游览器</p></blockquote><p>实例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(js|css|png|svg|ico|jpg)$ &#123;       </span><br><span class="line">   root static-resource;      </span><br><span class="line">   expires 1d;    </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><blockquote><p>压缩传输的文件，以提高网站响应速度，可以使用Gzip来进行压缩</p></blockquote><p>实例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http &#123;    </span><br><span class="line">  include       mime.types;    </span><br><span class="line">  default_type  application/octet-stream;       </span><br><span class="line">  sendfile        on;     </span><br><span class="line">  keepalive_timeout  60;         </span><br><span class="line">  ##</span><br><span class="line">  # Gzip Settings</span><br><span class="line">  ##    </span><br><span class="line">  gzip  on;    </span><br><span class="line">  gzip_min_length 5k;  </span><br><span class="line">  gzip_comp_level 3;     </span><br><span class="line">  gzip_types application/javascript image/jpeg image/svg+xml;  </span><br><span class="line">  gzip_buffers 4 32k;   </span><br><span class="line">  gzip_vary on;</span><br><span class="line">  include /etc/nginx/sites-enabled/*;</span><br></pre></td></tr></table></figure><ul><li>gzip on：开启压缩</li><li>gzip_min_length：开始压缩的最小长度</li><li>gzip_comp_level，压缩级别</li><li>gzip_types：需要压缩的文件类型</li><li>gzip_buffers：申请的内存大小，后面跟两个数字，分别代表倍数和申请空间单元，实例表示的是申请4倍的32k内存空间</li><li>gzip_vary：是否传输gzip压缩标识</li></ul><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>解决方法，可以通过location下的add_header来配置，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header 'Access-Control-Allow-Origin' '*';</span><br></pre></td></tr></table></figure><p>设置允许的访问IP为所有</p><h2 id="处理一个请求的流程"><a href="#处理一个请求的流程" class="headerlink" title="处理一个请求的流程"></a>处理一个请求的流程</h2><ul><li><p>nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址</p></li><li><p>nginx的master进程里面，先初始化好这个监控的（创建socket–设置addrreuse等选项–绑定到指定的ip地址端口–在listen），然后再fork出多个子进程出来，然后子进程会竞争accept新的连接。</p></li><li><p>此时，客户端就可以向nginx发起连接了。</p></li><li><p>客户端向Nginx发起连接</p></li><li><p>当客户端与nginx进行三次握手，与nginx建立好一个连接后，此时，某一个子进程会accept成功，得到这个建立好的socket，然后创建nginx对连接的封装，即ngx_connection_t结构体。</p></li><li><p>设置读写事件处理并添加读写事件来与客户端进行数据的交互。</p></li><li><p>nginx或客户端来主动关掉连接</p></li></ul><h2 id="NGINX多进程模型"><a href="#NGINX多进程模型" class="headerlink" title="NGINX多进程模型"></a>NGINX多进程模型</h2><blockquote><p>NGINX使用的是多进程模型，一个master进行下有多个worker进程，可以接受多个客户端连接，在全局块中可以使用worker_processes来设置worker进程数</p></blockquote><h2 id="高可用方案KeepAlived"><a href="#高可用方案KeepAlived" class="headerlink" title="高可用方案KeepAlived"></a>高可用方案KeepAlived</h2><blockquote><p>Keepalived 是一个基于VRRP协议来实现的LVS服务高可用方案，可以利用其来避免单点故障。一个LVS服务会有2台服务器运行Keepalived，一台为主服务器（MASTER），一台为备份服务器（BACKUP），但是对外表现为一个虚拟IP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。Keepalived是VRRP的完美实现。作用是检测web服务器的状态，如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的web服务器从系统中剔除，当web服务器工作正常后Keepalived自动将web服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。</p></blockquote><p>参考：<a href="https://www.cnblogs.com/centos2017/p/7896780.html" target="_blank" rel="noopener">Keepalived 工作原理和配置说明</a></p><p>示例图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/02/2dexstwYlu7TEho.png" alt="keepalived.png" title="">                </div>                <div class="image-caption">keepalived.png</div>            </figure><h2 id="Openresty"><a href="#Openresty" class="headerlink" title="Openresty"></a>Openresty</h2><blockquote><p>Nginx+Lua实现的高性能可伸缩的web平台</p></blockquote><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>待补充</p><h3 id="库文件使用"><a href="#库文件使用" class="headerlink" title="库文件使用"></a>库文件使用</h3><p>openresty提供了丰富的模块，例如可以使用redis.lua操作Redis数据库</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>对服务进行安全校验、流量控制、服务越来越多，那么服务本身不应该关心这些，而是将这些交由网关来处理，统一控制。</p><h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Nginx是一个高性能的反向代理服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本操作&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Nginx" scheme="wbc.wiki/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="wbc.wiki/tags/Nginx/"/>
    
      <category term="容器" scheme="wbc.wiki/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>mybatis技术内幕读书笔之整体架构</title>
    <link href="wbc.wiki/2020/07/09/mybatis%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E4%B9%8B%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>wbc.wiki/2020/07/09/mybatis%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E4%B9%8B%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</id>
    <published>2020-07-09T04:43:24.000Z</published>
    <updated>2020-07-09T04:44:04.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis技术内幕读书笔记（一）"><a href="#Mybatis技术内幕读书笔记（一）" class="headerlink" title="Mybatis技术内幕读书笔记（一）"></a>Mybatis技术内幕读书笔记（一）</h1><h2 id="Java应用执行mybatis的流程"><a href="#Java应用执行mybatis的流程" class="headerlink" title="Java应用执行mybatis的流程"></a>Java应用执行mybatis的流程</h2><ul><li>1、加载mybatis-config.xml配置文件</li><li>2、创建SqlSessionFactory对象</li><li>3、通过SqlSessionFactory创建sqlsession对象</li><li>4、通过sqlsession执行mapper文件的SQL语句</li><li>5、通过sqlsession提交事务</li><li>6、最后关闭sqlsession对象</li></ul><h2 id="mybatis整体架构"><a href="#mybatis整体架构" class="headerlink" title="mybatis整体架构"></a>mybatis整体架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.pianshen.com/images/694/db62d0cafefb88434877c62ef2eed326.png" alt="mybatis整体架构图" title="">                </div>                <div class="image-caption">mybatis整体架构图</div>            </figure><h3 id="基础支撑层"><a href="#基础支撑层" class="headerlink" title="基础支撑层"></a>基础支撑层</h3><ul><li>反射模块：提供良好的反射封装、简洁的API供上层使用</li><li>类型转换：提供别名机制以及JDBC类型和Java类型之间转换的能力</li><li>日志模块：集成第三方日志框架</li><li>资源价值模块：提供加载类文件以及其他资源文件的功能</li><li>解析器模块：解析配置文件、处理动态SQL语句的占位符</li><li>数据源模块：提供与第三方数据源集成的接口</li><li>事务管理：对事务操作进行了封装</li><li>缓存模块：提供一级缓存和二级缓存</li><li>binding模块：将用户自定义的mapper接口和映射配置文件关联</li></ul><h3 id="核心处理层"><a href="#核心处理层" class="headerlink" title="核心处理层"></a>核心处理层</h3><ul><li>配置解析：解析配置文件和mapper文件</li><li>SQL解析：解析mapper文件定义的SQL节点，转成数据库可执行的SQL语句</li><li>SQL执行：包括几个重要的组件：Executor负责维护缓存和事务管理操作；StatementHandler处理数据库委托请求；ParameterHandler完成SQL语句的实参绑定。</li><li>插件：提供插件接口</li></ul><h3 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h3><ul><li>SqlSession：暴露应用程序调用的API供上层调用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mybatis技术内幕读书笔记（一）&quot;&gt;&lt;a href=&quot;#Mybatis技术内幕读书笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;Mybatis技术内幕读书笔记（一）&quot;&gt;&lt;/a&gt;Mybatis技术内幕读书笔记（一）&lt;/h1&gt;&lt;h2 id=&quot;J
      
    
    </summary>
    
    
      <category term="Mybatis" scheme="wbc.wiki/categories/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="wbc.wiki/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringIOC源码分析</title>
    <link href="wbc.wiki/2020/07/09/SpringIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>wbc.wiki/2020/07/09/SpringIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-07-09T04:41:14.000Z</published>
    <updated>2020-07-09T04:41:58.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-IOC源码分析"><a href="#Spring-IOC源码分析" class="headerlink" title="Spring IOC源码分析"></a>Spring IOC源码分析</h1><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/06/01/leyNcqmBXwz57Ap.png" alt="DefaultListableBeanFactory.png" title="">                </div>                <div class="image-caption">DefaultListableBeanFactory.png</div>            </figure><h2 id="阅读入口"><a href="#阅读入口" class="headerlink" title="阅读入口"></a>阅读入口</h2><p><strong>ClassPathXmlApplicationContext</strong></p><h2 id="开始阅读"><a href="#开始阅读" class="headerlink" title="开始阅读"></a>开始阅读</h2><p>从找到这个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] paths, Class&lt;?&gt; clazz, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">Assert.notNull(paths, <span class="string">"Path array must not be null"</span>);</span><br><span class="line">Assert.notNull(clazz, <span class="string">"Class argument must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.configResources = <span class="keyword">new</span> Resource[paths.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.configResources[i] = <span class="keyword">new</span> ClassPathResource(paths[i], clazz);</span><br><span class="line">&#125;</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是refresh这个方法，接下来就是看这个：org.springframework.context.support.AbstractApplicationContext#refresh</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">//调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识，标志已启动标识</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">//告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从</span></span><br><span class="line"><span class="comment">//子类的refreshBeanFactory()方法启动</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">//为BeanFactory配置容器特性，例如类加载器、事件处理器等</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">//为容器的某些子类指定特殊的BeanPost事件处理器</span></span><br><span class="line"><span class="comment">// 如果实现了BeanFactoryPostProcessor这个接口将会调用postProcessBeanFactory方法</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">//调用所有注册的BeanFactoryPostProcessor的Bean</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">//为BeanFactory注册BeanPost事件处理器.</span></span><br><span class="line"><span class="comment">// 注册BeanPostProcessors的实现类，注意这个和BeanFactoryPostProcessor不同</span></span><br><span class="line"><span class="comment">//BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="comment">//初始化信息源，和国际化相关.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">//初始化容器事件传播器.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">//调用子类的某些特殊Bean初始化方法</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">//为事件传播器注册事件监听器.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">//初始化所有剩余的单例Bean</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">//初始化容器的生命周期事件处理器，广播并发布容器的生命周期事件</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line"><span class="comment">//销毁已创建的Bean</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line"><span class="comment">//取消refresh操作，重置容器的同步标识.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>我们一个个来看，首先看的是<strong>org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</strong>这个方法。这个方法是bean创建前的方法，主要目的是准备刷新方法，设置激活标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 记录开始时间</span></span><br><span class="line"><span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 设置closed和active这两个标识的值</span></span><br><span class="line"><span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"><span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">initPropertySources();</span><br><span class="line"><span class="comment">// 校验XML配置文件</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line"><span class="comment">// 关闭旧的BeanFactory，创建新的BeanFactory并返回</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用到了refreshBeanFactory这个方法，所以再来一下这个方法，找到其实现类：<strong>org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">//如果当前ApplicationContext已经有容器，销毁容器中的bean，关闭容器</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建IOC容器：DefaultListableBeanFactory</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line"><span class="comment">// bean的序列化</span></span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line"><span class="comment">//对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等，设置是否允许bean覆盖、循环引用。</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里使用的是<strong>DefaultListableBeanFactory</strong>这个实例来作为bean容器，这个类基本具有了BeanFactory所有子类的特性（从前面的UML图可以得知）。</p></li></ul><p>深入里面看这个方法<strong>org.springframework.context.support.AbstractRefreshableApplicationContext#customizeBeanFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是：设置bean是否允许覆盖和是否允许循环依赖。</p><ul><li>前面refreshBeanFactory方法调用了loadBeanDefinitions，所以我们再来看看这个方法：org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容器使用该读取器读取Bean定义资源</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line"><span class="comment">// resource loading environment.</span></span><br><span class="line"><span class="comment">//为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的</span></span><br><span class="line"><span class="comment">//祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器</span></span><br><span class="line">beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//为Bean读取器设置SAX xml解析器</span></span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line"><span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line"><span class="comment">//当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制</span></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"><span class="comment">//Bean读取器真正实现加载的方法</span></span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>继续看这个真正实现加载的方法：org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.xml.XmlBeanDefinitionReader)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//获取Bean定义资源的定位</span></span><br><span class="line">Resource[] configResources = getConfigResources();</span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位</span></span><br><span class="line"><span class="comment">//的Bean定义资源</span></span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源</span></span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位</span></span><br><span class="line"><span class="comment">//的Bean定义资源</span></span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里有两个分支，第一个调用的org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource…)方法，这个方法往下走调用的是loadBeanDefinitions方法，这个方法有多个实现，我们直接看org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource)这个。</p><p>继续深挖，走到这里org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)这个方法主要通过EncodedResource将资源文件转为InputStream的IO流。</p><p>继续走，里面调用了org.springframework.beans.factory.xml.XmlBeanDefinitionReader#doLoadBeanDefinitions将XML转换为Document对象。</p><p>接着，将document转换为容器的数据结构：org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">//得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析</span></span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="comment">//获得容器中注册的Bean数量</span></span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line"><span class="comment">//解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口,</span></span><br><span class="line"><span class="comment">//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="comment">//统计解析的Bean数量</span></span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里registerBeanDefinitions的使用的是org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#registerBeanDefinitions这个实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获得XML描述符</span></span><br><span class="line"><span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line"><span class="comment">//获得Document的根元素</span></span><br><span class="line">Element root = doc.getDocumentElement();</span><br><span class="line">doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//具体的解析过程由BeanDefinitionParserDelegate实现，</span></span><br><span class="line"><span class="comment">//BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性</span></span><br><span class="line">preProcessXml(root);</span><br><span class="line"><span class="comment">//从Document的根元素开始进行解析Bean定义的Document对象</span></span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line"><span class="comment">//在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性</span></span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法实例化了一个BeanDefinitionParserDelegate对象，这个类包含了<bean>标签的所有属性，在上面代码中，主要关注的是<strong>parseBeanDefinitions</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Bean定义的Document对象使用了Spring默认的XML命名空间</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">//获取Bean定义的Document对象根元素的所有子节点</span></span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="comment">//获得Document节点是XML元素节点</span></span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="comment">//Bean定义的Document的元素节点使用的是Spring默认的XML命名空间</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"><span class="comment">//使用Spring的Bean规则解析元素节点</span></span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//没有使用Spring默认的XML命名空间，则使用用户自定义的解析规则解析元素节点</span></span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的</span></span><br><span class="line"><span class="comment">//解析规则解析Document根节点</span></span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>parseDefaultElement解析的是** <import/> **、<alias />、<bean/>、<beans/> 这几个标签</p></blockquote><blockquote><p>delegate.parseCustomElement解析的是 <mvc/>、<task/>、<context/>、<aop/>标签</p></blockquote><p>来看parseDefaultElement方法里面调用的org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析Bean定义资源Document对象的普通元素</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="comment">// BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类</span></span><br><span class="line"><span class="comment">//对Document对象中&lt;Bean&gt;元素的解析由BeanDefinitionParserDelegate实现</span></span><br><span class="line"><span class="comment">// BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span></span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line"><span class="comment">//向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line"><span class="comment">//在完成向Spring IOC容器注册解析得到的Bean定义之后，发送注册事件</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到这个方法parseBeanDefinitionElement：org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element) 它内部又调用了org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, org.springframework.beans.factory.config.BeanDefinition):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取&lt;Bean&gt;元素中的id属性值</span></span><br><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line"><span class="comment">//获取&lt;Bean&gt;元素中的name属性值</span></span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取&lt;Bean&gt;元素中的alias属性值</span></span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将&lt;Bean&gt;元素中的所有name属性值存放到别名中</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String beanName = id;</span><br><span class="line"><span class="comment">//如果&lt;Bean&gt;元素中没有配置id属性时，并且设置了别名，将别名中的第一个值赋值给beanName</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查&lt;Bean&gt;元素所配置的id或者name的唯一性，containingBean标识&lt;Bean&gt;</span></span><br><span class="line"><span class="comment">//元素中是否包含子&lt;Bean&gt;元素</span></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//检查&lt;Bean&gt;元素所配置的id、name或者别名是否重复</span></span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//详细对&lt;Bean&gt;元素中配置的Bean定义进行解析的地方</span></span><br><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果&lt;Bean&gt;元素中没有配置id、别名或者name，且没有包含子元素&lt;Bean&gt;元素，为解析的Bean生成一个唯一beanName并注册</span></span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果&lt;Bean&gt;元素中没有配置id、别名或者name，且包含了子元素</span></span><br><span class="line"><span class="comment">//&lt;Bean&gt;元素，为解析的Bean使用别名向IOC容器注册</span></span><br><span class="line">beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"><span class="comment">//为解析的Bean使用别名注册时，为了向后兼容</span></span><br><span class="line"><span class="comment">//Spring1.2/2.0，给别名添加类名后缀</span></span><br><span class="line">String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当解析出错时，返回null</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要对name，id，别名 进行了解析。同时调用了org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, java.lang.String, org.springframework.beans.factory.config.BeanDefinition)进行其他属性的解析。所以接着来看parseBeanDefinitionElement方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"><span class="comment">//记录解析的&lt;Bean&gt;</span></span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里只读取&lt;Bean&gt;元素中配置的class名字，然后载入到BeanDefinition中去</span></span><br><span class="line"><span class="comment">//只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成</span></span><br><span class="line">String className = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果&lt;Bean&gt;元素中配置了parent属性，则获取parent属性的值</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line">String parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//根据&lt;Bean&gt;元素配置的class名称和parent属性值创建BeanDefinition</span></span><br><span class="line"><span class="comment">//为载入Bean定义信息做准备</span></span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等</span></span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line"><span class="comment">//为&lt;Bean&gt;元素解析的Bean设置description信息</span></span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line"><span class="comment">//对&lt;Bean&gt;元素的meta(元信息)属性解析</span></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line"><span class="comment">//对&lt;Bean&gt;元素的lookup-method属性解析</span></span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"><span class="comment">//对&lt;Bean&gt;元素的replaced-method属性解析</span></span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析&lt;Bean&gt;元素的构造方法设置</span></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line"><span class="comment">//解析&lt;Bean&gt;元素的&lt;property&gt;设置</span></span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line"><span class="comment">//解析&lt;Bean&gt;元素的qualifier属性</span></span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为当前解析的Bean设置所需的资源和依赖对象</span></span><br><span class="line">bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析&lt;Bean&gt;元素出错时，返回null</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类该方法中主要处理除这name,id,别名三个以外的其他属性数据。回到org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition方法，来看调用的org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将解析的BeanDefinitionHold注册到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean definition under primary name.</span></span><br><span class="line"><span class="comment">//获取解析的BeanDefinition的名称</span></span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line"><span class="comment">//向IOC容器注册BeanDefinition</span></span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line"><span class="comment">//如果解析的BeanDefinition有别名，向容器为其注册别名</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续走，来到这个方法org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验解析的BeanDefiniton</span></span><br><span class="line"><span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 处理重复名称bean定义问题</span></span><br><span class="line"><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="comment">// 不允许覆盖，将抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line"><span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// map中没有，则将beanName和beanDefinition存放到map中</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="comment">//注册的过程中需要线程同步，以保证数据的一致性</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">updatedSingletons.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否有同名的BeanDefinition已经在IOC容器中注册</span></span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">//重置所有已经注册过的BeanDefinition的缓存</span></span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>回到这里org.springframework.context.support.AbstractApplicationContext#refresh，来看里面使用到的org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory方法，代码就不贴了。主要是做了几项工作：设置类的加载器、自动装配时，忽略指定接口，自动进行注册相关bean。</p></li><li><p>再看refresh方法使用到的org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这是Spring3以后新加的代码，为容器指定一个转换服务(ConversionService)</span></span><br><span class="line"><span class="comment">//在对某些Bean属性进行转换时使用</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line"><span class="comment">//为了类型匹配，停止使用临时的类加载器</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line"><span class="comment">//缓存容器中所有注册的BeanDefinition元数据，以防被修改</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">//对配置了lazy-init属性的单态模式Bean进行预实例化处理</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面方法最后一行调用了org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons方法，该方法对配置lazy-init属性单态Bean的预实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="comment">//获取指定名称的Bean定义</span></span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">//Bean不是抽象的，是单态模式的，且lazy-init属性配置为false</span></span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="comment">//如果指定名称的bean是创建容器的Bean</span></span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line"><span class="comment">//FACTORY_BEAN_PREFIX=”&amp;”，当Bean名称前面加”&amp;”符号</span></span><br><span class="line"><span class="comment">//时，获取的是产生容器对象本身，而不是容器产生的Bean.</span></span><br><span class="line"><span class="comment">//调用getBean方法，触发容器对Bean实例化和依赖注入过程</span></span><br><span class="line"><span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="comment">//标识是否需要预实例化</span></span><br><span class="line"><span class="keyword">boolean</span> isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line"><span class="comment">//一个匿名内部类</span></span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(),</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line"><span class="comment">//调用getBean方法，触发容器对Bean实例化和依赖注入过程</span></span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着看org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)这个方法。它实际调用的org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖</span></span><br><span class="line"><span class="comment">//如果指定的是别名，将别名转换为规范的Bean名称</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line"><span class="comment">//先从缓存中取是否已经有被创建过的单态类型的Bean</span></span><br><span class="line"><span class="comment">//对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="comment">//IOC容器创建单例模式Bean实例对象</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="comment">//如果指定名称的Bean在容器中已有单例模式的Bean被创建</span></span><br><span class="line"><span class="comment">//直接返回已经创建的Bean</span></span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理</span></span><br><span class="line"><span class="comment">//注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是</span></span><br><span class="line"><span class="comment">//创建创建对象的工厂Bean，两者之间有区别</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//缓存没有正在创建的单例模式Bean</span></span><br><span class="line"><span class="comment">//缓存中已经有已经创建的原型模式Bean</span></span><br><span class="line"><span class="comment">//但是由于循环引用的问题导致实例化对象失败</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否</span></span><br><span class="line"><span class="comment">//能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器</span></span><br><span class="line"><span class="comment">//的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="comment">//当前容器的父级容器存在，且当前容器中不存在指定名称的Bean</span></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line"><span class="comment">//解析指定Bean名称的原始名称</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="comment">//委派父级容器根据指定名称和显式的参数查找</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="comment">//委派父级容器根据指定名称和类型查找</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建的Bean是否需要进行类型验证，一般不需要</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="comment">//向容器标记指定的Bean已经被创建</span></span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//根据指定Bean名称获取其父级的Bean定义</span></span><br><span class="line"><span class="comment">//主要解决Bean继承时子类合并父类公共属性问题</span></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// 检查合并的属性</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line"><span class="comment">//获取当前Bean所有依赖Bean的名称</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="comment">//如果当前Bean有依赖Bean</span></span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归调用getBean方法，获取当前Bean的依赖Bean</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="comment">//把被依赖Bean注册给当前依赖的Bean</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="comment">//创建单例模式Bean的实例对象</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line"><span class="comment">//显式地从容器单例模式Bean缓存中清除实例对象</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IOC容器创建原型模式Bean实例对象</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line"><span class="comment">//原型模式(Prototype)是每次都会创建一个新的对象</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象</span></span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="comment">//创建指定Bean对象实例</span></span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定Bean的原型对象不再创建</span></span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要创建的Bean既不是单例模式，也不是原型模式，则根据Bean定义资源中</span></span><br><span class="line"><span class="comment">//配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中</span></span><br><span class="line"><span class="comment">//比较常用，如：request、session、application等生命周期</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="comment">//Bean定义资源中没有配置生命周期范围，则Bean定义不合法</span></span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例</span></span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line"><span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"><span class="comment">//对创建的Bean实例对象进行类型检查</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line"><span class="comment">//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="comment">//校验和准备Bean中的方法覆盖</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="comment">//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建Bean的入口</span></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装被创建的Bean对象</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 说明不是 FactoryBean</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"><span class="comment">//获取实例化对象的类型</span></span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="comment">//调用PostProcessor后置处理器</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="comment">//向容器中缓存单例模式的Bean对象，以防循环引用</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line"><span class="comment">//Bean对象的初始化，依赖注入在此触发</span></span><br><span class="line"><span class="comment">//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">//初始化Bean对象，完成各种回调</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">//获取指定名称的已注册的单例模式Bean对象</span></span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//根据名称获取的已注册的Bean和正在实例化的Bean是同一个</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line"><span class="comment">//当前实例化的Bean初始化完成</span></span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="comment">//获取当前Bean所依赖的其他Bean</span></span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="comment">//对依赖Bean进行类型检查</span></span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="comment">//注册完成依赖注入的Bean</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上面使用到几个方法作分析：</p></li><li><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//检查确认Bean是可实例化的</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用工厂方法对Bean进行实例化</span></span><br><span class="line"><span class="comment">// 检查类的访问权限</span></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line"><span class="comment">//调用工厂方法实例化</span></span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用容器的自动装配方法进行实例化</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="comment">//配置了自动装配属性，使用容器的自动装配实例化</span></span><br><span class="line"><span class="comment">//容器的自动装配是根据参数类型匹配Bean的构造方法</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//使用默认的无参构造方法实例化</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Bean的构造方法进行实例化</span></span><br><span class="line"><span class="comment">// 判断是否采用有参构造方法</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line"><span class="comment">//使用容器的自动装配特性，调用匹配的构造方法实例化</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的无参构造方法实例化</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBeanInstance创建bean实例：首先判断能否实例化以及检查其访问权限。其次根据不同条件来对bean进行实例化，有工厂方法的则使用工厂实例化，后根据是否配置了自动装配属性来进行自动装配实例化，否则使用无参构造方法实例化。</p><p>以无参构造instantiateBean(beanName, mbd)为例，我们可以挖到这里org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(org.springframework.beans.factory.support.RootBeanDefinition, java.lang.String, org.springframework.beans.factory.BeanFactory)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;<span class="comment">//如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法</span></span><br><span class="line"><span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">Constructor&lt;?&gt; constructorToUse;</span><br><span class="line"><span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="comment">//获取对象的构造方法或工厂方法</span></span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="comment">//如果没有构造方法且没有工厂方法</span></span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//使用JDK的反射机制，判断要实例化的Bean是否是接口</span></span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line"><span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//这里是一个匿名内置类，使用反射机制获取Bean的构造方法</span></span><br><span class="line">constructorToUse = AccessController.doPrivileged(</span><br><span class="line">(PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) () -&gt; clazz.getDeclaredConstructor());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">constructorToUse =clazz.getDeclaredConstructor();</span><br><span class="line">&#125;</span><br><span class="line">bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化</span></span><br><span class="line"><span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line"><span class="comment">//使用CGLIB来实例化对象</span></span><br><span class="line"><span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里实例化了对象，但是还没有对属性进行赋值的。</p><ul><li><p>接下来看org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean方法中使用到的org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Bean属性设置到生成的实例对象上</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="comment">// 获取所有后置处理器</span></span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"><span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="comment">// 表示不需要后续对属性进行设置，不需要经过BeanPostProcessor处理</span></span><br><span class="line">continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值</span></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对依赖注入处理，首先处理autowiring自动装配的依赖注入</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Bean名称进行autowiring自动装配处理</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Bean类型进行autowiring自动装配处理</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对非autowiring的属性进行依赖注入处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//对属性进行注入</span></span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的作用就是将Bean属性设置到生成的实例对象上</p></li><li><p>最后看到org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容器创建的Bean实例对象，为其添加BeanPostProcessor后置处理器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="comment">//JDK的安全机制验证权限</span></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//实现PrivilegedAction接口的匿名内部类</span></span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//为Bean实例对象包装相关属性，如名称，类加载器，所属容器等信息</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="comment">//对BeanPostProcessor后置处理器的postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment">//回调方法的调用，为Bean实例初始化前做一些处理</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Bean实例对象初始化的方法，这个初始化方法是在Spring Bean定义配置</span></span><br><span class="line"><span class="comment">//文件中通过init-method属性指定的</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对BeanPostProcessor处理器的postProcessAfterInitialization</span></span><br><span class="line"><span class="comment">//回调方法的调用，为Bean实例初始化之后做一些处理</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li><li><p>几个重要的类：BeanDefinitionHolder、BeanDefinition、BeanDefinitionParserDelegate、AbstractBeanDefinition、FactoryBean、BeanFactory</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-IOC源码分析&quot;&gt;&lt;a href=&quot;#Spring-IOC源码分析&quot; class=&quot;headerlink&quot; title=&quot;Spring IOC源码分析&quot;&gt;&lt;/a&gt;Spring IOC源码分析&lt;/h1&gt;&lt;h2 id=&quot;UML图&quot;&gt;&lt;a href=&quot;#U
      
    
    </summary>
    
    
      <category term="Spring" scheme="wbc.wiki/categories/Spring/"/>
    
    
      <category term="Spring" scheme="wbc.wiki/tags/Spring/"/>
    
      <category term="IOC" scheme="wbc.wiki/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>并发队列原理之ConcurrentLinkedQueue原理解析</title>
    <link href="wbc.wiki/2020/07/09/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E4%B9%8BConcurrentLinkedQueue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>wbc.wiki/2020/07/09/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E4%B9%8BConcurrentLinkedQueue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2020-07-09T04:39:15.000Z</published>
    <updated>2020-07-09T04:39:36.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发队列原理之ConcurrentLinkedQueue原理解析"><a href="#并发队列原理之ConcurrentLinkedQueue原理解析" class="headerlink" title="并发队列原理之ConcurrentLinkedQueue原理解析"></a>并发队列原理之ConcurrentLinkedQueue原理解析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>ConcurrentLinkedQueue是无界非阻塞队列，底层有单向链表实现，通过CAS来保证线程的安全</p></blockquote><p>使用Node内部类作为链表的节点，Node的item域存放节点的值，next表示下一个节点，类图如下：</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="offer方法：在队列尾部添加一个元素，返回为true，不能添加null元素"><a href="#offer方法：在队列尾部添加一个元素，返回为true，不能添加null元素" class="headerlink" title="offer方法：在队列尾部添加一个元素，返回为true，不能添加null元素"></a>offer方法：在队列尾部添加一个元素，返回为true，不能添加null元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查元素是否为空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 插入尾部的元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"><span class="comment">// 从尾节点开始循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="comment">// 通过CAS将队列原最后一个元素的next指向新节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// 由于自引用问题需要重新找新的head</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 寻找尾节点</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add方法：实际调用的内部offer方法"><a href="#add方法：实际调用的内部offer方法" class="headerlink" title="add方法：实际调用的内部offer方法"></a>add方法：实际调用的内部offer方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll方法：移除队列头部一个元素，并返回该值，队列为空则返回null"><a href="#poll方法：移除队列头部一个元素，并返回该值，队列为空则返回null" class="headerlink" title="poll方法：移除队列头部一个元素，并返回该值，队列为空则返回null"></a>poll方法：移除队列头部一个元素，并返回该值，队列为空则返回null</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            <span class="comment">// 当前节点有值则设置为null</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    <span class="comment">// 从链表中移除</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前队列为空则返回null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点被自引用了，重新寻找队列头节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="comment">// 发现头结点被修改，通过goto预缴跳出外层循环重新获取头结点</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="peek方法：获取头节点元素但是不移除"><a href="#peek方法：获取头节点元素但是不移除" class="headerlink" title="peek方法：获取头节点元素但是不移除"></a>peek方法：获取头节点元素但是不移除</h3><p>具体逻辑跟poll差不多，区别在于不需要移除元素</p><h3 id="remove方法：移除指定元素，存在多个则移除第一个"><a href="#remove方法：移除指定元素，存在多个则移除第一个" class="headerlink" title="remove方法：移除指定元素，存在多个则移除第一个"></a>remove方法：移除指定元素，存在多个则移除第一个</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; next, pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; pred = p, p = next) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            <span class="comment">// 使用CAS设置为null</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!o.equals(item)) &#123;</span><br><span class="line">                    next = succ(p);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                removed = p.casItem(item, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取next节点</span></span><br><span class="line">            next = succ(p);</span><br><span class="line">            <span class="comment">// 前驱节点和next节点都不为空，则链接前驱节点到next节点</span></span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) <span class="comment">// unlink</span></span><br><span class="line">                pred.casNext(p, next);</span><br><span class="line">            <span class="keyword">if</span> (removed)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发队列原理之ConcurrentLinkedQueue原理解析&quot;&gt;&lt;a href=&quot;#并发队列原理之ConcurrentLinkedQueue原理解析&quot; class=&quot;headerlink&quot; title=&quot;并发队列原理之ConcurrentLinkedQueue
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock原理分析</title>
    <link href="wbc.wiki/2020/07/09/ReentrantReadWriteLock%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>wbc.wiki/2020/07/09/ReentrantReadWriteLock%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2020-07-09T04:38:24.000Z</published>
    <updated>2020-07-09T04:38:47.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReentrantReadWriteLock原理分析"><a href="#ReentrantReadWriteLock原理分析" class="headerlink" title="ReentrantReadWriteLock原理分析"></a>ReentrantReadWriteLock原理分析</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>ReentrantReadWriteLock采用读写分离的策略，允许多个线程同时获取读锁，写锁是独占式锁，读写锁之间为互斥。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/02/4AzipD7PCRgGK1F.png" alt="ReentrantReadWriteLock.png" title="">                </div>                <div class="image-caption">ReentrantReadWriteLock.png</div>            </figure><p>其内部有内部类：WriteLock和ReadLock，分别表示写锁和读锁的操作。ReentrantReadWriteLock中将状态值state分为了两部分，第一部分高16位表示的是读状态（获取到读锁的次数），低16位表示是写状态（获取到写锁的次数）。</p><p>其内部类Sync的成员变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享锁偏移量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 共享锁（读锁）状态单位值65536</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 排它锁（写锁）掩码，二进制，15个1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 返回读锁线程数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">// 返回写锁可重入个数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"><span class="comment">// 第一个获取到锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 第一个获取到读锁的线程获取读锁的可重入次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"><span class="comment">// 最后一个获取读锁的线程获取读锁的可重入次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br></pre></td></tr></table></figure><h2 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>ReentrantReadWriteLock的写锁是独占锁也是可重入锁，如果写锁和读锁没有被获取，那么当前线程可以获取到写锁，否则线程被挂起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock的lock方法同样是java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire实现的。里面使用到tryAcquire方法是Sync重写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该tryAcquire方法同样是掉用其的Sync内部类实现</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 获取可重入次数</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 不为0则写锁或读锁已经被其他线程获取了</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// c!=0且w为0说明低16位为0，高16位不为0，这就代表了读锁已经被获取了，w不为0，代表写锁被获取了</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="comment">// 读锁别获取了或者当前线程不是写锁持有者，则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 设置可重入次数</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h3><p>对中断进行响应的获取锁的方法</p><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h3><p>尝试获取写，成功返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">        <span class="comment">//  c!=0且w为0说明低16位为0，高16位不为0，这就代表了读锁已经被获取了，w不为0，代表写锁被获取了</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryLock-long-timeout-TimeUnit-unit"><a href="#tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="tryLock(long timeout, TimeUnit unit)"></a>tryLock(long timeout, TimeUnit unit)</h3><p>增加超时等待获取锁，能够对中断进行响应</p><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><p>尝试释放锁，对状态值减一，减一后结果为0则会释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用子类的tryRelease方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断释放锁的是否是锁的持有线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 状态值减一</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        <span class="comment">// 如果未0则成功释放锁</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 否则只是进行简单的减一</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读锁的获取和释放"><a href="#读锁的获取和释放" class="headerlink" title="读锁的获取和释放"></a>读锁的获取和释放</h2><h3 id="lock-1"><a href="#lock-1" class="headerlink" title="lock"></a>lock</h3><p>如果写锁没有被获取，则读锁可以被获取，获取后状态值的高16位的值加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用的是具体子类的方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用的是AQS的方法</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 判断写锁是否被占用,如果获取到写锁的不是当前线程则返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取读锁持有的线程数</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// r等于0表示读锁是第一次被获取，则设置当前线程为第一个获取到锁的线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">// 设置读锁的可重入次数为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程是第一个获取到读锁的线程，则重入次数加一</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 记录其他线程获取读锁的可重入数或记录最后一个获取读锁的线程</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程已经获取到写锁，而后先要获取读锁是允许的。readerShouldBlock用来判断队列中的第一个元素是否正尝试或获取写锁，不是则判断获取读锁的可重入次数是否达到了最大值。</p><h3 id="tryLock-1"><a href="#tryLock-1" class="headerlink" title="tryLock"></a>tryLock</h3><p>尝试获取锁</p><h3 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h3><p>释放锁，跟写锁的过程查不到，多了对firstReader、firstReaderHoldCount和cachedHoldCounter的额外处理，并通过自旋释放锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReentrantReadWriteLock原理分析&quot;&gt;&lt;a href=&quot;#ReentrantReadWriteLock原理分析&quot; class=&quot;headerlink&quot; title=&quot;ReentrantReadWriteLock原理分析&quot;&gt;&lt;/a&gt;Reentran
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock解析</title>
    <link href="wbc.wiki/2020/07/09/ReentrantLock%E8%A7%A3%E6%9E%90/"/>
    <id>wbc.wiki/2020/07/09/ReentrantLock%E8%A7%A3%E6%9E%90/</id>
    <published>2020-07-09T04:37:28.000Z</published>
    <updated>2020-07-09T04:38:05.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>ReentrantLock是一个可重入的独占锁</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/02/1Y6tSikGXEyIT7g.png" alt="ReentrantLock.png" title="">                </div>                <div class="image-caption">ReentrantLock.png</div>            </figure><p>内部类Sync有两个子类NonfairSync和FairSync，分别表示获取锁的非公平策略和公平策略</p><h2 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h2><h3 id="lock方法"><a href="#lock方法" class="headerlink" title="lock方法"></a>lock方法</h3><p>获取到锁将AQS的state值修改为1，如果该线程之前已经获取锁了，state会进行加一，获取锁失败会将该线程存放到AQS阻塞队列。</p><p>ReentrantLock的lock方法实际上调用器内部类Sync的lock方法，而在Sync内部根据实现策略的不同，公平锁则使用的是FairSync的lock方法，非公平锁则调用的是NonfairSync的lock方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过CAS设置状态值</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 设置成功则设置持有锁线程为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果获取锁失败则会调用acquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquire失败则把当前线程放入到AQS阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在非公平锁中</strong>，tryAcquire方法实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置状态值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 如果当前线程是该锁持有者</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 则直接将状态值加一</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在公平锁中</strong>，tryAcquire方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前状态值为0，并且前面没有等待的队列，则设置持有锁的线程为当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与非公平锁相比，多了一步hasQueuedPredecessors的判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 头结点与为节点不相等，并且第一个元素不是当前元素</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lockInterruptibly方法"><a href="#lockInterruptibly方法" class="headerlink" title="lockInterruptibly方法"></a>lockInterruptibly方法</h3><p>与lock比较，增加了对中断响应的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程被中断，则直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 尝试获取资源</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        <span class="comment">// 调用AQS的可被中断的方法</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 在AQS阻塞队列中添加一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 自璇</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点是头结点并且获取锁成功，则将新添加的节点作为头节点，原来的头节点移除掉</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果失败后需要挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryLock方法"><a href="#tryLock方法" class="headerlink" title="tryLock方法"></a>tryLock方法</h3><p>尝试获取锁，获取成功返回true，否则false，不会进行阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用的前面提交的非公平锁的nonfairTryAcquire方法。</p><h3 id="tryLock-long-timeout-TimeUnit-unit-方法"><a href="#tryLock-long-timeout-TimeUnit-unit-方法" class="headerlink" title="tryLock(long timeout, TimeUnit unit)方法"></a>tryLock(long timeout, TimeUnit unit)方法</h3><p>与tryLock方法比较，增加超时返回机制，在指定时间内没有获取到锁将不会阻塞下去，会返回执行下一步操作。</p><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><h3 id="unlock方法"><a href="#unlock方法" class="headerlink" title="unlock方法"></a>unlock方法</h3><p>如果该线程持有锁，则将状态值减一，减后的状态值为0则释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他调用java.util.concurrent.locks.AbstractQueuedSynchronizer#release的方法，而该方法里面调用了ReetrantLock的tryAcquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态值减一</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 释放锁的标记</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 清空持有锁的线程信息</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReentrantLock&quot;&gt;&lt;a href=&quot;#ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock&quot;&gt;&lt;/a&gt;ReentrantLock&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; cla
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList浅析</title>
    <link href="wbc.wiki/2020/07/09/CopyOnWriteArrayList%E6%B5%85%E6%9E%90/"/>
    <id>wbc.wiki/2020/07/09/CopyOnWriteArrayList%E6%B5%85%E6%9E%90/</id>
    <published>2020-07-09T04:36:26.000Z</published>
    <updated>2020-07-09T04:36:56.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><h2 id="常用方法分析"><a href="#常用方法分析" class="headerlink" title="常用方法分析"></a>常用方法分析</h2><h3 id="add-添加元素"><a href="#add-添加元素" class="headerlink" title="add 添加元素"></a>add 添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原来的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制元素到新数组，新数组长度是原来数组长度的+1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取指定位置的元素"><a href="#获取指定位置的元素" class="headerlink" title="获取指定位置的元素"></a>获取指定位置的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (E) a[index];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>get方法没有加锁，如果一个线程在获取元素的同时有一个线程删除了某些元素，那么会产生弱一致性问题，弱一致性是指返回迭代器后，其他线程对list的增删改查是不可见的</p><h3 id="指定位置修改值"><a href="#指定位置修改值" class="headerlink" title="指定位置修改值"></a>指定位置修改值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原来的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取指定位置的旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="comment">// 如果旧值与要指定修改的值不一致则复制新数组，在新数组中修改该位置的值</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果要删除的元素是最后一个元素则直接复制一个新数组，新数组长度比原来的数组长度小一</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话需要进行两次复制数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CopyOnWriteArrayList的增删改的操作都加入锁，且进行了复制数组的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CopyOnWriteArrayList&quot;&gt;&lt;a href=&quot;#CopyOnWriteArrayList&quot; class=&quot;headerlink&quot; title=&quot;CopyOnWriteArrayList&quot;&gt;&lt;/a&gt;CopyOnWriteArrayList&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>并发包中锁原理剖析</title>
    <link href="wbc.wiki/2020/07/09/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E9%94%81%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>wbc.wiki/2020/07/09/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E9%94%81%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</id>
    <published>2020-07-09T04:35:37.000Z</published>
    <updated>2020-07-09T04:35:57.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发包中锁原理剖析"><a href="#并发包中锁原理剖析" class="headerlink" title="并发包中锁原理剖析"></a>并发包中锁原理剖析</h1><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><blockquote><p>主要作用是挂起和唤醒线程</p></blockquote><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li>park：挂起线程</li><li>unpark：如果因park挂起的，调用unpark后，线程被唤醒</li><li>parkNanos：如果没有拿到许可证，超时后会自动返回</li><li>parkUntil：与parkNanos区别是parkUntil的时间是从1970年开始算的</li></ul><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><blockquote><p>抽象队列同步器，是一个双向队列，通过Node类型的head和tail记录队首和队尾元素。Node的thread变量记录进行AQS的线程</p></blockquote><p><strong>Node元素</strong>：</p><ul><li>SHARED：标记该线程是获取<strong>共享资源</strong>时被阻塞挂起后放入AQS队列的</li><li>EXCLUSIVE：标记获取<strong>独占资源</strong>时阻塞被挂起后放入AQS队列的</li><li>waitStatus：线程等待状态：<ul><li>CANCELLED</li><li>SIGNAL</li><li>CONDITION</li><li>PROPAGATE</li></ul></li><li>head：记录队首</li><li>tail：记录队尾元素</li><li>thread：记录进入AQS的线程</li></ul><p><strong>ConditionObject</strong></p><p>用来结合锁实现线程同步，可以直接访问AQS内部变量。ConditionObject作为条件变量，每个条件变量对应一个条件队列。</p><p><strong>AQS操作state的方式</strong></p><ul><li>独占方式：一个线程获取到了锁，其他线程获取失败进入阻塞。获取到锁的线程,，AQS会利用CAS将state状态值有0设置为1，如果锁是可重入的，已经获取到锁的线程再次获取时会将state值递增加一。</li><li>共享方式：类似于信号量的获取，如果一个信号被线程获取了，其他线程尝试获取时如果信号量满足条件则可以获取到锁。</li></ul><p><strong>AQS的条件变量的支持</strong></p><p>条件变量为signal和await，AQS一个锁可以对应多个条件变量，每个条件变量内部维护一个条件队列，存放调用条件变量await方法是被阻塞的线程。</p><p>条件变量作用示例：线程A获取到锁后调用了锁创建的条件变量1，那么线程A会释放锁，当前线程被转换为Node节点插入条件变量1的条件队列。</p><p>await方法：调用该方法前需要获取到锁，调用方法后会将该线程放到条件变量的阻塞队列（不是AQS队列）。然后释放锁。</p><p>signal方法：将条件队列中队头的线程节点移除，并放入AQS阻塞队列，激活这个线程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发包中锁原理剖析&quot;&gt;&lt;a href=&quot;#并发包中锁原理剖析&quot; class=&quot;headerlink&quot; title=&quot;并发包中锁原理剖析&quot;&gt;&lt;/a&gt;并发包中锁原理剖析&lt;/h1&gt;&lt;h2 id=&quot;LockSupport&quot;&gt;&lt;a href=&quot;#LockSupport&quot; c
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之CountDownLatch源码分析</title>
    <link href="wbc.wiki/2020/07/09/J-U-C%E4%B9%8BCountDownLatch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>wbc.wiki/2020/07/09/J-U-C%E4%B9%8BCountDownLatch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-07-09T04:34:38.000Z</published>
    <updated>2020-07-09T04:35:01.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念与作用"><a href="#概念与作用" class="headerlink" title="概念与作用"></a>概念与作用</h2><blockquote><p>CountDownLatch是JUC包下提供的一个工具类，它的作用是让一个或者一组线程等待其他线程执行完成后，自己再接着执行，count数不为0则线程进行等待。</p></blockquote><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>await：执行等待，计数不为0则进入等待</li><li>await(long timeout, TimeUnit unit)：超时则自动唤醒，继续往下走</li><li>coutDown：计数减一</li><li>getCount：获取当前计数的值</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><blockquote><p>底层使用一个Sync内部类实现，改类继承了AbstractQueuedSynchronizer</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul><li><p>Sync构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 在构造方法中设置同步变量state的值</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">          setState(count);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>获取共享锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 尝试在获取共享锁</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// state为0返回1，否则返回-1</span></span><br><span class="line">         <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>释放共享锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试释放锁</span></span><br><span class="line"><span class="comment">     * 该方法的调用实际是CountDownLatch调用countDonwn后使用AQS中的releaseShared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// state已为0则返回失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 通过CAS设置状态</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法：await方法"><a href="#核心方法：await方法" class="headerlink" title="核心方法：await方法"></a>核心方法：await方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">// 使用的是AQS的acquireSharedInterruptibly方法</span></span><br><span class="line">      sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法内部调用了AQS的acquireSharedInterruptibly方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireSharedInterruptibly方法分两步进行分析</p></li><li><p>tryAcquireShared：实际调用的是java.util.concurrent.CountDownLatch.Sync#tryAcquireShared，该方法上面有提及到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// state为0返回1，否则返回-1</span></span><br><span class="line">         <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>doAcquireSharedInterruptibly</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 新建并将共享节点加入到等待队列</span></span><br><span class="line">      <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// 或取前驱节点</span></span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">              <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">   <span class="comment">// 当前节点是队列中等待的第一个节点则尝试获取锁</span></span><br><span class="line">                  <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                  <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// r&gt;=0了获取到锁，设置当前节点为头结点</span></span><br><span class="line">                      setHeadAndPropagate(node, r);</span><br><span class="line"><span class="comment">// 在队列中删除原头结点</span></span><br><span class="line">                      p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                      failed = <span class="keyword">false</span>;</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"><span class="comment">// 判断获取失败后是否需要等待并进行中断检查</span></span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着来看一下setHeadAndPropagate方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">      Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line"><span class="comment">// 设置头结点</span></span><br><span class="line">      setHead(node);</span><br><span class="line">      <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">          (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          Node s = node.next;</span><br><span class="line">          <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">              doReleaseShared();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>propagate &gt; 0 说明state已经为0了；如果propagate &gt; 0或者头结点为空，或头结点的等待状态小于0，则获取该节点的后继节点，并判断如果没有后继节点或者后继节点为共享模式，则调用doReleaseShared方法，doReleaseShared方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         Node h = head;</span><br><span class="line">         <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">  <span class="comment">// 获取头节点的等待状态</span></span><br><span class="line">             <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">             <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">    <span class="comment">// 如果状态为SIGNAL则进行CAS更新</span></span><br><span class="line">                 <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                     <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"><span class="comment">// 释放后继节点</span></span><br><span class="line">                 unparkSuccessor(h);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                      !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line"> <span class="comment">//  如果等待状态为0，且节点状态为PROPAGATE，则继续循环</span></span><br><span class="line">                 <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里顺便提一下Node的状态：</p></li><li><p>CANCELLED =  1: 被取消，当线程等待超时或被中断</p></li><li><p>SIGNAL    = -1：通知，当前线程释放了，通知后继节点</p></li><li><p>CONDITION = -2：节点处于等待队列中，调用signal方法后，节点转移到同步队列中，加入到同步状态的获取中</p><ul><li>PROPAGATE = -3; 下一次共享状态将会被无条件传播下去</li></ul></li></ul><h3 id="核心方法：countDown方法"><a href="#核心方法：countDown方法" class="headerlink" title="核心方法：countDown方法"></a>核心方法：countDown方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync.releaseShared(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法调用的AQS的releaseShared方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，这里使用到tryReleaseShared方法和doReleaseShared方法，下面做分析：</p><ul><li>tryReleaseShared 尝试获取共享锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// state已为0则返回失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 通过CAS设置状态</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>doReleaseShared：执行释放锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">               <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">  <span class="comment">// 如果头结点的状态为SIGNAL，进行CAS更新</span></span><br><span class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"><span class="comment">// 释放后继节点</span></span><br><span class="line">                   unparkSuccessor(h);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>前面都有提到的unparkSuccessor方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取节点状态</span></span><br><span class="line">     <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">     <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="comment">// 节点状态小于0，则该节点的状态可能为：SIGNAL、CONDITION、PROPAGATE</span></span><br><span class="line">         compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     Node s = node.next;</span><br><span class="line">     <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 下一个节点的等待状态为CANCELLED或为空，则先置空</span></span><br><span class="line">         s = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">             <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">   <span class="comment">// 后循环释放节点的状态为：SIGNAL、CONDITION、PROPAGATE的后继节点</span></span><br><span class="line">                 s = t;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">         LockSupport.unpark(s.thread);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念与作用&quot;&gt;&lt;a href=&quot;#概念与作用&quot; class=&quot;headerlink&quot; title=&quot;概念与作用&quot;&gt;&lt;/a&gt;概念与作用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;CountDownLatch是JUC包下提供的一个工具类，它的作用是让一个或者一组线程等待
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列 </title>
    <link href="wbc.wiki/2020/07/09/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>wbc.wiki/2020/07/09/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-07-09T04:32:44.000Z</published>
    <updated>2020-07-09T04:33:11.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>通过全局锁的方式，同时只能有一个线程进行存放元素到队列或一个线程从队列中获取元素</p><ul><li><p>offer方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      checkNotNull(e);</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count == items.length)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              enqueue(e);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">该方法首先获取锁，通过其构造方法可以知道，这个锁是非公平锁：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;java</span><br><span class="line">    public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">        if (capacity &lt;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        this.items &#x3D; new Object[capacity];</span><br><span class="line">        lock &#x3D; new ReentrantLock(fair);</span><br><span class="line">        notEmpty &#x3D; lock.newCondition();</span><br><span class="line">        notFull &#x3D;  lock.newCondition();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>note</strong>: 非公平锁：直接尝试占有锁；公平锁，先判断当前线程是否是第一个线程，是则获取锁，否则添加到等待队列上。</p><p>然后调用enqueue方法将元素添加到队列上;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完后，通过 <strong>notEmpty.signal()</strong> 知非空对队列。</p><p>notEmpty和notFull是Condition类型的示例.</p></li></ul><h5 id="PriorityBlockingQueue-无界优先级队列"><a href="#PriorityBlockingQueue-无界优先级队列" class="headerlink" title="PriorityBlockingQueue 无界优先级队列"></a>PriorityBlockingQueue 无界优先级队列</h5><p>内部使用到比较器，用来比较元素大小，由于这是无界队列所以这里没有notFul。默认按元素升序。元素需要实现Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_INITIAL_CAPACITY = <span class="number">11</span> <span class="comment">//队列默认大小</span></span><br></pre></td></tr></table></figure><p>为什么是11？</p><ul><li><p>offer 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">int</span> n, cap;</span><br><span class="line">     Object[] array;</span><br><span class="line">    <span class="comment">// 元素个数大于了队列容量，则使用tryGrow进行扩容</span></span><br><span class="line">     <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">         tryGrow(array, cap);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">         <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">             siftUpComparable(n, e, array);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">         size = n + <span class="number">1</span>;</span><br><span class="line">         notEmpty.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到扩容时调用了tryGrow方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                 <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果oldCap大于等于64，那么队列新的容量则扩容50%</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                   (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>note</strong>：</p><ul><li><p>为什么是64作为阈值？</p></li><li><p>为什么要提前释放锁</p></li><li><p>扩容的时候可以进行入队列操作，所以是用到CAS，只允许一个线程进行扩容，如果扩容失败了，则通过Thread.yield()让出CPU，让改线程重新获取锁。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (newArray &#x3D;&#x3D; null) &#x2F;&#x2F; back off if another thread is allocating</span><br><span class="line"> Thread.yield();</span><br></pre></td></tr></table></figure></blockquote><p>复制数组是在获取锁后面才执行的，是为了保证复制的数组是最新的。</p><p>排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 确定父节点元素位置</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取父节点的值</span></span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="comment">// 如果插入的值比父节点大，那么完成堆的建立</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>例子：假设有三个节点0、1、2，值也是0、1、2。1、2分别是0节点的左右子节点，那么如果插入的k=3,这时先找出他要插入位置的父节点，通过<strong>(k-1)&gt;&gt;&gt;1</strong>可以得出，parent=1,也就是1节点，这个时候将这个插入的值跟其父节点的值进行比较，如果发现是大于父节点的值，那么完成堆的构建，跳出循环。否则与父节点进行交换，</p></li></ul><ul><li><p>poll方法</p><p>该方法通过dequeue方法进行出队列，获取元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        E result = (E) array[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 获取队列尾部元素，然后将原来的位置的指向设置为空</span></span><br><span class="line">        E x = (E) array[n];</span><br><span class="line">        array[n] = <span class="keyword">null</span>;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 把元素插入到下标为0的位置上，然后调整成最小堆</span></span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>note</strong>：最小堆构建过程</p></li></ul><ul><li><p>take操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列没有元素则一直阻塞</p></li></ul><h5 id="SychronousQueue-同步队列"><a href="#SychronousQueue-同步队列" class="headerlink" title="SychronousQueue 同步队列"></a>SychronousQueue 同步队列</h5><p>内部没有容器，只能存放一个元素，只要元素被消费了，才能继续take存放，否则一直阻塞。SychronousQueue 使用的CAS来实现线程的安全访问。</p><p>公平模式下的实现：队尾匹配，队头出队。底层实现：使用<strong>TransferQueue</strong>内部队列。</p><p>非公平模式下的实现：后入栈、先匹配。 底层使用TransferStack栈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阻塞队列&quot;&gt;&lt;a href=&quot;#阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列&quot;&gt;&lt;/a&gt;阻塞队列&lt;/h1&gt;&lt;h5 id=&quot;ArrayBlockingQueue&quot;&gt;&lt;a href=&quot;#ArrayBlockingQueue&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之CycliBarrier使用</title>
    <link href="wbc.wiki/2020/07/09/J-U-C%E4%B9%8BCycliBarrier%E4%BD%BF%E7%94%A8/"/>
    <id>wbc.wiki/2020/07/09/J-U-C%E4%B9%8BCycliBarrier%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-09T04:30:56.000Z</published>
    <updated>2020-07-09T04:31:25.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>实现屏障等待功能，支持多个线程一起完成任务的目标，与CountDownLatch相比较，CyclicBarrier侧重的是一个线程没完成任务，则多个线程必须等待。</p></blockquote><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>await：等待</li><li>await(long timeout, TimeUnit unit)：在规定时间内还没达到parties数量，则抛出超时异常</li><li>getNumberWaiting: 获取已到屏障掉的线程数</li><li>getParties：获取parties数</li><li>isBroken: 判断屏障是否处于损坏状态</li><li>reset：重置屏障，即将原来的parties重置为初始值</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierDemo1</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"完成了"</span>);</span><br><span class="line">            <span class="comment">// 全部完成才会是否</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// cyclicBarrier全部执行了将会回调run方法</span></span><br><span class="line">                System.out.println(<span class="string">"全部已完成"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> CyclicBarrierDemo1(cyclicBarrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程数等于CyclicBarrier的parties数时，这是正常的，大于也是正常的，但是线程数如果小于parties了，那么将会一直阻塞。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>屏障重置性：parties可以重置归为0</li><li>破坏模型：当其中一个线程中断或提前离开了屏障点，其他线程也会离开屏障点</li></ul><h2 id="与CountDownLatch比较"><a href="#与CountDownLatch比较" class="headerlink" title="与CountDownLatch比较"></a>与CountDownLatch比较</h2><ul><li>CountDownLatch的计数不能重置，CyclicBarrier可以</li><li>CountDownLatch计数为0释放等待的线程，CyclicBarrier达到指定值，释放等待的线程</li><li>CountDownLatch不可以重复利用，CyclicBarrier可以</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul><li>内部类，该类表示代<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static class Generation &#123;</span><br><span class="line">      boolean broken &#x3D; false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>lock：表示获取当锁</li><li>parties：指定parties数量</li><li>generation：当前代</li><li>count：仍在等待的数量</li></ul><h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>它调用了dowait方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 表示当前“代”</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// 判断屏障是否损坏</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 进行破坏屏障</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="comment">// 表示所有线程都达到屏障了</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 那么将会回调执行CyclicBarries的run方法</span></span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 可以认为执行栅栏任务成功了</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    <span class="comment">// 执行失败，则破坏屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// timed这个值是由构造方法决定的，如果是使用有超时设置的构造方法，那么该值为true</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    <span class="comment">// 否则等待指定的时长</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 当前代，且屏障没有被破坏</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="comment">// 判断当前CyclicBarrier是不是这代的，不是则直接返回下标</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;实现屏障等待功能，支持多个线程一起完成任务的目标，与CountDownLatch相比较，CyclicBarrier
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>并发编程基础</title>
    <link href="wbc.wiki/2020/07/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>wbc.wiki/2020/07/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-09T04:29:30.000Z</published>
    <updated>2020-07-09T04:29:59.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程基础"><a href="#并发编程基础" class="headerlink" title="并发编程基础"></a>并发编程基础</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul><li>进程：程序的一次执行，是资源的基本分配单位</li><li>线程：CPU调度的基本单元，同一个进程下的线程共享进程的资源，但每个线程都有自己的程序计数器和栈区域，线程间不共享</li></ul><h3 id="线程的创建方法"><a href="#线程的创建方法" class="headerlink" title="线程的创建方法"></a>线程的创建方法</h3><ul><li>实现Runnable接口：</li><li>继承Thread，重写run方法</li><li>使用FutureTask方式，构造参数可以接收Callable对象和Runnable对象</li></ul><h3 id="通知与等待"><a href="#通知与等待" class="headerlink" title="通知与等待"></a>通知与等待</h3><blockquote><p>等待是线程处于阻塞状态，持有了锁，通知是唤醒等待的线程</p></blockquote><p><strong>wait方法</strong>：</p><p>是Object的方法，对象将释放锁，如果对象没有获取到对象监视器时调用wait方法将抛出异常，因为只要线程持有了锁才能释放锁，获取对象监视器的方法可以使用Synchronized关键字，为了防止虚假唤醒（即没有使用notify唤醒线程）可以添加判断唤醒条件是否满足来处理。</p><p>共享对象调用wait方法，则当前线程只会释放当前共享对象的锁，其他的不会被释放。</p><p>wait方法还有个带超时参数的，如果在指定时间内被唤醒，那么将返回，继续往下走</p><p><strong>notify方法</strong>：</p><p>随机唤醒一个被挂起的线程，被唤醒的线程不一定执行，，需要获取到对象监视器才可以继续执行</p><p><strong>notifyAll方法</strong></p><p>唤醒所有因wait方法而被挂起的线程</p><h3 id="等待线程终止"><a href="#等待线程终止" class="headerlink" title="等待线程终止"></a>等待线程终止</h3><p><strong>join方法</strong>：</p><p>等待多个线程处理完任务后才返回，否则阻塞</p><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p><strong>sleep方法</strong></p><p>该方法不释放锁，休眠不参与CPU的调度</p><h3 id="让出CPU执行权"><a href="#让出CPU执行权" class="headerlink" title="让出CPU执行权"></a>让出CPU执行权</h3><p><strong>yield方法</strong></p><p>让出CPU执行权，即使它还没有执行完让任务</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p><strong>interrupt方法</strong></p><p>中断线程，实际上只是设置有一个中断标志位的值为true，如果线程被挂起了，当有其他线程中断这个线程时会抛出InterruptedException异常。</p><p><strong>isInterrupted方法</strong></p><p>判断线程是否被中断</p><p><strong>interrupted方法</strong>：</p><p>该方法是静态的，注意这个与<strong>interrupt方法</strong>不同，这个方法作用是检查当前线程是否被中断，它与<strong>isInterrupted</strong>方法也不同：如果发现当前线程被中断了，则会清除中断标志。“获取的当前调用线程的中断标志而不是调用interruped方法的示实例对象的中断标志”，也就是如果主线程里的子线程调用了<strong>interrupt</strong>方法设置了中断标志位，那么执行<strong>interrupted</strong>方法获取的却是主线程的中断标志。</p><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><blockquote><p>多个线程执行过程中，因争夺资源而造成相互等待的现象</p></blockquote><p>死锁产生的条件：</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不可以剥夺条件</li><li>环路等待条件</li></ul><h3 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h3><blockquote><p> 线程可以分为守护线程和用户线程，当用户线程还没有结束时，JVM不会退出， 而守护线程不会影响JVM的退出&gt;。</p></blockquote><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><blockquote><p>提供保存线程本地变量的作用，对于ThreadLocal变量的操作，线程本地会有这个变量的本地副本，多个线程的操作都是操作自己本地内存里的副本。</p></blockquote><p>每个线程Thread里都有一个ThreadLocalMap的对象threadLocals，key为ThreadLocal变量的this引用，value为自定义设置。</p><p>当设置value时，首先通过getMap获取到对应的线程变量ThreadLocalMap，如果不为空，则直接设置该值，否则创建并实例化ThreadLocalMap。</p><p>当获取value时，同样也是先获取ThreadLocalMap对象，通过获取ThreadLocalMap的内部类Entry来获取值。如果ThreadLocalMap对象为空，首先会进行初始化，初始化的value为null。</p><p><strong>InheritableThreadLocal</strong></p><p>该类继承了ThreadLocal，提供了子线程可以访问父线程设置的本地变量的作用。</p><h2 id="并发有三个主要问题"><a href="#并发有三个主要问题" class="headerlink" title="并发有三个主要问题"></a>并发有三个主要问题</h2><ul><li>原子性</li><li>有序性</li><li>可见性</li></ul><h2 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h2><blockquote><p>提供原子性、有序性、可见性的保障，对被修饰的变量的获取途径由工作内存改为直接从主内存中获取。存在弊端是会引起线程上下文的切换。</p></blockquote><p>作用范围</p><ul><li>代码块</li><li>对象</li><li>类</li></ul><h2 id="volitile关键字"><a href="#volitile关键字" class="headerlink" title="volitile关键字"></a>volitile关键字</h2><blockquote><p>保证变量的可见性和禁止重排序，当修改变量的值时会立即将该值刷回主内存，但是不保证原子性</p></blockquote><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><blockquote><p>JMM会对不存在数据依赖性的指令进行重排序，已提交编译速度，重排序后的执行结果与程序顺序执行的结果一致</p></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li>悲观锁：认为数据很容易被其他线程修改，所以数据在处理前需要进行加锁</li><li>乐观锁：认为数据一般情况下不会冲突，只有在数据提交更新时才会对数据冲突进行检测</li></ul><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><blockquote><p>以线程获取锁的抢占机制可以将锁分为公平锁和非公平锁</p></blockquote><ul><li><p>公平锁：线程获取锁的顺序以按照请求锁的时间顺序类决定</p></li><li><p>非公平锁：与公平锁相比，不按照顺序来，获取锁的时机不一定，与公平锁性能开销比较，性能较高</p><p>实现例子：ReentrantLock(isFairLock) 如果isFairLock为true则为公平锁，否则为非公平锁。</p></li></ul><h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><blockquote><p>按照锁能被单个线程持有还是能被多个线程持有，可以将锁分为独占锁和共享锁</p></blockquote><ul><li>独占锁：锁只能被一个线程持有，是一种悲观锁实现例子：ReentrantLock</li><li>独占锁：锁能被多个线程持有，是一种乐观锁，实现例子：ReadWriteLock读写锁</li></ul><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><blockquote><p>持有锁的线程多次获取已经持有的锁的时候不被阻塞，那么该锁为可重入锁，synchronized内部锁是重入锁</p></blockquote><p>重入N次，需要释放N次才能真正释放掉锁？</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p>当前线程没有获取到锁时，并不立即阻塞，而是重试多次获取锁，如果尝试指定次数后还没有获取到锁，那么线程才会被阻塞。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程基础&quot;&gt;&lt;a href=&quot;#并发编程基础&quot; class=&quot;headerlink&quot; title=&quot;并发编程基础&quot;&gt;&lt;/a&gt;并发编程基础&lt;/h1&gt;&lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之ScheduledExecutorService使用</title>
    <link href="wbc.wiki/2020/07/09/J-U-C%E4%B9%8BScheduledExecutorService%E4%BD%BF%E7%94%A8/"/>
    <id>wbc.wiki/2020/07/09/J-U-C%E4%B9%8BScheduledExecutorService%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-09T04:27:25.000Z</published>
    <updated>2020-07-09T04:28:00.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>将定时任务和线程池功能结合起来</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutoreDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Callable&gt; callableList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        callableList.add(<span class="keyword">new</span> MyCallableA());</span><br><span class="line">        callableList.add(<span class="keyword">new</span> MyCallableB());</span><br><span class="line">        <span class="comment">// 使用的是单任务的计划任务池</span></span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        ScheduledFuture futureA = scheduledExecutorService.schedule(callableList.get(<span class="number">0</span>), <span class="number">4</span>, TimeUnit.SECONDS);</span><br><span class="line">        ScheduledFuture futureB = scheduledExecutorService.schedule(callableList.get(<span class="number">1</span>), <span class="number">4</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Begin: "</span> + System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">"futureA: "</span> + futureA.get());</span><br><span class="line">            System.out.println(<span class="string">"futureB: "</span> + futureB.get());</span><br><span class="line">            System.out.println(<span class="string">"End: "</span> + System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallableA</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"return A"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallableB</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"return B"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例的作用是延迟4秒后执行任务；schedule方法中的第一个参数也可以接收runnable类型的参数</p><ul><li><p>scheduleAtFixedRate：周期性执行任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFuture&lt;?&gt; scheduledFuture = scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> MyRunnable(), <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">      System.out.println(scheduledFuture.get());</span><br></pre></td></tr></table></figure><p>需要注意的是该方法获取的scheduledFuture对象是无法获取到返回值的。</p></li><li><p>scheduleWithFixedDelay：该方法也是周期性执行任务</p></li><li><p>getQueue：获取队列中的任务，该队列中存放的是将要执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">scheduledThreadPoolExecutor.getQueue();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>remove：在队列中移除指定的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor.remove</span><br></pre></td></tr></table></figure></li><li><p>setExecuteExistingDelayedTasksAfterShutdownPolicy：默认值为true，作用是当执行了shutdown方法后，判断任务是否继续执行，true则继续执行</p></li><li><p>setContinueExistingPeriodicTasksAfterShutdownPolicy：当为true时，使用<strong>scheduleWithFixedDelay</strong>和<strong>scheduleAtFixedRate</strong>，如果执行了shutdown方法，则任务还会继续执行</p></li><li><p>cancel：是否取消任务，但是该任务依然会存在队列中，只是任务不会被执行</p></li><li><p>setRemoveOnCancelPolicy：是否将取消的任务从队列中清除</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;将定时任务和线程池功能结合起来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之Executor 和ThreadPoolExecutor知识总结</title>
    <link href="wbc.wiki/2020/07/09/J-U-C%E4%B9%8BExecutor-%E5%92%8CThreadPoolExecutor%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>wbc.wiki/2020/07/09/J-U-C%E4%B9%8BExecutor-%E5%92%8CThreadPoolExecutor%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-09T04:26:05.000Z</published>
    <updated>2020-07-09T04:26:55.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>线程池接口，不能被直接使用，需要实现类</p></blockquote><p>继承结构如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/06/11/GErzkwYbIytavip.png" alt="Excutor类及其相关子类.png" title="">                </div>                <div class="image-caption">Excutor类及其相关子类.png</div>            </figure><h3 id="Executor使用示例"><a href="#Executor使用示例" class="headerlink" title="Executor使用示例"></a>Executor使用示例</h3><ul><li><p>newCachedThreadPool</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" begin: "</span> + System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"end: "</span> + System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>newCachedThreadPool(ThreadFactory threadFactory): 参数ThreadFactory示例，而ThreadFactory是一个接口，因此可以实现该接口，重写newThread方法，实现我们想要的功能</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CustomizeFactory customizeFactory=<span class="keyword">new</span> CustomizeFactory();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool(customizeFactory);</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" begin: "</span> + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"end: "</span> + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizeFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.setName(<span class="string">"自定义的线程工厂"</span>);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>newFixedThreadPool(int nThreads): 有界的线程池，可以设置线程池中的线程最大数量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" begin: "</span> + System.currentTimeMillis());</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"end: "</span> + System.currentTimeMillis());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  示例中即使execute了大于三次，实际上也只会使用三个线程</p></li><li><p>newFixedThreadPool(int nThreads, ThreadFactory threadFactory)：可以自定义线程工厂，并设置线程池最大个数</p></li><li><p>newSingleThreadExecutor：创建单一线程，实际上是调用ThreadPoolExecutor并指定corePoolSize和maximumPoolSize都为1实现的</p></li></ul><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><ul><li><p>invokeAny：取得第一个完成任务的结果值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        List callableList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        callableList.add(<span class="keyword">new</span> CallableA());</span><br><span class="line">        callableList.add(<span class="keyword">new</span> CallableB1());</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        String value = executorService.invokeAny(callableList);</span><br><span class="line">        System.out.println(<span class="string">"结果为: "</span>+value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableA</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"CallableA "</span> + Math.random());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"callableA"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableB1</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"CallableB1 "</span> + Math.random());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CallableB1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>invokeAny(Collection&lt;? extends Callable<T>&gt; tasks,</p><pre><code>long timeout, TimeUnit unit)：在指定时间内取得第一个先执行任务的结果值</code></pre></li></ul><ul><li><p>invokeAll(Collection&lt;? extends Callable<T>&gt; tasks)：返回所有任务的执行结果</p></li><li><p>invokeAll(Collection&lt;? extends Callable<T>&gt; tasks,</p><pre><code>long timeout, TimeUnit unit):如果全部任务在指定时间内没有完成，则抛出异常</code></pre></li></ul><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="概念与作用"><a href="#概念与作用" class="headerlink" title="概念与作用"></a>概念与作用</h3><blockquote><p>Executor的可以直接实例化的实现类，用于创建线程池对象</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><p>构造方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue)</span><br></pre></td></tr></table></figure><p>构造方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure><p>构造方法三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><p>构造方法四：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><ul><li>corePooSize：核心线程数最大值</li><li>maximumPoolSize：线程池最大线程数</li><li>keepAliveTime：线程数大于corePoolSize时，超过该时间，将会删除，为0时，线程执行完任务会立即在队列中删除</li><li>unit： 时间单位</li><li>workQueue：执行前用于保持任务的队列 </li><li>threadFactory：线程工厂</li><li>handler：处理任务被拒绝执行时的行为，RejectedExecutionHandler是一个接口，如果我们想自定义拒绝处理行为，那么可以类似这样：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizeExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"被拒绝执行了"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在创建线程池时使用</span></span><br><span class="line">   ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">3</span>, <span class="number">9999L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">      threadPoolExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> CustomizeExecutionHandler());</span><br></pre></td></tr></table></figure></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>shutdown：执行完当前任务后，主线程结束，不在添加新的任务，队列中任务还是会正常执行的</li><li>shutdownNow：中断所有任务，队列中未执行的线程不再执行，同时会返回未被执行的任务列表，如果在shutdownNow方法后面又execute线程，将会抛出异常</li><li>isShutdown：判断线程池是否关闭</li><li>awaitTermination(long timeout, TimeUnit unit)：如果有任务正在执行，阻塞线程，在指定时间之后，再去判断线程池是否已经关闭了，否则不阻塞</li><li>allowCoreThreadTimeOut(boolean value) ：设置核心线程是否具有超时效果，超时时间由创建线程池时指定</li></ul><p><strong>几个要点说明</strong></p><ul><li>1、创建的线程数量小于corePoolSize，那么即使设置了超时时间，该参数也不会起作用</li><li>2、创建的线程大于corePoolSize，并且小于等于最大线程数，workQueue使用的时<strong>LinkedBlockDeue</strong>队列，那么maximumPoolSize和keepAliveTime可以被忽略</li><li>3、创建的线程大于corePoolSize，并且小于等于最大线程数，workQueue使用的时<strong>SynchronousQueue</strong>队列，那么maximumPoolSize和keepAliveTime会起作用</li></ul><h3 id="执行流程图"><a href="#执行流程图" class="headerlink" title="执行流程图"></a>执行流程图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://imgedu.lagou.com/1f3d144584b54235811b65ffe091dc09.jpg" alt="执行流程图" title="">                </div>                <div class="image-caption">执行流程图</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Executor&quot;&gt;&lt;a href=&quot;#Executor&quot; class=&quot;headerlink&quot; title=&quot;Executor&quot;&gt;&lt;/a&gt;Executor&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之Fork-Join使用</title>
    <link href="wbc.wiki/2020/07/09/J-U-C%E4%B9%8BFork-Join%E4%BD%BF%E7%94%A8/"/>
    <id>wbc.wiki/2020/07/09/J-U-C%E4%B9%8BFork-Join%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-09T04:24:13.000Z</published>
    <updated>2020-07-09T04:25:34.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><blockquote><p>ForkJoinPool继承AbstractExecutorService，提供线程池的功能</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><p>execute：以异步的形式执行任务，该方法 没有返回值</p></li><li><p>submit：有返回值，使用ForkJoinTask的get方法获取</p></li><li><p>invoke：异步执行任务，直接将返回结果返回</p></li><li><p>shutdown：关闭任务，但不具有中断的效果</p></li><li><p>shutdownNow：如果跟isInterrupted==true来判断，那么会立即停止当前正在执行的任务，并不允许接收新任务；没有跟isInterrupted==true来判断，那么当前执行的任务会正常运行到结束</p></li><li><p>isTerminated()：如果关闭后所有任务都已完成则返回true</p></li><li><p>isShutdown：判断任务是否关闭</p></li><li><p>awaitTermination：等待线程池被销毁的最长时间，具有阻塞性</p></li><li><p>isCompletedNormally:判断任务是否正常执行完毕</p></li><li><p>getException：获取任务执行时返回的异常信息</p></li></ul><h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p>执行任务的具体类，但该类是一个抽象类，下面三个类是其子类：</p><ul><li><p>RecursiveAction：没有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveActionDemo1</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> beginValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> endValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecursiveActionDemo1</span><span class="params">(<span class="keyword">int</span> beginValue, <span class="keyword">int</span> endValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beginValue = beginValue;</span><br><span class="line">        <span class="keyword">this</span>.endValue = endValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-----------开始"</span>);</span><br><span class="line">        <span class="keyword">if</span> (endValue - beginValue &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> middleNum = (beginValue + endValue) / <span class="number">2</span>;</span><br><span class="line">            RecursiveActionDemo1 leftAction = <span class="keyword">new</span> RecursiveActionDemo1(beginValue, middleNum);</span><br><span class="line">            RecursiveActionDemo1 rightAction = <span class="keyword">new</span> RecursiveActionDemo1(middleNum+<span class="number">1</span>, endValue);</span><br><span class="line">            <span class="keyword">this</span>.invokeAll(leftAction, rightAction);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"打印组合为: "</span> + beginValue + <span class="string">"---"</span> + endValue);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-----------结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        forkJoinPool.submit(<span class="keyword">new</span> RecursiveActionDemo1(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>CountedCompleter：具有返回值</li></ul><ul><li><p>RecursiveTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTaskDemo1</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        RecursiveTaskDemo1 recursiveTaskDemo1 = <span class="keyword">new</span> RecursiveTaskDemo1();</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; joinTask = forkJoinPool.submit(recursiveTaskDemo1);</span><br><span class="line">        System.out.println(<span class="string">"joinTask: "</span> + joinTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>ForkJoinTask有两种方法获取返回值：get和join，前者遇到异常时能够进行捕获，join则直接抛出，执行多个 任务时join获取结果是同步的</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;ForkJoinPool继承AbstractExecutorService，提供线程池的功能&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之Phaser移相器使用</title>
    <link href="wbc.wiki/2020/07/09/J-U-C%E4%B9%8BPhaser%E7%A7%BB%E7%9B%B8%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>wbc.wiki/2020/07/09/J-U-C%E4%B9%8BPhaser%E7%A7%BB%E7%9B%B8%E5%99%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-09T04:21:18.000Z</published>
    <updated>2020-07-09T04:23:14.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念与作用"><a href="#概念与作用" class="headerlink" title="概念与作用"></a>概念与作用</h2><blockquote><p>移相器，可用于线程进行分组同步控制，解决分阶段共同完成任务的需求</p></blockquote><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li>arriveAndAwaitAdvance：到达屏障处等待，等待其他线程达到屏障处，满足条件后继续向下一个屏障执行</li><li>arriveAndDeregister：动态撤销线程在phaser的注册，表示不参与后面阶段工作</li><li>getPhase：获取已经达到第几个屏障</li><li>onAdvance：通过新屏障时被调用，如果通过第一个屏障时返回了true，那么后面的phaser不进行工作，取消屏障   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">2</span>) &#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registerdParties)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"被调用了"</span>);</span><br><span class="line"><span class="comment">// true不进行等待</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>getRegisteredParties：获取注册的parties数目</li><li>register: 动态增加parties值，每次加一</li><li>bulkRegister：动态增加parties值，可以指定每次增加的数目</li><li>getArrivedParties：获取已使用的parties的数目</li><li>getUnarrivedParties：获取未使用的parties的数目</li><li>arrive：是parties加一，且不再屏障出等待</li><li>awaitAdvance(int phase)：如果参数和getPhase方法返回值一样，则在屏障出等待，否则继续执行。</li><li>awaitAdvanceInterruptibly(int phase)：表示可中断</li><li>awaitAdvanceInterruptibly(int phase,long timeout, TimeUnit unit)：指定栏数等待最大的单位时间，如在指定时间内栏数没有变化，则继续向下运行</li><li>forceTermination：是凭证处于终结状态，即屏障失效</li><li>isTerminated：判断phaser是否失效</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" One Begin"</span> + System.currentTimeMillis());</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" One End"</span> + System.currentTimeMillis());</span><br><span class="line"> phaser.getArrivedParties();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Two Begin"</span> + System.currentTimeMillis());</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Two End"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" One Begin"</span> + System.currentTimeMillis());</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" One End"</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Two Begin"</span> + System.currentTimeMillis());</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Two End"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(Phaser phaser)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            PhaserDemo1.testA();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(Phaser phaser)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            PhaserDemo1.testA();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Phaser phaser;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(Phaser phaser)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            PhaserDemo1.testB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">3</span>);</span><br><span class="line">        PhaserDemo1.phaser=phaser;</span><br><span class="line">        <span class="keyword">new</span> ThreadA(phaser).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadB(phaser).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadC(phaser).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是如果parties数大于线程数，将会一直阻塞</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念与作用&quot;&gt;&lt;a href=&quot;#概念与作用&quot; class=&quot;headerlink&quot; title=&quot;概念与作用&quot;&gt;&lt;/a&gt;概念与作用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;移相器，可用于线程进行分组同步控制，解决分阶段共同完成任务的需求&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
      <category term="多线程" scheme="wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发包" scheme="wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper选举算法分析: 以FastLeader为例</title>
    <link href="wbc.wiki/2020/04/28/Zookeeper%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-%E4%BB%A5FastLeader%E4%B8%BA%E4%BE%8B/"/>
    <id>wbc.wiki/2020/04/28/Zookeeper%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-%E4%BB%A5FastLeader%E4%B8%BA%E4%BE%8B/</id>
    <published>2020-04-28T13:35:04.000Z</published>
    <updated>2020-04-28T13:36:01.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper选举算法分析-以FastLeader为例"><a href="#Zookeeper选举算法分析-以FastLeader为例" class="headerlink" title="Zookeeper选举算法分析: 以FastLeader为例"></a>Zookeeper选举算法分析: 以FastLeader为例</h1><h3 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h3><p>源码入口: <strong>org.apache.zookeeper.server.quorum.QuorumPeerMain#initializeAndRun</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeAndRun</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ConfigException, IOException, AdminServerException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        QuorumPeerConfig config = <span class="keyword">new</span> QuorumPeerConfig();</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            config.parse(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start and schedule the the purge task</span></span><br><span class="line">        DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(config</span><br><span class="line">                .getDataDir(), config.getDataLogDir(), config</span><br><span class="line">                .getSnapRetainCount(), config.getPurgeInterval());</span><br><span class="line">        purgeMgr.start();</span><br><span class="line">        <span class="comment">// 判断是单机还是集群模式</span></span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.isDistributed()) &#123;</span><br><span class="line">            runFromConfig(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.warn(<span class="string">"Either no config or no quorum defined in config, running "</span></span><br><span class="line">                    + <span class="string">" in standalone mode"</span>);</span><br><span class="line">            <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">            ZooKeeperServerMain.main(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">首先判断一下如果是集群模式的话，则会调用 **org.apache.zookeeper.server.quorum.QuorumPeerMain#runFromConfig**方法</span><br><span class="line">这个方法主要是读取配置文件信息对**QuorumPeer**进行初始化。最后开启线程</span><br><span class="line">```java</span><br><span class="line">quorumPeer.start()</span><br></pre></td></tr></table></figure><p><em>ps:QuorumPeer翻译过来就是仲裁人</em></p><p>接着我们来到org.apache.zookeeper.server.quorum.QuorumPeer#start这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"My id "</span> + myid + <span class="string">" not in the peer list"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// 从本地文件中恢复数据</span></span><br><span class="line">        loadDataBase();</span><br><span class="line">        startServerCnxnFactory();</span><br><span class="line">        ...</span><br><span class="line">        startLeaderElection();</span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">这里又调用了loadDataBase这个方法，这个方法主要获取当前的epoch和最新的zxid;接着调用org.apache.zookeeper.server.quorum.QuorumPeer#startLeaderElection方法进行选举初始化。</span><br><span class="line">```java</span><br><span class="line">   <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 如果当前是LOOKING状态，则投票给自己</span></span><br><span class="line">           <span class="keyword">if</span> (getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">               currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">接着就是使用createElectionAlgorithm，这个方法主要目的就是根据配置文件中配置的选举算法类型，创建选举算法。</span><br><span class="line">```java</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span></span>&#123;</span><br><span class="line">        Election le=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">        <span class="keyword">switch</span> (electionAlgorithm) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            le = <span class="keyword">new</span> LeaderElection(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">// 默认是这个</span></span><br><span class="line">            QuorumCnxManager qcm = createCnxnManager();</span><br><span class="line">            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);</span><br><span class="line">            <span class="keyword">if</span> (oldQcm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Clobbering already-set QuorumCnxManager (restarting leader election?)"</span>);</span><br><span class="line">                oldQcm.halt();</span><br><span class="line">            &#125;</span><br><span class="line">            QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">            <span class="keyword">if</span>(listener != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//启动已绑定端口的选举线程，等待集群中其他机器的连接</span></span><br><span class="line">                listener.start();</span><br><span class="line">                FastLeaderElection fle = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">                fle.start();</span><br><span class="line">                le = fle;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> le;</span><br><span class="line">```   </span><br><span class="line">实例化FastLeaderElection，对proposedLeader、proposedZxid、接收队列和发送队列进行初始化。</span><br><span class="line">通过FastLeaderElection的start方法启动选举线程，这里也启动了两个队列：发送队列和接收队列.</span><br><span class="line">```java</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.wsThread.start();</span><br><span class="line">            <span class="keyword">this</span>.wrThread.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>接着来到<strong>org.apache.zookeeper.server.quorum.QuorumPeer#run</strong>这个方法里，这里面有段主要的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LOOKING:</span><br><span class="line">                   <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"readonlymode.enabled"</span>)) &#123;</span><br><span class="line">                       <span class="keyword">final</span> ReadOnlyZooKeeperServer roZk =</span><br><span class="line">                           <span class="keyword">new</span> ReadOnlyZooKeeperServer(logFactory, <span class="keyword">this</span>, <span class="keyword">this</span>.zkDb);</span><br><span class="line">                       Thread roZkMgr = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                               <span class="keyword">try</span> &#123;</span><br><span class="line">                                   sleep(Math.max(<span class="number">2000</span>, tickTime));</span><br><span class="line">                                   <span class="keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                       roZk.startup();</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           roZkMgr.start();</span><br><span class="line">                           reconfigFlagClear();</span><br><span class="line">                           <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                               shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                               startLeaderElection();</span><br><span class="line">                           &#125;</span><br><span class="line">                     setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                          reconfigFlagClear();</span><br><span class="line">                           <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                              shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                              startLeaderElection();</span><br><span class="line">                              &#125;</span><br><span class="line">                    setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       &#125;                        </span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><p>上诉代码通过** setCurrentVote(makeLEStrategy().lookForLeader());**进行最终确认选举算法。</p><p>这里以FastLeaderElection算法为例，setCurrentVote第二个参数正是<br>org.apache.zookeeper.server.quorum.FastLeaderElection#lookForLeader方法。在这个方法中使用logicalclock.incrementAndGet();来表示epoch，使用 <strong>updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</strong> 来更新投票结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateProposal</span><span class="params">(<span class="keyword">long</span> leader, <span class="keyword">long</span> zxid, <span class="keyword">long</span> epoch)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    proposedLeader = leader;</span><br><span class="line">    proposedZxid = zxid;</span><br><span class="line">    proposedEpoch = epoch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>sendNotifications</strong>发送投票结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNotifications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> sid : self.getCurrentAndNextConfigVoters()) &#123;</span><br><span class="line">        QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">        <span class="comment">// 创建要发送的消息</span></span><br><span class="line">        ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                proposedLeader,</span><br><span class="line">                proposedZxid,</span><br><span class="line">                logicalclock.get(),</span><br><span class="line">                QuorumPeer.ServerState.LOOKING,</span><br><span class="line">                sid,</span><br><span class="line">                proposedEpoch, qv.toString().getBytes());</span><br><span class="line">        <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 添加到发送队列</span></span><br><span class="line">        sendqueue.offer(notmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续来看lookForLeader方法，当状态处于LOOKING时，一直循环从接收队列中拿出投票消息，并判断消息是否发送完毕，是则再次发送，否则执行以下逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到投票信息，判断消息是否属于这个集群</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (n.state) &#123;</span><br><span class="line">                        <span class="keyword">case</span> LOOKING:</span><br><span class="line">                            <span class="comment">// If notification &gt; current, replace and send messages out</span></span><br><span class="line">                            <span class="comment">// 如果当前消息的epoch大于logicalclock，表示这是新的一场投票</span></span><br><span class="line">                            <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;</span><br><span class="line">                            <span class="comment">// 更新本地epoch</span></span><br><span class="line">                                logicalclock.set(n.electionEpoch);</span><br><span class="line">                                 <span class="comment">// 清空原来的接收消息的队列</span></span><br><span class="line">                                recvset.clear();</span><br><span class="line">                                <span class="comment">// 检查是否可以对方胜出</span></span><br><span class="line">                                <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                        getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</span><br><span class="line">                                         <span class="comment">// 更新票据结果为对方票据</span></span><br><span class="line">                                    updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 否则票据不变</span></span><br><span class="line">                                    updateProposal(getInitId(),</span><br><span class="line">                                            getInitLastLoggedZxid(),</span><br><span class="line">                                            getPeerEpoch());</span><br><span class="line">                                &#125;</span><br><span class="line">                                sendNotifications();</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;</span><br><span class="line">                                <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">                        ...</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                    proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                                    <span class="comment">// epoch相同，则比较zxid和myid</span></span><br><span class="line">                                updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                                sendNotifications();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line"> ...</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// don't care about the version if it's in LOOKING state</span></span><br><span class="line">                            <span class="comment">// 添加到本机投票集合，用作最终选举终结判断</span></span><br><span class="line">                            recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (termPredicate(recvset,</span><br><span class="line">                                    <span class="keyword">new</span> Vote(proposedLeader, proposedZxid,</span><br><span class="line">                                            logicalclock.get(), proposedEpoch))) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">while</span>((n = recvqueue.poll(finalizeWait,</span><br><span class="line">                                        TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                                         <span class="comment">// 一直等待新的通知，直到超时，作用是：</span></span><br><span class="line">                                    <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                            proposedLeader, proposedZxid, proposedEpoch))&#123;</span><br><span class="line">                                        recvqueue.put(n);</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 如果当前服务器是leader，那么修改状态为leading</span></span><br><span class="line">                                    self.setPeerState((proposedLeader == self.getId()) ?</span><br><span class="line">                                            ServerState.LEADING: learningState());</span><br><span class="line">                                    Vote endVote = <span class="keyword">new</span> Vote(proposedLeader,</span><br><span class="line">                                            proposedZxid, logicalclock.get(),</span><br><span class="line">                                            proposedEpoch);</span><br><span class="line">                                            <span class="comment">// 将接收队列清空</span></span><br><span class="line">                                    leaveInstance(endVote);</span><br><span class="line">                                    <span class="keyword">return</span> endVote;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br></pre></td></tr></table></figure><p>上述方法使用到<strong>totalOrderPredicate</strong>，该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">totalOrderPredicate</span><span class="params">(<span class="keyword">long</span> newId, <span class="keyword">long</span> newZxid, <span class="keyword">long</span> newEpoch, <span class="keyword">long</span> curId, <span class="keyword">long</span> curZxid, <span class="keyword">long</span> curEpoch)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(self.getQuorumVerifier().getWeight(newId) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((newEpoch &gt; curEpoch) ||</span><br><span class="line">            ((newEpoch == curEpoch) &amp;&amp;</span><br><span class="line">            ((newZxid &gt; curZxid) || ((newZxid == curZxid) &amp;&amp; (newId &gt; curId)))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法便可以得知：<strong>投票的PK是先比较epoch，如果相同则再比较zxid，如果zxid也相同，那么则比较severID</strong>。</p><p>使用到<strong>termPredicate</strong>方法判断选举是否结束，默认超过半数server同意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">termPredicate</span><span class="params">(Map&lt;Long, Vote&gt; votes, Vote vote)</span> </span>&#123;</span><br><span class="line">        SyncedLearnerTracker voteSet = <span class="keyword">new</span> SyncedLearnerTracker();</span><br><span class="line">        voteSet.addQuorumVerifier(self.getQuorumVerifier());</span><br><span class="line">        <span class="keyword">if</span> (self.getLastSeenQuorumVerifier() != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; self.getLastSeenQuorumVerifier().getVersion() &gt; self</span><br><span class="line">                        .getQuorumVerifier().getVersion()) &#123;</span><br><span class="line">            voteSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把投票项放入set</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Long, Vote&gt; entry : votes.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vote.equals(entry.getValue())) &#123;</span><br><span class="line">                voteSet.addAck(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计set集合，判断某个server的票数是否超过了一半</span></span><br><span class="line">        <span class="keyword">return</span> voteSet.hasAllQuorums();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>选举过程图如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/04/19/SwtzydP5saM9k2Y.png" alt="选举过程图" title="">                </div>                <div class="image-caption">选举过程图</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Zookeeper选举算法分析-以FastLeader为例&quot;&gt;&lt;a href=&quot;#Zookeeper选举算法分析-以FastLeader为例&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper选举算法分析: 以FastLeader为例&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="分布式" scheme="wbc.wiki/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="zookeeper" scheme="wbc.wiki/tags/zookeeper/"/>
    
  </entry>
  
</feed>
