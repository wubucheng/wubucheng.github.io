{"meta":{"title":"吴编程","subtitle":"wubc的个人博客","description":"技术、生活、工作","author":"wubc","url":"wbc.wiki","root":"/"},"pages":[{"title":"无编程 | 404","date":"2020-02-29T07:28:36.278Z","updated":"2020-02-29T07:27:41.983Z","comments":true,"path":"404.html","permalink":"wbc.wiki/404.html","excerpt":"","text":""},{"title":"无编程 | 404","date":"2020-02-29T07:27:41.983Z","updated":"2020-02-29T07:27:41.983Z","comments":true,"path":"404/404.html","permalink":"wbc.wiki/404/404.html","excerpt":"","text":""},{"title":"404","date":"2020-02-29T07:02:11.000Z","updated":"2020-02-29T07:02:11.876Z","comments":true,"path":"404/index.html","permalink":"wbc.wiki/404/index.html","excerpt":"","text":""},{"title":"","date":"2023-06-07T08:42:09.050Z","updated":"2020-02-29T04:38:14.560Z","comments":false,"path":"categories/index.html","permalink":"wbc.wiki/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2023-06-07T08:42:09.047Z","updated":"2020-02-29T09:03:31.695Z","comments":false,"path":"aboutme/index.html","permalink":"wbc.wiki/aboutme/index.html","excerpt":"","text":"编程让生活更加美好@card{ 从事Java后端开发，本博客记录本人工作内外所学的知识，或生活思考，偶尔瞎写。内容同步到本人公众号“后端随笔”欢迎关注一波。同步经常在京东购物的朋友们可以京东优惠券先领券再购物，更加优惠哟。 } @timeline{ 2015@item{ 1月1日Android开发 } 2018@item{ 7月1日java后端开发 } 未来@item{ —可期 } }"},{"title":"","date":"2020-04-06T09:08:48.631Z","updated":"2020-04-06T08:36:41.804Z","comments":true,"path":"data/butterfly.json","permalink":"wbc.wiki/data/butterfly.json","excerpt":"","text":"{\"menu\":{\"Home\":\"/ || fa fa-home\",\"Archives\":\"/archives/ || fa fa-archive\",\"Tags\":\"/tags/ || fa fa-tags\",\"Categories\":\"/categories/ || fa fa-folder-open\",\"Link\":\"/link/ || fa fa-link\",\"About\":\"/about/ || fa fa-heart\",\"List||fa fa-list\":[\"Music || /music/ || fa fa-music\",\"Movie || /movies/ || fa fa-film\"]},\"favicon\":\"/img/favicon.ico\",\"highlight_theme\":\"light\",\"highlight_copy\":true,\"highlight_lang\":true,\"highlight_shrink\":false,\"code_word_wrap\":false,\"copy\":{\"enable\":true,\"copyright\":false},\"social\":{\"fa fa-github\":\"https://github.com/jerryc127\",\"fa fa-envelope\":\"mailto:xxxxxxxx@gmail.com\",\"fa fa-rss\":\"/atom.xml\"},\"algolia_search\":{\"enable\":false,\"hits\":{\"per_page\":6},\"labels\":{\"input_placeholder\":\"Search for Posts\",\"hits_empty\":\"We didn't find any results for the search: ${query}\",\"hits_stats\":\"${hits} results found in ${time} ms\"}},\"local_search\":{\"enable\":false,\"labels\":{\"input_placeholder\":\"Search for Posts\",\"hits_empty\":\"We didn't find any results for the search: ${query}\"}},\"mathjax\":{\"enable\":false,\"per_page\":false},\"katex\":{\"enable\":false,\"per_page\":false,\"hide_scrollbar\":true},\"mermaid\":{\"enable\":false,\"theme\":\"default\"},\"avatar\":{\"img\":\"/img/avatar.png\",\"effect\":false},\"index_img\":null,\"default_top_img\":\"/img/index.jpg\",\"archive_img\":null,\"tag_img\":null,\"category_img\":null,\"cover\":{\"index_enable\":true,\"aside_enable\":true,\"archives_enable\":true,\"position\":\"both\",\"default_cover\":[\"/img/post.jpg\"]},\"lodding_bg\":{\"flink\":\"/img/friend_404.gif\",\"post_page\":\"/img/404.jpg\"},\"error_404\":{\"enable\":false,\"subtitle\":\"Page Not Found\",\"background\":null},\"post_meta\":{\"page\":{\"date_type\":\"created\",\"categories\":true,\"tags\":false},\"post\":{\"date_type\":\"both\",\"categories\":true,\"tags\":true}},\"wordcount\":{\"enable\":false},\"toc\":{\"enable\":true,\"number\":true},\"auto_open_sidebar\":{\"enable\":true},\"post_copyright\":{\"enable\":true,\"decode\":false,\"license\":\"CC BY-NC-SA 4.0\",\"license_url\":\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"},\"auto_excerpt\":{\"enable\":true,\"length\":150},\"addThis\":{\"enable\":false,\"pubid\":null},\"sharejs\":{\"enable\":true,\"sites\":\"facebook,twitter,wechat,weibo,qq\"},\"addtoany\":{\"enable\":false,\"item\":[\"facebook\",\"twitter\",\"wechat\",\"sina_weibo\",\"facebook_messenger\",\"email\",\"copy_link\"]},\"disqus\":{\"enable\":false,\"shortname\":null,\"count\":false},\"disqusjs\":{\"enable\":false,\"shortname\":null,\"siteName\":null,\"apikey\":null,\"api\":\"https://disqus.skk.moe/disqus/\",\"admin\":null,\"adminLabel\":null,\"count\":true},\"laibili\":{\"enable\":false,\"uid\":null},\"gitalk\":{\"enable\":false,\"client_id\":null,\"client_secret\":null,\"repo\":null,\"owner\":null,\"admin\":null,\"language\":\"zh-CN\",\"perPage\":10,\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"createIssueManually\":false,\"count\":true},\"valine\":{\"enable\":false,\"appId\":null,\"appKey\":null,\"notify\":false,\"verify\":false,\"pageSize\":10,\"avatar\":\"monsterid\",\"lang\":\"en\",\"placeholder\":\"Please leave your footprints\",\"guest_info\":\"nick,mail,link\",\"recordIP\":false,\"serverURLs\":null,\"bg\":\"/img/comment_bg.png\",\"count\":true},\"utterances\":{\"enable\":false,\"repo\":null,\"issue_term\":\"pathname\",\"light_theme\":\"github-light\",\"dark_theme\":\"photon-dark\"},\"since\":2020,\"footer_custom_text\":null,\"footer_copyright\":{\"enable\":true},\"ICP\":{\"enable\":false,\"url\":null,\"text\":null,\"icon\":\"/img/icp.png\"},\"baidu_analytics\":null,\"google_analytics\":null,\"tencent_analytics\":null,\"google_adsense\":{\"enable\":false,\"js\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\",\"client\":null,\"enable_page_level_ads\":true},\"google_site_verification\":null,\"bing_site_verification\":null,\"baidu_site_verification\":null,\"qihu_site_verification\":null,\"reward\":{\"enable\":true,\"QR_code\":[{\"itemlist\":{\"img\":\"/img/wechat.jpg\",\"text\":\"微信\"}},{\"itemlist\":{\"img\":\"/img/alipay.jpg\",\"text\":\"支付寶\"}}]},\"related_post\":{\"enable\":true,\"limit\":6,\"date_type\":\"created\"},\"index_site_info_top\":null,\"index_top_img_height\":null,\"category_ui\":null,\"tag_ui\":null,\"background\":null,\"footer_bg\":false,\"canvas_ribbon\":{\"enable\":false,\"size\":150,\"alpha\":0.6,\"zIndex\":-1,\"click_to_change\":false,\"mobile\":false},\"canvas_ribbon_piao\":{\"enable\":false,\"mobile\":false},\"canvas_nest\":{\"enable\":false,\"color\":\"0,0,255\",\"opacity\":0.7,\"zIndex\":-1,\"count\":99,\"mobile\":false},\"activate_power_mode\":{\"enable\":false,\"colorful\":true,\"shake\":true},\"fireworks\":{\"enable\":false},\"click_heart\":{\"enable\":false},\"ClickShowText\":{\"enable\":false,\"text\":[\"本人\",\"超帥\"],\"fontSize\":\"15px\"},\"display_mode\":\"light\",\"beautify\":{\"enable\":false,\"title-prefix-icon\":\"\\\\f0c1\",\"title-prefix-icon-color\":\"#F47466\"},\"font\":{\"enable\":false,\"font-family\":\"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\\\", Helvetica Neue, Helvetica, Arial, sans-serif\",\"code-font\":\"consolas, Menlo, \\\"PingFang SC\\\", \\\"Microsoft YaHei\\\", monospace, Helvetica Neue For Number\"},\"blog_title_font\":{\"font_link\":\"https://fonts.googleapis.com/css?family=Titillium+Web\",\"font-family\":\"Titillium Web, PingFang SC, Hiragino Sans GB, \\\"Microsoft YaHei\\\", Helvetica Neue, Helvetica, Arial, sans-serif\"},\"hr\":{\"enable\":false,\"icon\":\"\\\\f21c\",\"icon-top\":\"-20px\"},\"subtitle\":{\"enable\":true,\"effect\":true,\"loop\":false,\"source\":false,\"sub\":[\"今日事&#44;今日畢\",\"Never put off till tomorrow what you can do today\"]},\"fontawesome_v5\":{\"enable\":false},\"aside\":{\"enable\":true,\"mobile\":true,\"position\":\"right\",\"card_author\":true,\"card_announcement\":true,\"card_recent_post\":true,\"card_categories\":true,\"card_tags\":true,\"card_archives\":true,\"card_webinfo\":true},\"announcement\":{\"content\":\"感謝訪問本站，若喜歡請收藏 ^_^\"},\"busuanzi\":{\"site_uv\":true,\"site_pv\":true,\"page_pv\":true},\"runtimeshow\":{\"enable\":true,\"start_date\":\"6/7/2018 00:00:00\"},\"translate\":{\"enable\":true,\"default\":\"繁\",\"defaultEncoding\":2,\"translateDelay\":0,\"cookieDomain\":\"https://xxx/\",\"msgToTraditionalChinese\":\"繁\",\"msgToSimplifiedChinese\":\"簡\"},\"readmode\":{\"enable\":true},\"darkmode\":{\"enable\":true,\"button\":true,\"autoChangeMode\":1},\"medium_zoom\":{\"enable\":false},\"fancybox\":{\"enable\":true},\"snackbar\":{\"enable\":false,\"position\":\"bottom-left\",\"bg_light\":\"#49b1f5\",\"bg_dark\":\"#2d3035\"},\"baidu_push\":{\"enable\":false},\"instantpage\":{\"enable\":true},\"pangu\":{\"enable\":false,\"field\":\"page\"},\"note\":{\"style\":\"flat\",\"icons\":true,\"border_radius\":3,\"light_bg_offset\":0},\"lazyload\":{\"enable\":true},\"canonical\":true,\"disable_baidu_transformation\":true,\"twitter_meta\":true,\"Open_Graph_meta\":true,\"fragment_cache\":true,\"CDN_USE\":{\"css\":[\"/css/index.css\"],\"js\":[\"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js\",\"/js/utils.js\",\"/js/main.js\"]},\"CDN\":{\"blueimp_md5\":\"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js\",\"gitalk\":\"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js\",\"gitalk_css\":\"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css\",\"valine\":\"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js\",\"disqusjs\":\"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js\",\"disqusjs_css\":\"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css\",\"utterances\":\"https://utteranc.es/client.js\",\"addtoany\":\"https://static.addtoany.com/menu/page.js\",\"sharejs\":\"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js\",\"sharejs_css\":\"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css\",\"local_search\":\"/js/search/local-search.js\",\"algolia_js\":\"/js/search/algolia.js\",\"algolia_search\":\"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js\",\"algolia_search_css\":\"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css\",\"mathjax\":\"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML\",\"katex\":\"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css\",\"katex_copytex\":\"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js\",\"katex_copytex_css\":\"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css\",\"mermaid\":\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\",\"busuanzi\":\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\",\"canvas_ribbon\":\"/js/third-party/canvas-ribbon.js\",\"canvas_ribbon_piao\":\"/js/third-party/piao.js\",\"canvas_nest\":\"/js/third-party/canvas-nest.js\",\"lazyload\":\"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js\",\"instantpage\":\"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js\",\"typed\":\"https://cdn.jsdelivr.net/npm/typed.js\",\"js_cookies\":\"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js\",\"pangu\":\"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js\",\"fancybox_css\":\"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css\",\"fancybox\":\"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js\",\"medium_zoom\":\"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js\",\"snackbar_css\":\"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css\",\"snackbar\":\"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js\",\"anime\":\"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js\",\"activate_power_mode\":\"/js/third-party/activate-power-mode.js\",\"fireworks\":\"/js/third-party/fireworks.js\",\"click_heart\":\"/js/third-party/click_heart.js\",\"ClickShowText\":\"/js/third-party/ClickShowText.js\",\"fontawesome_v4\":\"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css\",\"fontawesome_v5\":\"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css\",\"translate\":\"/js/tw_cn.js\"}}"},{"title":"","date":"2023-06-07T08:42:09.045Z","updated":"2020-02-29T04:37:49.936Z","comments":false,"path":"tags/index.html","permalink":"wbc.wiki/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring源码解析读书笔记之一、容器的基本实现","slug":"Spring源码解析读书笔记之一：容器的基本实现","date":"2023-06-07T13:35:00.000Z","updated":"2023-06-07T13:44:53.859Z","comments":true,"path":"2023/06/07/Spring源码解析读书笔记之一：容器的基本实现/","link":"","permalink":"wbc.wiki/2023/06/07/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"一、容器的基本实现容器的基础XmlBeanFactory配置文件的封装通过ClassPathResource进行封装，该类间接实现了Resource接口，这个接口定义了底层资源的方法，对于不同资源都有着不同的是吸纳，例如ClassPathResource（ClassPath资源）、FileSystemResource（文件资源） 加载Bean资源加载入口： 1234public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException &#123; super(parentBeanFactory); this.reader.loadBeanDefinitions(resource);&#125; 进入到：XmlBeanDefinitionReader#loadBeanDefinitions(EncodedResource) 省略掉无关代码 1234567891011121314151617181920212223242526272829303132333435363738//这里是载入XML形式Bean定义资源文件方法public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; // 记录已加载的资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; ... &#125; try &#123; //将资源文件转为InputStream的IO流 InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; //从InputStream中得到XML的解析源 InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; //这里是具体的读取过程 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; //关闭从Resource中得到的IO流 inputStream.close(); &#125; &#125; catch (IOException ex) &#123; ... &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 这上面主要作用是获取InputSource，在这里调用了XmlBeanDefinitionReader#doLoadBeanDefinitions，是具体的读取过程。 12345678910//从特定XML文件中实际载入Bean定义资源的方法 protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; //将XML文件转换为DOM对象，解析过程由documentLoader实现 Document doc = doLoadDocument(inputSource, resource); //这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则 return registerBeanDefinitions(doc, resource); &#125; &#125; 主要做了三件事情： • 获取XML文件的验证模式 • 加载XML文件，并得到对应的Document • 根据返回的Document注册Bean信息 注册和解析BeanDefinitionsXmlBeanDefinitionReader#registerBeanDefinitions 123456789101112//按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; //得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); //获得容器中注册的Bean数量 int countBefore = getRegistry().getBeanDefinitionCount(); //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口, //具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); //统计解析的Bean数量 return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 这里是使用BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader进行处理，走到这个类的registerBeanDefinitions方法： 12345678910@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; //获得XML描述符 this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); //获得Document的根元素 Element root = doc.getDocumentElement(); // 解析的具体实现 doRegisterBeanDefinitions(root);&#125; 一个很重要的目的是提取root。DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions是真正开始解析了。 1234567891011121314151617181920212223242526protected void doRegisterBeanDefinitions(Element root) &#123; //具体的解析过程由BeanDefinitionParserDelegate实现， //BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; &#125; //在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性 preProcessXml(root); //从Document的根元素开始进行解析Bean定义的Document对象 parseBeanDefinitions(root, this.delegate); //在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性 postProcessXml(root); this.delegate = parent;&#125; 解析并注册BeanDefinition： 1234567891011121314151617181920212223242526272829//使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; //Bean定义的Document对象使用了Spring默认的XML命名空间 if (delegate.isDefaultNamespace(root)) &#123; //获取Bean定义的Document对象根元素的所有子节点 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); //获得Document节点是XML元素节点 if (node instanceof Element) &#123; Element ele = (Element) node; //Bean定义的Document的元素节点使用的是Spring默认的XML命名空间 if (delegate.isDefaultNamespace(ele)) &#123; //使用Spring的Bean规则解析元素节点 parseDefaultElement(ele, delegate); &#125; else &#123; //没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; //Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的 //解析规则解析Document根节点 delegate.parseCustomElement(root); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"wbc.wiki/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"wbc.wiki/tags/Spring/"},{"name":"源码解析","slug":"源码解析","permalink":"wbc.wiki/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"第六章 类文件结构","slug":"深入理解Java虚拟机：第六章-类文件结构","date":"2020-10-17T08:06:38.000Z","updated":"2020-10-17T09:32:00.900Z","comments":true,"path":"2020/10/17/深入理解Java虚拟机：第六章-类文件结构/","link":"","permalink":"wbc.wiki/2020/10/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9A%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","excerpt":"","text":"深入理解Java虚拟机：第六章（一）类文件结构Class文件的结构class文件伪结构中有两种数据类型： 无符号数 表 class文件图 魔数magic占4个字节，作用是确定文件是否能被虚拟机接受 版本号包括次版本号和主版本号 常量池存放两大常量： 字面量 如文本字符串、final常量 符号引用 开放的包、全限定名、方法名称和描述、句柄、类型、动态调用点等 常量池项目类型： 常量池项目类型 P221参照表，后面分析的内容要用到 访问标志 access_flag占两个字节，用于识别一些类或者接口层次的访问信息，例如是否定义为public、abstract、final类型 各个值得含义如下图： 访问标志.jpg 没有使用到的标志位一律为0 类索引、父类索引与接口索引集合类索引：确定类的全限定名 父类索引：确定类的父类的全限定名，只有一个。除了java.lang.Object外，所有Java类的父类索引都不为0 接口索引：集合就用来描述这个类实现了哪些接口 字段表集合 用于描述接口或类中声明的变量 字段表结构如下图 字段表结构.jpg 字段访问标志如下图 字段访问标志.jpg 由于java语法原因，有些标志位不能同时选择。 字段表后面两项是name_index和descriptor_indexx。分别代表字段的简单名称和方法描述符 方法表集合方法表结构 方法表结构.jpg 方法访问标志与属性访问标志类似。只是增加和减少了部分属性。而方法中代码存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目。 在java代码层面上，重载一个方法必须拥有一个与原方法不同的特征签名（特征签名是指一个方法中各个参数在常量池中的字段符号），该特征签名只包括方法名称、参数类型和顺序。 而在字节码层面上，特征签名还包括方法返回值和受检查异常表，因此，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的 属性表集合属性表结构 属性表结构.jpg code属性 方法体里的代码编译后会存储在字节码的code属性内，code属性出现在方法表里的属性集合之中，但接口或抽象类的方法就不存在code属性。 code属性表结构.jpg attribute_name_index：属性名称索引，CONSTRANT_Utf8_info型常量索引 attribute_length：属性值长度。属性名称索引和该值长度共6个字节 max_stack：操作数栈深度最大值，在方法执行时操作数栈不会超过这个深度。虚拟机根据这个值分配栈帧中操作栈的深度。 max_locals：局部变量表所需的存储空间，单位是槽。长度不超过32位的局部变量用一个槽存储，64位的用2个槽。变量槽是可以进行复用的。 code_length：字节码长度。理论值可以达到2的32次幂，但实际上不能超过u2长度，否则编译器拒绝编译。 code：存储字节码指令的一些列字节流 Exceptions属性 作用是列举出方法中可能抛出的受查异常 LineNumberTable属性 用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性 其他属性 LocalV ariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。 LocalV ariableTypeTable。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名，用于准确描述泛型类型。 SourceFile属性用于记录生成这个Class文件的源码文件名称，可选。 SourceDebugExtension属性用于存储额外的代码调试信息，例如定位JSP的信息。 ConstantV alue属性的作用是通知虚拟机自动为静态变量赋值。 InnerClasses属性用于记录内部类与宿主类之间的关联。 Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用。 Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。 StackMapTable： Sign：ature：记录泛型签名信息 BootstrapMethods： MethodParameters：记录方法的各个形参名称和信息，jdk8新增的 模块化相关属性 exports：每一元素都代表一个被模块所导出的包 export_to_count：导出包的限定器，为0则无限定，否则后面跟着的export_to_index是以计数器值为长度的数组，只有在这个数组范围内的模块才允许被访问。 运行期注解相关属性：","categories":[{"name":"java虚拟机","slug":"java虚拟机","permalink":"wbc.wiki/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"wbc.wiki/tags/JVM/"}]},{"title":"Nginx浅入浅出","slug":"Nginx浅入浅出","date":"2020-08-11T11:32:09.000Z","updated":"2020-08-11T11:35:19.108Z","comments":true,"path":"2020/08/11/Nginx浅入浅出/","link":"","permalink":"wbc.wiki/2020/08/11/Nginx%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA/","excerpt":"","text":"概念 Nginx是一个高性能的反向代理服务 基本操作 启动：sudo nginx -s start 停止：sudo nginx -s stop 或./nginx -s stop 重启：sudo nginx -s reload 配置说明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 user www-data; # 配置用户或组 worker_processes auto; # 设置允许生成的进程数 pid &#x2F;run&#x2F;nginx.pid; # 设置pid文件存放路径 include &#x2F;etc&#x2F;nginx&#x2F;modules-enabled&#x2F;*.conf; # 全局块 # events块 events &#123; worker_connections 768; # 设置最大连接数 # multi_accept on; # 设置一个进程能否接收多个网络连接 # accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on # use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|&#x2F;dev&#x2F;poll|eventport &#125; # http块，可以嵌套多个server块 http &#123; ## # Basic Settings ## sendfile on; #允许sendfile方式传输文件 tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; #连接超时时间 types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include &#x2F;etc&#x2F;nginx&#x2F;mime.types; default_type application&#x2F;octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## 日志存放路径，分为用户访问日志和错误日志 access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log; error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log; ## # Gzip Settings ## # 配置压缩信息，可以对静态资源进行压缩 gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript; ## # Virtual Host Configs ## 引用存放在其他路径的配置文件，例如server include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*;&#125; 在http属性下有这样一行include /etc/nginx/sites-enabled/*，表示是引入了外部另一个配置文件，实际上我们也是这样做的，将相关的代理配置单独存放到另一个文件上，现在我们来看看这个文件中的内容是什么？ 1234567891011121314151617181920 # server块 server &#123; # 监听端口与地址 listen 80 default_server; listen [::]:80 default_server; root /var/www/html; server_name _; # 配置请求的路由 location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125; try_files $uri $uri/ =404; &#125;&#125; 在该配置文件中，我们可以设置被代理的服务器，通过location路由匹配则转发到被代理服务器，例如如下： 1234567891011121314151617upstream tomcat &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备&#125;error_page 404 https://www.baidu.com; #错误页server &#123; keepalive_requests 120; #单连接请求上限次数。 listen 4545; #监听端口 server_name 127.0.0.1; #监听地址 location ~*^.+$ &#123; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 #root path; #根目录 #index vv.txt; #设置默认页 proxy_pass tomcat: #请求转向tomcat，即upstream定义的服务器 deny 127.0.0.1; #拒绝的ip allow 172.18.5.54; #允许的ip &#125; &#125; location配置语法 location=/uri 精确匹配 localhost^~/uri前缀匹配 location / 通用匹配 参考配置项 1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址； 2.$remote_user ：用来记录客户端用户名称； 3.$time_local ： 用来记录访问时间与时区； 4.$request ： 用来记录请求的url与http协议； 5.$status ： 用来记录请求状态；成功是200； 6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小； 7.$http_referer ：用来记录从那个页面链接访问过来的； 8.$http_user_agent ：记录客户端浏览器的相关信息； 第三方模块安装方法： ./configure –prefix=/安装目录 –add-module = /第三方模块的目录 负载均衡 负载均衡的大致原理是利用一定的分配策略将网络负载平衡地分摊到网络集群的各个操作单元上，使得单个重负载任务能够分担到多个单元上并行处理，使得大量并发访问或数据流量分担到多个单元上分别处理，从而减少用户的等待响应时间 负载均衡器可以分为软件负载和硬件负载： 软件负载：NGINX、LVS、HAProxy 硬件负载：F5、 NGINX的负载均衡负载均衡算法 轮询 加权轮询 IP hash：可以解决session不共享的问题 配置实例12345678910111213141516171819202122232425262728293031upstream tomcat &#123; server 192.168.11.161:8080 max_fails=2 fail_timeout=60s; # max_fails最大失败次数；fail_timeout超#时时间 server 192.168.11.159:8080; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://tomcat; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_next_upstream error timeout http_500 http_503; proxy_connect_timeout 60s; proxy_send_timeout 60s; proxy_read_timeout 60s; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET,POST,DELETE'; add_header 'Aceess-Control-Allow-Header' 'Content-Type,*'; &#125; location ~ .*\\.(js|css|png|svg|ico|jpg)$ &#123; # 防盗链设置 valid_referers none blocked 192.168.11.160 https://wubc.me; if ($invalid_referer) &#123; return 404; &#125; root static-resource; expires 1d; &#125; &#125; 几个配置的说明： proxy_next_upstream：向一台服务器转发请求出现错误，换一台来处理请求获取直接返回错误状态码 proxy_connect_timeout：连接超时时间 proxy_send_timeout：发送数据超时时间 proxy_read_timeout：读取数据超时时间 动静分离 意思是将服务器的静态文件资源直接存放到NGINX上，当客户端访问时直接返回静态资源，不用再一次转发请求到应用服务器上获取，以提高网站性能为目的 实例，参照前面实例： 12345location ~ .*\\.(js|css|png|svg|ico|jpg)$ &#123; root static-resource; expires 1d; &#125; &#125; 缓存 将静态资源等设置缓存时间，并告诉游览器 实例： 12345location ~ .*\\.(js|css|png|svg|ico|jpg)$ &#123; root static-resource; expires 1d; &#125; &#125; 压缩 压缩传输的文件，以提高网站响应速度，可以使用Gzip来进行压缩 实例： 123456789101112131415http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 60; ## # Gzip Settings ## gzip on; gzip_min_length 5k; gzip_comp_level 3; gzip_types application/javascript image/jpeg image/svg+xml; gzip_buffers 4 32k; gzip_vary on; include /etc/nginx/sites-enabled/*; gzip on：开启压缩 gzip_min_length：开始压缩的最小长度 gzip_comp_level，压缩级别 gzip_types：需要压缩的文件类型 gzip_buffers：申请的内存大小，后面跟两个数字，分别代表倍数和申请空间单元，实例表示的是申请4倍的32k内存空间 gzip_vary：是否传输gzip压缩标识 跨域解决方法，可以通过location下的add_header来配置，例如： 1add_header 'Access-Control-Allow-Origin' '*'; 设置允许的访问IP为所有 处理一个请求的流程 nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址 nginx的master进程里面，先初始化好这个监控的（创建socket–设置addrreuse等选项–绑定到指定的ip地址端口–在listen），然后再fork出多个子进程出来，然后子进程会竞争accept新的连接。 此时，客户端就可以向nginx发起连接了。 客户端向Nginx发起连接 当客户端与nginx进行三次握手，与nginx建立好一个连接后，此时，某一个子进程会accept成功，得到这个建立好的socket，然后创建nginx对连接的封装，即ngx_connection_t结构体。 设置读写事件处理并添加读写事件来与客户端进行数据的交互。 nginx或客户端来主动关掉连接 NGINX多进程模型 NGINX使用的是多进程模型，一个master进行下有多个worker进程，可以接受多个客户端连接，在全局块中可以使用worker_processes来设置worker进程数 高可用方案KeepAlived Keepalived 是一个基于VRRP协议来实现的LVS服务高可用方案，可以利用其来避免单点故障。一个LVS服务会有2台服务器运行Keepalived，一台为主服务器（MASTER），一台为备份服务器（BACKUP），但是对外表现为一个虚拟IP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。Keepalived是VRRP的完美实现。作用是检测web服务器的状态，如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的web服务器从系统中剔除，当web服务器工作正常后Keepalived自动将web服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。 参考：Keepalived 工作原理和配置说明 示例图： keepalived.png Openresty Nginx+Lua实现的高性能可伸缩的web平台 基本使用待补充 库文件使用openresty提供了丰富的模块，例如可以使用redis.lua操作Redis数据库 网关对服务进行安全校验、流量控制、服务越来越多，那么服务本身不应该关心这些，而是将这些交由网关来处理，统一控制。 灰度发布","categories":[{"name":"Nginx","slug":"Nginx","permalink":"wbc.wiki/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"wbc.wiki/tags/Nginx/"},{"name":"容器","slug":"容器","permalink":"wbc.wiki/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"mybatis技术内幕读书笔之整体架构","slug":"mybatis技术内幕读书笔之整体架构","date":"2020-07-09T04:43:24.000Z","updated":"2020-07-09T04:44:04.166Z","comments":true,"path":"2020/07/09/mybatis技术内幕读书笔之整体架构/","link":"","permalink":"wbc.wiki/2020/07/09/mybatis%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E4%B9%8B%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/","excerpt":"","text":"Mybatis技术内幕读书笔记（一）Java应用执行mybatis的流程 1、加载mybatis-config.xml配置文件 2、创建SqlSessionFactory对象 3、通过SqlSessionFactory创建sqlsession对象 4、通过sqlsession执行mapper文件的SQL语句 5、通过sqlsession提交事务 6、最后关闭sqlsession对象 mybatis整体架构 mybatis整体架构图 基础支撑层 反射模块：提供良好的反射封装、简洁的API供上层使用 类型转换：提供别名机制以及JDBC类型和Java类型之间转换的能力 日志模块：集成第三方日志框架 资源价值模块：提供加载类文件以及其他资源文件的功能 解析器模块：解析配置文件、处理动态SQL语句的占位符 数据源模块：提供与第三方数据源集成的接口 事务管理：对事务操作进行了封装 缓存模块：提供一级缓存和二级缓存 binding模块：将用户自定义的mapper接口和映射配置文件关联 核心处理层 配置解析：解析配置文件和mapper文件 SQL解析：解析mapper文件定义的SQL节点，转成数据库可执行的SQL语句 SQL执行：包括几个重要的组件：Executor负责维护缓存和事务管理操作；StatementHandler处理数据库委托请求；ParameterHandler完成SQL语句的实参绑定。 插件：提供插件接口 接口层 SqlSession：暴露应用程序调用的API供上层调用","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"wbc.wiki/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"wbc.wiki/tags/Mybatis/"}]},{"title":"SpringIOC源码分析","slug":"SpringIOC源码分析","date":"2020-07-09T04:41:14.000Z","updated":"2020-07-09T04:41:58.556Z","comments":true,"path":"2020/07/09/SpringIOC源码分析/","link":"","permalink":"wbc.wiki/2020/07/09/SpringIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"Spring IOC源码分析UML图 DefaultListableBeanFactory.png 阅读入口ClassPathXmlApplicationContext 开始阅读从找到这个构造方法： 123456789101112public ClassPathXmlApplicationContext(String[] paths, Class&lt;?&gt; clazz, @Nullable ApplicationContext parent) throws BeansException &#123; super(parent); Assert.notNull(paths, \"Path array must not be null\"); Assert.notNull(clazz, \"Class argument must not be null\"); this.configResources = new Resource[paths.length]; for (int i = 0; i &lt; paths.length; i++) &#123; this.configResources[i] = new ClassPathResource(paths[i], clazz); &#125; refresh();&#125; 重点是refresh这个方法，接下来就是看这个：org.springframework.context.support.AbstractApplicationContext#refresh 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public void refresh() throws BeansException, IllegalStateException &#123; // 加锁 synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识，标志已启动标识 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从 //子类的refreshBeanFactory()方法启动 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //为BeanFactory配置容器特性，例如类加载器、事件处理器等 prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. //为容器的某些子类指定特殊的BeanPost事件处理器 // 如果实现了BeanFactoryPostProcessor这个接口将会调用postProcessBeanFactory方法 postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. //调用所有注册的BeanFactoryPostProcessor的Bean invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. //为BeanFactory注册BeanPost事件处理器. // 注册BeanPostProcessors的实现类，注意这个和BeanFactoryPostProcessor不同 //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. //初始化信息源，和国际化相关. initMessageSource(); // Initialize event multicaster for this context. //初始化容器事件传播器. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. //调用子类的某些特殊Bean初始化方法 onRefresh(); // Check for listener beans and register them. //为事件传播器注册事件监听器. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. //初始化所有剩余的单例Bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. //初始化容器的生命周期事件处理器，广播并发布容器的生命周期事件 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. //销毁已创建的Bean destroyBeans(); // Reset 'active' flag. //取消refresh操作，重置容器的同步标识. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125; &#125; 我们一个个来看，首先看的是org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory这个方法。这个方法是bean创建前的方法，主要目的是准备刷新方法，设置激活标识。 123456789101112131415protected void prepareRefresh() &#123; // 记录开始时间 this.startupDate = System.currentTimeMillis(); // 设置closed和active这两个标识的值 this.closed.set(false); this.active.set(true); ... // Initialize any placeholder property sources in the context environment initPropertySources(); // 校验XML配置文件 getEnvironment().validateRequiredProperties(); this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();&#125; org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory 1234567protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; //这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法 // 关闭旧的BeanFactory，创建新的BeanFactory并返回 refreshBeanFactory(); ConfigurableListableBeanFactory beanFactory = getBeanFactory(); return beanFactory;&#125; 这里使用到了refreshBeanFactory这个方法，所以再来一下这个方法，找到其实现类：org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory 1234567891011121314151617181920212223protected final void refreshBeanFactory() throws BeansException &#123; //如果当前ApplicationContext已经有容器，销毁容器中的bean，关闭容器 if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; //创建IOC容器：DefaultListableBeanFactory DefaultListableBeanFactory beanFactory = createBeanFactory(); // bean的序列化 beanFactory.setSerializationId(getId()); //对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等，设置是否允许bean覆盖、循环引用。 customizeBeanFactory(beanFactory); //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); &#125; &#125; 可以看到这里使用的是DefaultListableBeanFactory这个实例来作为bean容器，这个类基本具有了BeanFactory所有子类的特性（从前面的UML图可以得知）。 深入里面看这个方法org.springframework.context.support.AbstractRefreshableApplicationContext#customizeBeanFactory 12345678protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; if (this.allowBeanDefinitionOverriding != null) &#123; beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.allowCircularReferences != null) &#123; beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125;&#125; 这个方法是：设置bean是否允许覆盖和是否允许循环依赖。 前面refreshBeanFactory方法调用了loadBeanDefinitions，所以我们再来看看这个方法：org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)123456789101112131415161718192021@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; //创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容器使用该读取器读取Bean定义资源 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. //为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的 //祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器 beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); //为Bean读取器设置SAX xml解析器 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. //当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制 initBeanDefinitionReader(beanDefinitionReader); //Bean读取器真正实现加载的方法 loadBeanDefinitions(beanDefinitionReader);&#125; 继续看这个真正实现加载的方法：org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.xml.XmlBeanDefinitionReader)12345678910111213141516protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; //获取Bean定义资源的定位 Resource[] configResources = getConfigResources(); if (configResources != null) &#123; //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位 //的Bean定义资源 reader.loadBeanDefinitions(configResources); &#125; //如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源 String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位 //的Bean定义资源 reader.loadBeanDefinitions(configLocations); &#125;&#125; 这里有两个分支，第一个调用的org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource…)方法，这个方法往下走调用的是loadBeanDefinitions方法，这个方法有多个实现，我们直接看org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource)这个。 继续深挖，走到这里org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)这个方法主要通过EncodedResource将资源文件转为InputStream的IO流。 继续走，里面调用了org.springframework.beans.factory.xml.XmlBeanDefinitionReader#doLoadBeanDefinitions将XML转换为Document对象。 接着，将document转换为容器的数据结构：org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions 1234567891011public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; //得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); //获得容器中注册的Bean数量 int countBefore = getRegistry().getBeanDefinitionCount(); //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口, //具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); //统计解析的Bean数量 return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 这里registerBeanDefinitions的使用的是org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#registerBeanDefinitions这个实现。 12345678public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; //获得XML描述符 this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); //获得Document的根元素 Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root);&#125; 来到org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions方法： 1234567891011121314151617181920212223242526272829protected void doRegisterBeanDefinitions(Element root) &#123; //具体的解析过程由BeanDefinitionParserDelegate实现， //BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isInfoEnabled()) &#123; ... &#125; return; &#125; &#125; &#125; //在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性 preProcessXml(root); //从Document的根元素开始进行解析Bean定义的Document对象 parseBeanDefinitions(root, this.delegate); //在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性 postProcessXml(root); this.delegate = parent; &#125; 上面方法实例化了一个BeanDefinitionParserDelegate对象，这个类包含了标签的所有属性，在上面代码中，主要关注的是parseBeanDefinitions方法： 1234567891011121314151617181920212223242526272829//使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; //Bean定义的Document对象使用了Spring默认的XML命名空间 if (delegate.isDefaultNamespace(root)) &#123; //获取Bean定义的Document对象根元素的所有子节点 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); //获得Document节点是XML元素节点 if (node instanceof Element) &#123; Element ele = (Element) node; //Bean定义的Document的元素节点使用的是Spring默认的XML命名空间 if (delegate.isDefaultNamespace(ele)) &#123; //使用Spring的Bean规则解析元素节点 parseDefaultElement(ele, delegate); &#125; else &#123; //没有使用Spring默认的XML命名空间，则使用用户自定义的解析规则解析元素节点 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; //Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的 //解析规则解析Document根节点 delegate.parseCustomElement(root); &#125; &#125; parseDefaultElement解析的是** **、、、 这几个标签 delegate.parseCustomElement解析的是 、、、标签 来看parseDefaultElement方法里面调用的org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition方法： 123456789101112131415161718192021 //解析Bean定义资源Document对象的普通元素 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类 //对Document对象中&lt;Bean&gt;元素的解析由BeanDefinitionParserDelegate实现 // BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. //向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123;... &#125; // Send registration event. //在完成向Spring IOC容器注册解析得到的Bean定义之后，发送注册事件 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125; &#125; 我们看到这个方法parseBeanDefinitionElement：org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element) 它内部又调用了org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, org.springframework.beans.factory.config.BeanDefinition): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123; //获取&lt;Bean&gt;元素中的id属性值 String id = ele.getAttribute(ID_ATTRIBUTE); //获取&lt;Bean&gt;元素中的name属性值 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); //获取&lt;Bean&gt;元素中的alias属性值 List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); //将&lt;Bean&gt;元素中的所有name属性值存放到别名中 if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; //如果&lt;Bean&gt;元素中没有配置id属性时，并且设置了别名，将别名中的第一个值赋值给beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); ... &#125; //检查&lt;Bean&gt;元素所配置的id或者name的唯一性，containingBean标识&lt;Bean&gt; //元素中是否包含子&lt;Bean&gt;元素 if (containingBean == null) &#123; //检查&lt;Bean&gt;元素所配置的id、name或者别名是否重复 checkNameUniqueness(beanName, aliases, ele); &#125; //详细对&lt;Bean&gt;元素中配置的Bean定义进行解析的地方 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; //如果&lt;Bean&gt;元素中没有配置id、别名或者name，且没有包含子元素&lt;Bean&gt;元素，为解析的Bean生成一个唯一beanName并注册 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; //如果&lt;Bean&gt;元素中没有配置id、别名或者name，且包含了子元素 //&lt;Bean&gt;元素，为解析的Bean使用别名向IOC容器注册 beanName = this.readerContext.generateBeanName(beanDefinition); //为解析的Bean使用别名注册时，为了向后兼容 //Spring1.2/2.0，给别名添加类名后缀 String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123;... &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; //当解析出错时，返回null return null; &#125; 这个方法主要对name，id，别名 进行了解析。同时调用了org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, java.lang.String, org.springframework.beans.factory.config.BeanDefinition)进行其他属性的解析。所以接着来看parseBeanDefinitionElement方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123; //记录解析的&lt;Bean&gt; this.parseState.push(new BeanEntry(beanName)); //这里只读取&lt;Bean&gt;元素中配置的class名字，然后载入到BeanDefinition中去 //只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成 String className = null; //如果&lt;Bean&gt;元素中配置了parent属性，则获取parent属性的值 if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; try &#123; //根据&lt;Bean&gt;元素配置的class名称和parent属性值创建BeanDefinition //为载入Bean定义信息做准备 AbstractBeanDefinition bd = createBeanDefinition(className, parent); //对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); //为&lt;Bean&gt;元素解析的Bean设置description信息 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //对&lt;Bean&gt;元素的meta(元信息)属性解析 parseMetaElements(ele, bd); //对&lt;Bean&gt;元素的lookup-method属性解析 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //对&lt;Bean&gt;元素的replaced-method属性解析 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //解析&lt;Bean&gt;元素的构造方法设置 parseConstructorArgElements(ele, bd); //解析&lt;Bean&gt;元素的&lt;property&gt;设置 parsePropertyElements(ele, bd); //解析&lt;Bean&gt;元素的qualifier属性 parseQualifierElements(ele, bd); //为当前解析的Bean设置所需的资源和依赖对象 bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125;... finally &#123; this.parseState.pop(); &#125; //解析&lt;Bean&gt;元素出错时，返回null return null; &#125; 该类该方法中主要处理除这name,id,别名三个以外的其他属性数据。回到org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition方法，来看调用的org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition方法： 1234567891011121314151617181920//将解析的BeanDefinitionHold注册到容器中public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; // Register bean definition under primary name. //获取解析的BeanDefinition的名称 String beanName = definitionHolder.getBeanName(); //向IOC容器注册BeanDefinition registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // Register aliases for bean name, if any. //如果解析的BeanDefinition有别名，向容器为其注册别名 String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; registry.registerAlias(beanName, alias); &#125; &#125;&#125; 继续走，来到这个方法org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; Assert.hasText(beanName, \"Bean name must not be empty\"); Assert.notNull(beanDefinition, \"BeanDefinition must not be null\"); //校验解析的BeanDefiniton if (beanDefinition instanceof AbstractBeanDefinition) &#123; try &#123; ((AbstractBeanDefinition) beanDefinition).validate(); &#125; catch (BeanDefinitionValidationException ex) &#123; ... &#125; BeanDefinition oldBeanDefinition; oldBeanDefinition = this.beanDefinitionMap.get(beanName); if (oldBeanDefinition != null) &#123; // 处理重复名称bean定义问题 if (!isAllowBeanDefinitionOverriding()) &#123; // 不允许覆盖，将抛出异常 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Cannot register bean definition [\" + beanDefinition + \"] for bean '\" + beanName + \"': There is already [\" + oldBeanDefinition + \"] bound.\"); &#125; else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123; // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE... &#125; else if (!beanDefinition.equals(oldBeanDefinition)) &#123;... &#125; else &#123;... &#125; this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; // map中没有，则将beanName和beanDefinition存放到map中 if (hasBeanCreationStarted()) &#123; // Cannot modify startup-time collection elements anymore (for stable iteration) //注册的过程中需要线程同步，以保证数据的一致性 synchronized (this.beanDefinitionMap) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) &#123; Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; &#125; &#125; &#125; else &#123; // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.manualSingletonNames.remove(beanName); &#125; this.frozenBeanDefinitionNames = null; &#125; //检查是否有同名的BeanDefinition已经在IOC容器中注册 if (oldBeanDefinition != null || containsSingleton(beanName)) &#123; //重置所有已经注册过的BeanDefinition的缓存 resetBeanDefinition(beanName); &#125; &#125; 回到这里org.springframework.context.support.AbstractApplicationContext#refresh，来看里面使用到的org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory方法，代码就不贴了。主要是做了几项工作：设置类的加载器、自动装配时，忽略指定接口，自动进行注册相关bean。 再看refresh方法使用到的org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization方法： 12345678910111213141516171819202122232425262728293031protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; //这是Spring3以后新加的代码，为容器指定一个转换服务(ConversionService) //在对某些Bean属性进行转换时使用 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; if (!beanFactory.hasEmbeddedValueResolver()) &#123; beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal)); &#125; // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early. String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // Stop using the temporary ClassLoader for type matching. //为了类型匹配，停止使用临时的类加载器 beanFactory.setTempClassLoader(null); // Allow for caching all bean definition metadata, not expecting further changes. //缓存容器中所有注册的BeanDefinition元数据，以防被修改 beanFactory.freezeConfiguration(); // Instantiate all remaining (non-lazy-init) singletons. //对配置了lazy-init属性的单态模式Bean进行预实例化处理 beanFactory.preInstantiateSingletons();&#125; 上面方法最后一行调用了org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons方法，该方法对配置lazy-init属性单态Bean的预实例化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public void preInstantiateSingletons() throws BeansException &#123; ... List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames); for (String beanName : beanNames) &#123; //获取指定名称的Bean定义 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); //Bean不是抽象的，是单态模式的，且lazy-init属性配置为false if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; //如果指定名称的bean是创建容器的Bean if (isFactoryBean(beanName)) &#123; //FACTORY_BEAN_PREFIX=”&amp;”，当Bean名称前面加”&amp;”符号 //时，获取的是产生容器对象本身，而不是容器产生的Bean. //调用getBean方法，触发容器对Bean实例化和依赖注入过程 final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); //标识是否需要预实例化 boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; //一个匿名内部类 isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(), getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; //调用getBean方法，触发容器对Bean实例化和依赖注入过程 getBean(beanName); &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125; // Trigger post-initialization callback for all applicable beans... for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125; 接着看org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)这个方法。它实际调用的org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖 //如果指定的是别名，将别名转换为规范的Bean名称 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. //先从缓存中取是否已经有被创建过的单态类型的Bean //对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建 Object sharedInstance = getSingleton(beanName); //IOC容器创建单例模式Bean实例对象 if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; //如果指定名称的Bean在容器中已有单例模式的Bean被创建 //直接返回已经创建的Bean if (isSingletonCurrentlyInCreation(beanName)) &#123; ... &#125; else &#123; ... &#125; &#125; //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理 //注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是 //创建创建对象的工厂Bean，两者之间有区别 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; //缓存没有正在创建的单例模式Bean //缓存中已经有已经创建的原型模式Bean //但是由于循环引用的问题导致实例化对象失败 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; //对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否 //能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器 //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找 BeanFactory parentBeanFactory = getParentBeanFactory(); //当前容器的父级容器存在，且当前容器中不存在指定名称的Bean if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. //解析指定Bean名称的原始名称 String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) &#123; return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); &#125; else if (args != null) &#123; // Delegation to parent with explicit args. //委派父级容器根据指定名称和显式的参数查找 return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. //委派父级容器根据指定名称和类型查找 return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; //创建的Bean是否需要进行类型验证，一般不需要 if (!typeCheckOnly) &#123; //向容器标记指定的Bean已经被创建 markBeanAsCreated(beanName); &#125; try &#123; //根据指定Bean名称获取其父级的Bean定义 //主要解决Bean继承时子类合并父类公共属性问题 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); // 检查合并的属性 checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. //获取当前Bean所有依赖Bean的名称 String[] dependsOn = mbd.getDependsOn(); //如果当前Bean有依赖Bean if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); &#125; //递归调用getBean方法，获取当前Bean的依赖Bean registerDependentBean(dep, beanName); //把被依赖Bean注册给当前依赖的Bean getBean(dep); &#125; &#125; // Create bean instance. //创建单例模式Bean的实例对象 if (mbd.isSingleton()) &#123; //这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象 sharedInstance = getSingleton(beanName, () -&gt; &#123; try &#123; //创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. //显式地从容器单例模式Bean缓存中清除实例对象 destroySingleton(beanName); throw ex; &#125; &#125;); //获取给定Bean的实例对象 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; //IOC容器创建原型模式Bean实例对象 else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. //原型模式(Prototype)是每次都会创建一个新的对象 Object prototypeInstance = null; try &#123; //回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象 beforePrototypeCreation(beanName); //创建指定Bean对象实例 prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; //回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定Bean的原型对象不再创建 afterPrototypeCreation(beanName); &#125; //获取给定Bean的实例对象 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; //要创建的Bean既不是单例模式，也不是原型模式，则根据Bean定义资源中 //配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中 //比较常用，如：request、session、application等生命周期 else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); //Bean定义资源中没有配置生命周期范围，则Bean定义不合法 if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例 Object scopedInstance = scope.get(beanName, () -&gt; &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125;); //获取给定Bean的实例对象 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. //对创建的Bean实例对象进行类型检查 if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType); if (convertedBean == null) &#123; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; return convertedBean; &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123;... &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean; &#125; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[]) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); &#125; RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. //判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // Prepare method overrides. //校验和准备Bean中的方法覆盖 try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123;... &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. //如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123;... &#125; try &#123; //创建Bean的入口 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; &#125; return beanInstance; &#125; ... &#125; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException &#123; //封装被创建的Bean对象 BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; // 说明不是 FactoryBean instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = instanceWrapper.getWrappedInstance(); //获取实例化对象的类型 Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) &#123; mbd.resolvedTargetType = beanType; &#125; // Allow post-processors to modify the merged bean definition. //调用PostProcessor后置处理器 synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. //向容器中缓存单例模式的Bean对象，以防循环引用 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; ... &#125; //这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用 addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); &#125; // Initialize the bean instance. //Bean对象的初始化，依赖注入在此触发 //这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean Object exposedObject = bean; try &#123; //将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象 populateBean(beanName, mbd, instanceWrapper); //初始化Bean对象，完成各种回调 exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); &#125; &#125; if (earlySingletonExposure) &#123; //获取指定名称的已注册的单例模式Bean对象 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; //根据名称获取的已注册的Bean和正在实例化的Bean是同一个 if (exposedObject == bean) &#123; //当前实例化的Bean初始化完成 exposedObject = earlySingletonReference; &#125; //当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length); //获取当前Bean所依赖的其他Bean for (String dependentBean : dependentBeans) &#123; //对依赖Bean进行类型检查 if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123;... &#125; &#125; &#125; &#125; // Register bean as disposable. //注册完成依赖注入的Bean try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); &#125; return exposedObject; &#125; 接下来对上面使用到几个方法作分析： org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123; //检查确认Bean是可实例化的 Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); //使用工厂方法对Bean进行实例化 // 检查类的访问权限 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); &#125; Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) &#123; return obtainFromSupplier(instanceSupplier, beanName); &#125; if (mbd.getFactoryMethodName() != null) &#123; //调用工厂方法实例化 return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; //使用容器的自动装配方法进行实例化 boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; //配置了自动装配属性，使用容器的自动装配实例化 //容器的自动装配是根据参数类型匹配Bean的构造方法 return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; //使用默认的无参构造方法实例化 return instantiateBean(beanName, mbd); &#125; &#125; //使用Bean的构造方法进行实例化 // 判断是否采用有参构造方法 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; //使用容器的自动装配特性，调用匹配的构造方法实例化 return autowireConstructor(beanName, mbd, ctors, args); &#125; //使用默认的无参构造方法实例化 return instantiateBean(beanName, mbd); &#125; createBeanInstance创建bean实例：首先判断能否实例化以及检查其访问权限。其次根据不同条件来对bean进行实例化，有工厂方法的则使用工厂实例化，后根据是否配置了自动装配属性来进行自动装配实例化，否则使用无参构造方法实例化。 以无参构造instantiateBean(beanName, mbd)为例，我们可以挖到这里org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(org.springframework.beans.factory.support.RootBeanDefinition, java.lang.String, org.springframework.beans.factory.BeanFactory) 1234567891011121314151617181920212223242526272829303132333435363738public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) &#123; //如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法 if (!bd.hasMethodOverrides()) &#123; Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) &#123; //获取对象的构造方法或工厂方法 constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; //如果没有构造方法且没有工厂方法 if (constructorToUse == null) &#123; //使用JDK的反射机制，判断要实例化的Bean是否是接口 final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, \"Specified class is an interface\"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; //这里是一个匿名内置类，使用反射机制获取Bean的构造方法 constructorToUse = AccessController.doPrivileged( (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) () -&gt; clazz.getDeclaredConstructor()); &#125; else &#123; constructorToUse = clazz.getDeclaredConstructor(); &#125; bd.resolvedConstructorOrFactoryMethod = constructorToUse; &#125; catch (Throwable ex) &#123; throw new BeanInstantiationException(clazz, \"No default constructor found\", ex); &#125; &#125; &#125; //使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化 return BeanUtils.instantiateClass(constructorToUse); &#125; else &#123; // Must generate CGLIB subclass. //使用CGLIB来实例化对象 return instantiateWithMethodInjection(bd, beanName, owner); &#125; &#125; 注意：这里实例化了对象，但是还没有对属性进行赋值的。 接下来看org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean方法中使用到的org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//将Bean属性设置到生成的实例对象上protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123; if (bw == null) &#123; if (mbd.hasPropertyValues()) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\"); &#125; else &#123; // Skip property population phase for null instance. return; &#125; &#125; boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; // 获取所有后置处理器 for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; // 表示不需要后续对属性进行设置，不需要经过BeanPostProcessor处理 continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (!continueWithPropertyPopulation) &#123; return; &#125; //获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值 PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); //对依赖注入处理，首先处理autowiring自动装配的依赖注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); //根据Bean名称进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; //根据Bean类型进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; //对非autowiring的属性进行依赖注入处理 boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) &#123; if (pvs == null) &#123; pvs = mbd.getPropertyValues(); &#125; PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; checkDependencies(beanName, mbd, filteredPds, pvs); &#125; &#125; if (pvs != null) &#123; //对属性进行注入 applyPropertyValues(beanName, mbd, bw, pvs); &#125;&#125; 该方法的作用就是将Bean属性设置到生成的实例对象上 最后看到org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)这个方法 12345678910111213141516171819202122232425262728293031323334353637383940//初始容器创建的Bean实例对象，为其添加BeanPostProcessor后置处理器 protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123; //JDK的安全机制验证权限 if (System.getSecurityManager() != null) &#123; //实现PrivilegedAction接口的匿名内部类 AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; invokeAwareMethods(beanName, bean); return null; &#125;, getAccessControlContext()); &#125; else &#123; //为Bean实例对象包装相关属性，如名称，类加载器，所属容器等信息 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; //对BeanPostProcessor后置处理器的postProcessBeforeInitialization //回调方法的调用，为Bean实例初始化前做一些处理 if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; //调用Bean实例对象初始化的方法，这个初始化方法是在Spring Bean定义配置 //文件中通过init-method属性指定的 try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); &#125; //对BeanPostProcessor处理器的postProcessAfterInitialization //回调方法的调用，为Bean实例初始化之后做一些处理 if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; 几个重要的类：BeanDefinitionHolder、BeanDefinition、BeanDefinitionParserDelegate、AbstractBeanDefinition、FactoryBean、BeanFactory","categories":[{"name":"Spring","slug":"Spring","permalink":"wbc.wiki/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"wbc.wiki/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"wbc.wiki/tags/IOC/"}]},{"title":"并发队列原理之ConcurrentLinkedQueue原理解析","slug":"并发队列原理之ConcurrentLinkedQueue原理解析","date":"2020-07-09T04:39:15.000Z","updated":"2020-07-09T04:39:36.307Z","comments":true,"path":"2020/07/09/并发队列原理之ConcurrentLinkedQueue原理解析/","link":"","permalink":"wbc.wiki/2020/07/09/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E4%B9%8BConcurrentLinkedQueue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"并发队列原理之ConcurrentLinkedQueue原理解析概述 ConcurrentLinkedQueue是无界非阻塞队列，底层有单向链表实现，通过CAS来保证线程的安全 使用Node内部类作为链表的节点，Node的item域存放节点的值，next表示下一个节点，类图如下： 原理分析offer方法：在队列尾部添加一个元素，返回为true，不能添加null元素1234567891011121314151617181920212223242526public boolean offer(E e) &#123; // 检查元素是否为空 checkNotNull(e); // 插入尾部的元素 final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); // 从尾节点开始循环 for (Node&lt;E&gt; t = tail, p = t;;) &#123; Node&lt;E&gt; q = p.next; if (q == null) &#123; // p is last node // 通过CAS将队列原最后一个元素的next指向新节点 if (p.casNext(null, newNode)) &#123; if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; &#125; // Lost CAS race to another thread; re-read next &#125; else if (p == q) // 由于自引用问题需要重新找新的head p = (t != (t = tail)) ? t : head; else // 寻找尾节点 p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; add方法：实际调用的内部offer方法123public boolean add(E e) &#123; return offer(e);&#125; poll方法：移除队列头部一个元素，并返回该值，队列为空则返回null12345678910111213141516171819202122232425262728public E poll() &#123; restartFromHead: for (;;) &#123; for (Node&lt;E&gt; h = head, p = h, q;;) &#123; E item = p.item; // 当前节点有值则设置为null if (item != null &amp;&amp; p.casItem(item, null)) &#123; // Successful CAS is the linearization point // for item to be removed from this queue. if (p != h) // hop two nodes at a time // 从链表中移除 updateHead(h, ((q = p.next) != null) ? q : p); return item; &#125; // 当前队列为空则返回null else if ((q = p.next) == null) &#123; updateHead(h, p); return null; &#125; // 当前节点被自引用了，重新寻找队列头节点 else if (p == q) // 发现头结点被修改，通过goto预缴跳出外层循环重新获取头结点 continue restartFromHead; else p = q; &#125; &#125;&#125; peek方法：获取头节点元素但是不移除具体逻辑跟poll差不多，区别在于不需要移除元素 remove方法：移除指定元素，存在多个则移除第一个12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o != null) &#123; Node&lt;E&gt; next, pred = null; for (Node&lt;E&gt; p = first(); p != null; pred = p, p = next) &#123; boolean removed = false; E item = p.item; // 使用CAS设置为null if (item != null) &#123; if (!o.equals(item)) &#123; next = succ(p); continue; &#125; removed = p.casItem(item, null); &#125; // 获取next节点 next = succ(p); // 前驱节点和next节点都不为空，则链接前驱节点到next节点 if (pred != null &amp;&amp; next != null) // unlink pred.casNext(p, next); if (removed) return true; &#125; &#125; return false;&#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"ReentrantReadWriteLock原理分析","slug":"ReentrantReadWriteLock原理分析","date":"2020-07-09T04:38:24.000Z","updated":"2020-07-09T04:38:47.667Z","comments":true,"path":"2020/07/09/ReentrantReadWriteLock原理分析/","link":"","permalink":"wbc.wiki/2020/07/09/ReentrantReadWriteLock%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"ReentrantReadWriteLock原理分析概念 ReentrantReadWriteLock采用读写分离的策略，允许多个线程同时获取读锁，写锁是独占式锁，读写锁之间为互斥。 ReentrantReadWriteLock.png 其内部有内部类：WriteLock和ReadLock，分别表示写锁和读锁的操作。ReentrantReadWriteLock中将状态值state分为了两部分，第一部分高16位表示的是读状态（获取到读锁的次数），低16位表示是写状态（获取到写锁的次数）。 其内部类Sync的成员变量如下： 1234567891011121314151617// 共享锁偏移量static final int SHARED_SHIFT = 16;// 共享锁（读锁）状态单位值65536static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;// 排它锁（写锁）掩码，二进制，15个1static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;// 返回读锁线程数static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;// 返回写锁可重入个数static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;// 第一个获取到锁的线程private transient Thread firstReader = null;// 第一个获取到读锁的线程获取读锁的可重入次数private transient int firstReaderHoldCount;// 最后一个获取读锁的线程获取读锁的可重入次数private transient HoldCounter cachedHoldCounter; 写锁的获取和释放lockReentrantReadWriteLock的写锁是独占锁也是可重入锁，如果写锁和读锁没有被获取，那么当前线程可以获取到写锁，否则线程被挂起。 123public void lock() &#123; sync.acquire(1);&#125; ReentrantReadWriteLock的lock方法同样是java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire实现的。里面使用到tryAcquire方法是Sync重写的 123456public final void acquire(int arg) &#123; // 该tryAcquire方法同样是掉用其的Sync内部类实现 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 12345678910111213141516171819202122232425protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState(); // 获取可重入次数 int w = exclusiveCount(c); if (c != 0) &#123; // 不为0则写锁或读锁已经被其他线程获取了 // (Note: if c != 0 and w == 0 then shared count != 0) // c!=0且w为0说明低16位为0，高16位不为0，这就代表了读锁已经被获取了，w不为0，代表写锁被获取了 if (w == 0 || current != getExclusiveOwnerThread()) // 读锁别获取了或者当前线程不是写锁持有者，则返回false return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); // Reentrant acquire // 设置可重入次数 setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true;&#125; lockInterruptibly对中断进行响应的获取锁的方法 tryLock尝试获取写，成功返回true 123public boolean tryLock( ) &#123; return sync.tryWriteLock();&#125; 12345678910111213141516final boolean tryWriteLock() &#123; Thread current = Thread.currentThread(); int c = getState(); if (c != 0) &#123; int w = exclusiveCount(c); // c!=0且w为0说明低16位为0，高16位不为0，这就代表了读锁已经被获取了，w不为0，代表写锁被获取了 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w == MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); &#125; if (!compareAndSetState(c, c + 1)) return false; setExclusiveOwnerThread(current); return true;&#125; tryLock(long timeout, TimeUnit unit)增加超时等待获取锁，能够对中断进行响应 unlock尝试释放锁，对状态值减一，减一后结果为0则会释放锁 123public void unlock() &#123; sync.release(1);&#125; 1234567891011public final boolean release(int arg) &#123; // 调用子类的tryRelease方法 if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) // 唤醒后继节点 unparkSuccessor(h); return true; &#125; return false;&#125; 1234567891011121314protected final boolean tryRelease(int releases) &#123; // 判断释放锁的是否是锁的持有线程 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // 状态值减一 int nextc = getState() - releases; boolean free = exclusiveCount(nextc) == 0; if (free) // 如果未0则成功释放锁 setExclusiveOwnerThread(null); // 否则只是进行简单的减一 setState(nextc); return free;&#125; 读锁的获取和释放lock如果写锁没有被获取，则读锁可以被获取，获取后状态值的高16位的值加一。 123public void lock() &#123; sync.acquireShared(1);&#125; 123456public final void acquireShared(int arg) &#123; // 调用的是具体子类的方法 if (tryAcquireShared(arg) &lt; 0) // 调用的是AQS的方法 doAcquireShared(arg);&#125; 12345678910111213141516171819202122232425262728293031323334protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); int c = getState(); // 判断写锁是否被占用,如果获取到写锁的不是当前线程则返回-1 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 获取读锁持有的线程数 int r = sharedCount(c); // 尝试获取锁 if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; // r等于0表示读锁是第一次被获取，则设置当前线程为第一个获取到锁的线程 firstReader = current; // 设置读锁的可重入次数为1 firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; // 如果当前线程是第一个获取到读锁的线程，则重入次数加一 firstReaderHoldCount++; &#125; else &#123; // 记录其他线程获取读锁的可重入数或记录最后一个获取读锁的线程 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 如果当前线程已经获取到写锁，而后先要获取读锁是允许的。readerShouldBlock用来判断队列中的第一个元素是否正尝试或获取写锁，不是则判断获取读锁的可重入次数是否达到了最大值。 tryLock尝试获取锁 tryReleaseShared释放锁，跟写锁的过程查不到，多了对firstReader、firstReaderHoldCount和cachedHoldCounter的额外处理，并通过自旋释放锁。","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"ReentrantLock解析","slug":"ReentrantLock解析","date":"2020-07-09T04:37:28.000Z","updated":"2020-07-09T04:38:05.884Z","comments":true,"path":"2020/07/09/ReentrantLock解析/","link":"","permalink":"wbc.wiki/2020/07/09/ReentrantLock%E8%A7%A3%E6%9E%90/","excerpt":"","text":"ReentrantLock概念 ReentrantLock是一个可重入的独占锁 ReentrantLock.png 内部类Sync有两个子类NonfairSync和FairSync，分别表示获取锁的非公平策略和公平策略 获取锁lock方法获取到锁将AQS的state值修改为1，如果该线程之前已经获取锁了，state会进行加一，获取锁失败会将该线程存放到AQS阻塞队列。 ReentrantLock的lock方法实际上调用器内部类Sync的lock方法，而在Sync内部根据实现策略的不同，公平锁则使用的是FairSync的lock方法，非公平锁则调用的是NonfairSync的lock方法。 123public void lock() &#123; sync.lock();&#125; 12345678final void lock() &#123; // 通过CAS设置状态值 if (compareAndSetState(0, 1)) // 设置成功则设置持有锁线程为当前线程 setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 如果获取锁失败则会调用acquire方法： 1234567public final void acquire(int arg) &#123; // tryAcquire失败则把当前线程放入到AQS阻塞队列 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; 在非公平锁中，tryAcquire方法实现如下: 123protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125; 1234567891011121314151617181920final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 设置状态值 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125;// 如果当前线程是该锁持有者 else if (current == getExclusiveOwnerThread()) &#123; // 则直接将状态值加一 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125; 在公平锁中，tryAcquire方法实现如下： 123456789101112131415161718192021 protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 如果当前状态值为0，并且前面没有等待的队列，则设置持有锁的线程为当前线程 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false; &#125;&#125; 与非公平锁相比，多了一步hasQueuedPredecessors的判断： 12345678public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; // 头结点与为节点不相等，并且第一个元素不是当前元素 return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; lockInterruptibly方法与lock比较，增加了对中断响应的功能。 123public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1);&#125; 12345678910public final void acquireInterruptibly(int arg) throws InterruptedException &#123; // 如果线程被中断，则直接抛出异常 if (Thread.interrupted()) throw new InterruptedException(); // 尝试获取资源 if (!tryAcquire(arg)) // 调用AQS的可被中断的方法 doAcquireInterruptibly(arg);&#125; 123456789101112131415161718192021222324252627private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; // 在AQS阻塞队列中添加一个节点 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; // 自璇 for (;;) &#123; // 获取前驱节点 final Node p = node.predecessor(); // 如果前驱节点是头结点并且获取锁成功，则将新添加的节点作为头节点，原来的头节点移除掉 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; // 如果失败后需要挂起 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; tryLock方法尝试获取锁，获取成功返回true，否则false，不会进行阻塞。 123public boolean tryLock() &#123; return sync.nonfairTryAcquire(1);&#125; 它调用的前面提交的非公平锁的nonfairTryAcquire方法。 tryLock(long timeout, TimeUnit unit)方法与tryLock方法比较，增加超时返回机制，在指定时间内没有获取到锁将不会阻塞下去，会返回执行下一步操作。 释放锁unlock方法如果该线程持有锁，则将状态值减一，减后的状态值为0则释放锁。 123public void unlock() &#123; sync.release(1);&#125; 他调用java.util.concurrent.locks.AbstractQueuedSynchronizer#release的方法，而该方法里面调用了ReetrantLock的tryAcquire方法： 123456789101112131415protected final boolean tryRelease(int releases) &#123; // 状态值减一 int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); // 释放锁的标记 boolean free = false; if (c == 0) &#123; free = true; // 清空持有锁的线程信息 setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"CopyOnWriteArrayList浅析","slug":"CopyOnWriteArrayList浅析","date":"2020-07-09T04:36:26.000Z","updated":"2020-07-09T04:36:56.744Z","comments":true,"path":"2020/07/09/CopyOnWriteArrayList浅析/","link":"","permalink":"wbc.wiki/2020/07/09/CopyOnWriteArrayList%E6%B5%85%E6%9E%90/","excerpt":"","text":"CopyOnWriteArrayList常用方法分析add 添加元素1234567891011121314151617public boolean add(E e) &#123; // 获取独占锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获取原来的数组 Object[] elements = getArray(); int len = elements.length; // 复制元素到新数组，新数组长度是原来数组长度的+1 Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 获取指定位置的元素123public E get(int index) &#123; return get(getArray(), index);&#125; 123final Object[] getArray() &#123; return array;&#125; 123private E get(Object[] a, int index) &#123; return (E) a[index]; &#125; get方法没有加锁，如果一个线程在获取元素的同时有一个线程删除了某些元素，那么会产生弱一致性问题，弱一致性是指返回迭代器后，其他线程对list的增删改查是不可见的 指定位置修改值1234567891011121314151617181920212223public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获取原来的数组 Object[] elements = getArray(); // 获取指定位置的旧值 E oldValue = get(elements, index); // 如果旧值与要指定修改的值不一致则复制新数组，在新数组中修改该位置的值 if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 删除元素123456789101112131415161718192021222324public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) // 如果要删除的元素是最后一个元素则直接复制一个新数组，新数组长度比原来的数组长度小一 setArray(Arrays.copyOf(elements, len - 1)); else &#123; // 否则的话需要进行两次复制数组 Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 总结CopyOnWriteArrayList的增删改的操作都加入锁，且进行了复制数组的操作。","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"并发包中锁原理剖析","slug":"并发包中锁原理剖析","date":"2020-07-09T04:35:37.000Z","updated":"2020-07-09T04:35:57.638Z","comments":true,"path":"2020/07/09/并发包中锁原理剖析/","link":"","permalink":"wbc.wiki/2020/07/09/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E9%94%81%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/","excerpt":"","text":"并发包中锁原理剖析LockSupport 主要作用是挂起和唤醒线程 主要方法 park：挂起线程 unpark：如果因park挂起的，调用unpark后，线程被唤醒 parkNanos：如果没有拿到许可证，超时后会自动返回 parkUntil：与parkNanos区别是parkUntil的时间是从1970年开始算的 AQS 抽象队列同步器，是一个双向队列，通过Node类型的head和tail记录队首和队尾元素。Node的thread变量记录进行AQS的线程 Node元素： SHARED：标记该线程是获取共享资源时被阻塞挂起后放入AQS队列的 EXCLUSIVE：标记获取独占资源时阻塞被挂起后放入AQS队列的 waitStatus：线程等待状态： CANCELLED SIGNAL CONDITION PROPAGATE head：记录队首 tail：记录队尾元素 thread：记录进入AQS的线程 ConditionObject 用来结合锁实现线程同步，可以直接访问AQS内部变量。ConditionObject作为条件变量，每个条件变量对应一个条件队列。 AQS操作state的方式 独占方式：一个线程获取到了锁，其他线程获取失败进入阻塞。获取到锁的线程,，AQS会利用CAS将state状态值有0设置为1，如果锁是可重入的，已经获取到锁的线程再次获取时会将state值递增加一。 共享方式：类似于信号量的获取，如果一个信号被线程获取了，其他线程尝试获取时如果信号量满足条件则可以获取到锁。 AQS的条件变量的支持 条件变量为signal和await，AQS一个锁可以对应多个条件变量，每个条件变量内部维护一个条件队列，存放调用条件变量await方法是被阻塞的线程。 条件变量作用示例：线程A获取到锁后调用了锁创建的条件变量1，那么线程A会释放锁，当前线程被转换为Node节点插入条件变量1的条件队列。 await方法：调用该方法前需要获取到锁，调用方法后会将该线程放到条件变量的阻塞队列（不是AQS队列）。然后释放锁。 signal方法：将条件队列中队头的线程节点移除，并放入AQS阻塞队列，激活这个线程","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"J.U.C之CountDownLatch源码分析","slug":"J-U-C之CountDownLatch源码分析","date":"2020-07-09T04:34:38.000Z","updated":"2020-07-09T04:35:01.527Z","comments":true,"path":"2020/07/09/J-U-C之CountDownLatch源码分析/","link":"","permalink":"wbc.wiki/2020/07/09/J-U-C%E4%B9%8BCountDownLatch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"概念与作用 CountDownLatch是JUC包下提供的一个工具类，它的作用是让一个或者一组线程等待其他线程执行完成后，自己再接着执行，count数不为0则线程进行等待。 API await：执行等待，计数不为0则进入等待 await(long timeout, TimeUnit unit)：超时则自动唤醒，继续往下走 coutDown：计数减一 getCount：获取当前计数的值 源码分析内部实现 底层使用一个Sync内部类实现，改类继承了AbstractQueuedSynchronizer Sync构造方法 12345678/** * 在构造方法中设置同步变量state的值 * * @param count */ Sync(int count) &#123; setState(count); &#125; 获取共享锁 12345678910/** * 尝试在获取共享锁 * * @param acquires * @return */ protected int tryAcquireShared(int acquires) &#123; // state为0返回1，否则返回-1 return (getState() == 0) ? 1 : -1; &#125; 释放共享锁 1234567891011121314151617181920 /** * 尝试释放锁 * 该方法的调用实际是CountDownLatch调用countDonwn后使用AQS中的releaseShared * @param releases * @return */ protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (; ; ) &#123; int c = getState(); if (c == 0) // state已为0则返回失败 return false; int nextc = c - 1; // 通过CAS设置状态 if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125; 核心方法：await方法1234public void await() throws InterruptedException &#123; // 使用的是AQS的acquireSharedInterruptibly方法 sync.acquireSharedInterruptibly(1); &#125; 该方法内部调用了AQS的acquireSharedInterruptibly方法： 1234567public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; acquireSharedInterruptibly方法分两步进行分析 tryAcquireShared：实际调用的是java.util.concurrent.CountDownLatch.Sync#tryAcquireShared，该方法上面有提及到 1234protected int tryAcquireShared(int acquires) &#123; // state为0返回1，否则返回-1 return (getState() == 0) ? 1 : -1; &#125; doAcquireSharedInterruptibly 12345678910111213141516171819202122232425262728293031 private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123;// 新建并将共享节点加入到等待队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 或取前驱节点 final Node p = node.predecessor(); if (p == head) &#123; // 当前节点是队列中等待的第一个节点则尝试获取锁 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // r&gt;=0了获取到锁，设置当前节点为头结点 setHeadAndPropagate(node, r); // 在队列中删除原头结点 p.next = null; // help GC failed = false; return; &#125; &#125; // 判断获取失败后是否需要等待并进行中断检查 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 接着来看一下setHeadAndPropagate方法： 123456789101112private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below// 设置头结点 setHead(node); if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) // 释放锁 doReleaseShared(); &#125; &#125; propagate &gt; 0 说明state已经为0了；如果propagate &gt; 0或者头结点为空，或头结点的等待状态小于0，则获取该节点的后继节点，并判断如果没有后继节点或者后继节点为共享模式，则调用doReleaseShared方法，doReleaseShared方法如下： 12345678910111213141516171819202122private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; // 获取头节点的等待状态 int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; // 如果状态为SIGNAL则进行CAS更新 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases // 释放后继节点 unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // 如果等待状态为0，且节点状态为PROPAGATE，则继续循环 continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125; 这里顺便提一下Node的状态： CANCELLED = 1: 被取消，当线程等待超时或被中断 SIGNAL = -1：通知，当前线程释放了，通知后继节点 CONDITION = -2：节点处于等待队列中，调用signal方法后，节点转移到同步队列中，加入到同步状态的获取中 PROPAGATE = -3; 下一次共享状态将会被无条件传播下去 核心方法：countDown方法123public void countDown() &#123; sync.releaseShared(1); &#125; 该方法调用的AQS的releaseShared方法： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 同样，这里使用到tryReleaseShared方法和doReleaseShared方法，下面做分析： tryReleaseShared 尝试获取共享锁1234567891011121314protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (; ; ) &#123; int c = getState(); if (c == 0) // state已为0则返回失败 return false; int nextc = c - 1; // 通过CAS设置状态 if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125; doReleaseShared：执行释放锁1234567891011121314151617181920private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; // 如果头结点的状态为SIGNAL，进行CAS更新 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases // 释放后继节点 unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125; 前面都有提到的unparkSuccessor方法如下： 1234567891011121314151617181920private void unparkSuccessor(Node node) &#123; // 获取节点状态 int ws = node.waitStatus; if (ws &lt; 0) // 节点状态小于0，则该节点的状态可能为：SIGNAL、CONDITION、PROPAGATE compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; // 下一个节点的等待状态为CANCELLED或为空，则先置空 s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) // 后循环释放节点的状态为：SIGNAL、CONDITION、PROPAGATE的后继节点 s = t; &#125; if (s != null) LockSupport.unpark(s.thread); &#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"阻塞队列 ","slug":"阻塞队列","date":"2020-07-09T04:32:44.000Z","updated":"2020-07-09T04:33:11.498Z","comments":true,"path":"2020/07/09/阻塞队列/","link":"","permalink":"wbc.wiki/2020/07/09/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","excerpt":"","text":"阻塞队列ArrayBlockingQueue通过全局锁的方式，同时只能有一个线程进行存放元素到队列或一个线程从队列中获取元素 offer方法 123456789101112131415public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; 123456789101112该方法首先获取锁，通过其构造方法可以知道，这个锁是非公平锁：​&#96;&#96;&#96;java public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;&#x3D; 0) throw new IllegalArgumentException(); this.items &#x3D; new Object[capacity]; lock &#x3D; new ReentrantLock(fair); notEmpty &#x3D; lock.newCondition(); notFull &#x3D; lock.newCondition(); &#125; note: 非公平锁：直接尝试占有锁；公平锁，先判断当前线程是否是第一个线程，是则获取锁，否则添加到等待队列上。 然后调用enqueue方法将元素添加到队列上; 12345678910private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 添加完后，通过 notEmpty.signal() 知非空对队列。 notEmpty和notFull是Condition类型的示例. PriorityBlockingQueue 无界优先级队列内部使用到比较器，用来比较元素大小，由于这是无界队列所以这里没有notFul。默认按元素升序。元素需要实现Comparable接口。 1DEFAULT_INITIAL_CAPACITY = 11 //队列默认大小 为什么是11？ offer 方法 1234567891011121314151617181920212223public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; // 元素个数大于了队列容量，则使用tryGrow进行扩容 while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true; &#125; 这里可以看到扩容时调用了tryGrow方法： 12345678910111213141516171819202122232425262728293031private void tryGrow(Object[] array, int oldCap) &#123; lock.unlock(); // must release and then re-acquire main lock Object[] newArray = null; if (allocationSpinLock == 0 &amp;&amp; UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) &#123; try &#123; // 如果oldCap大于等于64，那么队列新的容量则扩容50% int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : // grow faster if small (oldCap &gt;&gt; 1)); if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123; // possible overflow int minCap = oldCap + 1; if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; &#125; if (newCap &gt; oldCap &amp;&amp; queue == array) newArray = new Object[newCap]; &#125; finally &#123; allocationSpinLock = 0; &#125; &#125; if (newArray == null) // back off if another thread is allocating Thread.yield(); lock.lock(); if (newArray != null &amp;&amp; queue == array) &#123; queue = newArray; System.arraycopy(array, 0, newArray, 0, oldCap); &#125;&#125; note： 为什么是64作为阈值？ 为什么要提前释放锁 扩容的时候可以进行入队列操作，所以是用到CAS，只允许一个线程进行扩容，如果扩容失败了，则通过Thread.yield()让出CPU，让改线程重新获取锁。 12if (newArray &#x3D;&#x3D; null) &#x2F;&#x2F; back off if another thread is allocating Thread.yield(); 复制数组是在获取锁后面才执行的，是为了保证复制的数组是最新的。 排序方法： 123456789101112131415private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; while (k &gt; 0) &#123; // 确定父节点元素位置 int parent = (k - 1) &gt;&gt;&gt; 1; //获取父节点的值 Object e = array[parent]; // 如果插入的值比父节点大，那么完成堆的建立 if (key.compareTo((T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = key;&#125; 例子：假设有三个节点0、1、2，值也是0、1、2。1、2分别是0节点的左右子节点，那么如果插入的k=3,这时先找出他要插入位置的父节点，通过(k-1)&gt;&gt;&gt;1可以得出，parent=1,也就是1节点，这个时候将这个插入的值跟其父节点的值进行比较，如果发现是大于父节点的值，那么完成堆的构建，跳出循环。否则与父节点进行交换， poll方法 该方法通过dequeue方法进行出队列，获取元素。 1234567891011121314151617181920private E dequeue() &#123; int n = size - 1; if (n &lt; 0) return null; else &#123; Object[] array = queue; E result = (E) array[0]; // 获取队列尾部元素，然后将原来的位置的指向设置为空 E x = (E) array[n]; array[n] = null; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) // 把元素插入到下标为0的位置上，然后调整成最小堆 siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n; return result; &#125;&#125; note：最小堆构建过程 take操作 123456789101112public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); E result; try &#123; while ( (result = dequeue()) == null) notEmpty.await(); &#125; finally &#123; lock.unlock(); &#125; return result;&#125; 队列没有元素则一直阻塞 SychronousQueue 同步队列内部没有容器，只能存放一个元素，只要元素被消费了，才能继续take存放，否则一直阻塞。SychronousQueue 使用的CAS来实现线程的安全访问。 公平模式下的实现：队尾匹配，队头出队。底层实现：使用TransferQueue内部队列。 非公平模式下的实现：后入栈、先匹配。 底层使用TransferStack栈。","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"J.U.C之CycliBarrier使用","slug":"J-U-C之CycliBarrier使用","date":"2020-07-09T04:30:56.000Z","updated":"2020-07-09T04:31:25.857Z","comments":true,"path":"2020/07/09/J-U-C之CycliBarrier使用/","link":"","permalink":"wbc.wiki/2020/07/09/J-U-C%E4%B9%8BCycliBarrier%E4%BD%BF%E7%94%A8/","excerpt":"","text":"作用 实现屏障等待功能，支持多个线程一起完成任务的目标，与CountDownLatch相比较，CyclicBarrier侧重的是一个线程没完成任务，则多个线程必须等待。 API await：等待 await(long timeout, TimeUnit unit)：在规定时间内还没达到parties数量，则抛出超时异常 getNumberWaiting: 获取已到屏障掉的线程数 getParties：获取parties数 isBroken: 判断屏障是否处于损坏状态 reset：重置屏障，即将原来的parties重置为初始值 示例1234567891011121314151617181920212223242526272829303132333435public class CyclicBarrierDemo1 extends Thread &#123; private CyclicBarrier cyclicBarrier; public CyclicBarrierDemo1(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; try &#123; Thread.sleep(500); System.out.println(Thread.currentThread().getName() + \"完成了\"); // 全部完成才会是否 cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new Runnable() &#123; public void run() &#123; // cyclicBarrier全部执行了将会回调run方法 System.out.println(\"全部已完成\"); &#125; &#125;); for (int i = 0; i &lt; 3; i++) &#123; new CyclicBarrierDemo1(cyclicBarrier).start(); &#125; &#125;&#125; 当线程数等于CyclicBarrier的parties数时，这是正常的，大于也是正常的，但是线程数如果小于parties了，那么将会一直阻塞。 特性 屏障重置性：parties可以重置归为0 破坏模型：当其中一个线程中断或提前离开了屏障点，其他线程也会离开屏障点 与CountDownLatch比较 CountDownLatch的计数不能重置，CyclicBarrier可以 CountDownLatch计数为0释放等待的线程，CyclicBarrier达到指定值，释放等待的线程 CountDownLatch不可以重复利用，CyclicBarrier可以 源码分析成员变量 内部类，该类表示代123private static class Generation &#123; boolean broken &#x3D; false; &#125; lock：表示获取当锁 parties：指定parties数量 generation：当前代 count：仍在等待的数量 await方法1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125; &#125; 它调用了dowait方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 表示当前“代” final Generation g = generation; // 判断屏障是否损坏 if (g.broken) throw new BrokenBarrierException(); if (Thread.interrupted()) &#123; // 进行破坏屏障 breakBarrier(); throw new InterruptedException(); &#125; int index = --count; if (index == 0) &#123; // tripped // 表示所有线程都达到屏障了 boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) // 那么将会回调执行CyclicBarries的run方法 command.run(); // 可以认为执行栅栏任务成功了 ranAction = true; // 唤醒所有线程 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) // 执行失败，则破坏屏障 breakBarrier(); &#125; &#125; // loop until tripped, broken, interrupted, or timed out for (;;) &#123; try &#123; // timed这个值是由构造方法决定的，如果是使用有超时设置的构造方法，那么该值为true if (!timed) trip.await(); else if (nanos &gt; 0L) // 否则等待指定的时长 nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; if (g == generation &amp;&amp; ! g.broken) &#123; // 当前代，且屏障没有被破坏 breakBarrier(); throw ie; &#125; else &#123; Thread.currentThread().interrupt(); &#125; &#125; if (g.broken) throw new BrokenBarrierException(); if (g != generation) // 判断当前CyclicBarrier是不是这代的，不是则直接返回下标 return index; if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"并发编程基础","slug":"并发编程基础","date":"2020-07-09T04:29:30.000Z","updated":"2020-07-09T04:29:59.987Z","comments":true,"path":"2020/07/09/并发编程基础/","link":"","permalink":"wbc.wiki/2020/07/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"并发编程基础线程几个概念 进程：程序的一次执行，是资源的基本分配单位 线程：CPU调度的基本单元，同一个进程下的线程共享进程的资源，但每个线程都有自己的程序计数器和栈区域，线程间不共享 线程的创建方法 实现Runnable接口： 继承Thread，重写run方法 使用FutureTask方式，构造参数可以接收Callable对象和Runnable对象 通知与等待 等待是线程处于阻塞状态，持有了锁，通知是唤醒等待的线程 wait方法： 是Object的方法，对象将释放锁，如果对象没有获取到对象监视器时调用wait方法将抛出异常，因为只要线程持有了锁才能释放锁，获取对象监视器的方法可以使用Synchronized关键字，为了防止虚假唤醒（即没有使用notify唤醒线程）可以添加判断唤醒条件是否满足来处理。 共享对象调用wait方法，则当前线程只会释放当前共享对象的锁，其他的不会被释放。 wait方法还有个带超时参数的，如果在指定时间内被唤醒，那么将返回，继续往下走 notify方法： 随机唤醒一个被挂起的线程，被唤醒的线程不一定执行，，需要获取到对象监视器才可以继续执行 notifyAll方法 唤醒所有因wait方法而被挂起的线程 等待线程终止join方法： 等待多个线程处理完任务后才返回，否则阻塞 线程休眠sleep方法 该方法不释放锁，休眠不参与CPU的调度 让出CPU执行权yield方法 让出CPU执行权，即使它还没有执行完让任务 线程中断interrupt方法 中断线程，实际上只是设置有一个中断标志位的值为true，如果线程被挂起了，当有其他线程中断这个线程时会抛出InterruptedException异常。 isInterrupted方法 判断线程是否被中断 interrupted方法： 该方法是静态的，注意这个与interrupt方法不同，这个方法作用是检查当前线程是否被中断，它与isInterrupted方法也不同：如果发现当前线程被中断了，则会清除中断标志。“获取的当前调用线程的中断标志而不是调用interruped方法的示实例对象的中断标志”，也就是如果主线程里的子线程调用了interrupt方法设置了中断标志位，那么执行interrupted方法获取的却是主线程的中断标志。 线程死锁 多个线程执行过程中，因争夺资源而造成相互等待的现象 死锁产生的条件： 互斥条件 请求和保持条件 不可以剥夺条件 环路等待条件 守护线程和用户线程 线程可以分为守护线程和用户线程，当用户线程还没有结束时，JVM不会退出， 而守护线程不会影响JVM的退出&gt;。 ThreadLocal 提供保存线程本地变量的作用，对于ThreadLocal变量的操作，线程本地会有这个变量的本地副本，多个线程的操作都是操作自己本地内存里的副本。 每个线程Thread里都有一个ThreadLocalMap的对象threadLocals，key为ThreadLocal变量的this引用，value为自定义设置。 当设置value时，首先通过getMap获取到对应的线程变量ThreadLocalMap，如果不为空，则直接设置该值，否则创建并实例化ThreadLocalMap。 当获取value时，同样也是先获取ThreadLocalMap对象，通过获取ThreadLocalMap的内部类Entry来获取值。如果ThreadLocalMap对象为空，首先会进行初始化，初始化的value为null。 InheritableThreadLocal 该类继承了ThreadLocal，提供了子线程可以访问父线程设置的本地变量的作用。 并发有三个主要问题 原子性 有序性 可见性 Synchronized关键字 提供原子性、有序性、可见性的保障，对被修饰的变量的获取途径由工作内存改为直接从主内存中获取。存在弊端是会引起线程上下文的切换。 作用范围 代码块 对象 类 volitile关键字 保证变量的可见性和禁止重排序，当修改变量的值时会立即将该值刷回主内存，但是不保证原子性 指令重排序 JMM会对不存在数据依赖性的指令进行重排序，已提交编译速度，重排序后的执行结果与程序顺序执行的结果一致 锁乐观锁和悲观锁 悲观锁：认为数据很容易被其他线程修改，所以数据在处理前需要进行加锁 乐观锁：认为数据一般情况下不会冲突，只有在数据提交更新时才会对数据冲突进行检测 公平锁和非公平锁 以线程获取锁的抢占机制可以将锁分为公平锁和非公平锁 公平锁：线程获取锁的顺序以按照请求锁的时间顺序类决定 非公平锁：与公平锁相比，不按照顺序来，获取锁的时机不一定，与公平锁性能开销比较，性能较高 实现例子：ReentrantLock(isFairLock) 如果isFairLock为true则为公平锁，否则为非公平锁。 独占锁和共享锁 按照锁能被单个线程持有还是能被多个线程持有，可以将锁分为独占锁和共享锁 独占锁：锁只能被一个线程持有，是一种悲观锁实现例子：ReentrantLock 独占锁：锁能被多个线程持有，是一种乐观锁，实现例子：ReadWriteLock读写锁 可重入锁 持有锁的线程多次获取已经持有的锁的时候不被阻塞，那么该锁为可重入锁，synchronized内部锁是重入锁 重入N次，需要释放N次才能真正释放掉锁？ 自旋锁 当前线程没有获取到锁时，并不立即阻塞，而是重试多次获取锁，如果尝试指定次数后还没有获取到锁，那么线程才会被阻塞。","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"J.U.C之ScheduledExecutorService使用","slug":"J-U-C之ScheduledExecutorService使用","date":"2020-07-09T04:27:25.000Z","updated":"2020-07-09T04:28:00.085Z","comments":true,"path":"2020/07/09/J-U-C之ScheduledExecutorService使用/","link":"","permalink":"wbc.wiki/2020/07/09/J-U-C%E4%B9%8BScheduledExecutorService%E4%BD%BF%E7%94%A8/","excerpt":"","text":"作用 将定时任务和线程池功能结合起来 使用12345678910111213141516171819202122232425262728293031323334353637public class ScheduledThreadPoolExecutoreDemo1 &#123; public static void main(String[] args) &#123; List&lt;Callable&gt; callableList = new ArrayList&lt;&gt;(); callableList.add(new MyCallableA()); callableList.add(new MyCallableB()); // 使用的是单任务的计划任务池 ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(); ScheduledFuture futureA = scheduledExecutorService.schedule(callableList.get(0), 4, TimeUnit.SECONDS); ScheduledFuture futureB = scheduledExecutorService.schedule(callableList.get(1), 4, TimeUnit.SECONDS); try &#123; System.out.println(\"Begin: \" + System.currentTimeMillis()); System.out.println(\"futureA: \" + futureA.get()); System.out.println(\"futureB: \" + futureB.get()); System.out.println(\"End: \" + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; static class MyCallableA implements Callable &#123; @Override public Object call() throws Exception &#123; return \"return A\"; &#125; &#125; static class MyCallableB implements Callable &#123; @Override public Object call() throws Exception &#123; return \"return B\"; &#125; &#125;&#125; 上面示例的作用是延迟4秒后执行任务；schedule方法中的第一个参数也可以接收runnable类型的参数 scheduleAtFixedRate：周期性执行任务： 12ScheduledFuture&lt;?&gt; scheduledFuture = scheduledExecutorService.scheduleAtFixedRate(new MyRunnable(), 1, 2, TimeUnit.SECONDS); System.out.println(scheduledFuture.get()); 需要注意的是该方法获取的scheduledFuture对象是无法获取到返回值的。 scheduleWithFixedDelay：该方法也是周期性执行任务 getQueue：获取队列中的任务，该队列中存放的是将要执行的任务 12ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);scheduledThreadPoolExecutor.getQueue(); remove：在队列中移除指定的任务 1ScheduledThreadPoolExecutor.remove setExecuteExistingDelayedTasksAfterShutdownPolicy：默认值为true，作用是当执行了shutdown方法后，判断任务是否继续执行，true则继续执行 setContinueExistingPeriodicTasksAfterShutdownPolicy：当为true时，使用scheduleWithFixedDelay和scheduleAtFixedRate，如果执行了shutdown方法，则任务还会继续执行 cancel：是否取消任务，但是该任务依然会存在队列中，只是任务不会被执行 setRemoveOnCancelPolicy：是否将取消的任务从队列中清除","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"J.U.C之Executor 和ThreadPoolExecutor知识总结","slug":"J-U-C之Executor-和ThreadPoolExecutor知识总结","date":"2020-07-09T04:26:05.000Z","updated":"2020-07-09T04:26:55.691Z","comments":true,"path":"2020/07/09/J-U-C之Executor-和ThreadPoolExecutor知识总结/","link":"","permalink":"wbc.wiki/2020/07/09/J-U-C%E4%B9%8BExecutor-%E5%92%8CThreadPoolExecutor%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"Executor概念 线程池接口，不能被直接使用，需要实现类 继承结构如下： Excutor类及其相关子类.png Executor使用示例 newCachedThreadPool 12345678910111213 ExecutorService executorService = Executors.newCachedThreadPool();executorService.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" begin: \" + System.currentTimeMillis()); Thread.sleep(1000); System.out.println(\"end: \" + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); newCachedThreadPool(ThreadFactory threadFactory): 参数ThreadFactory示例，而ThreadFactory是一个接口，因此可以实现该接口，重写newThread方法，实现我们想要的功能 1234567891011121314151617181920212223242526 public static void main(String[] args) &#123; CustomizeFactory customizeFactory=new CustomizeFactory(); ExecutorService executorService = Executors.newCachedThreadPool(customizeFactory); executorService.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" begin: \" + System.currentTimeMillis()); Thread.sleep(1000); System.out.println(\"end: \" + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125;static class CustomizeFactory implements ThreadFactory &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r); thread.setName(\"自定义的线程工厂\"); return thread; &#125;&#125; newFixedThreadPool(int nThreads): 有界的线程池，可以设置线程池中的线程最大数量 1234567891011121314151617 public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 5; i++) &#123; executorService.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" begin: \" + System.currentTimeMillis()); Thread.sleep(1000); System.out.println(\"end: \" + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 示例中即使execute了大于三次，实际上也只会使用三个线程 newFixedThreadPool(int nThreads, ThreadFactory threadFactory)：可以自定义线程工厂，并设置线程池最大个数 newSingleThreadExecutor：创建单一线程，实际上是调用ThreadPoolExecutor并指定corePoolSize和maximumPoolSize都为1实现的 ExecutorService使用示例 invokeAny：取得第一个完成任务的结果值 1234567891011121314151617181920212223242526272829303132public class ExecutorServiceDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; List callableList = new ArrayList&lt;&gt;(); callableList.add(new CallableA()); callableList.add(new CallableB1()); ExecutorService executorService = Executors.newCachedThreadPool(); String value = executorService.invokeAny(callableList); System.out.println(\"结果为: \"+value); &#125; static class CallableA implements Callable &#123; @Override public Object call() throws Exception &#123; System.out.println(\"CallableA \" + Math.random()); return \"callableA\"; &#125; &#125; static class CallableB1 implements Callable &#123; @Override public Object call() throws Exception &#123; System.out.println(\"CallableB1 \" + Math.random()); return \"CallableB1\"; &#125; &#125;&#125; invokeAny(Collection&lt;? extends Callable&gt; tasks, long timeout, TimeUnit unit)：在指定时间内取得第一个先执行任务的结果值 invokeAll(Collection&lt;? extends Callable&gt; tasks)：返回所有任务的执行结果 invokeAll(Collection&lt;? extends Callable&gt; tasks, long timeout, TimeUnit unit):如果全部任务在指定时间内没有完成，则抛出异常 ThreadPoolExecutor概念与作用 Executor的可以直接实例化的实现类，用于创建线程池对象 使用构造方法：构造方法一： 12345ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 构造方法二： 123456ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) 构造方法三： 123456ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) 构造方法四： 1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePooSize：核心线程数最大值 maximumPoolSize：线程池最大线程数 keepAliveTime：线程数大于corePoolSize时，超过该时间，将会删除，为0时，线程执行完任务会立即在队列中删除 unit： 时间单位 workQueue：执行前用于保持任务的队列 threadFactory：线程工厂 handler：处理任务被拒绝执行时的行为，RejectedExecutionHandler是一个接口，如果我们想自定义拒绝处理行为，那么可以类似这样： 12345678910 static class CustomizeExecutionHandler implements RejectedExecutionHandler &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.out.println(\"被拒绝执行了\"); &#125; &#125; // 在创建线程池时使用 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 3, 9999L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); threadPoolExecutor.setRejectedExecutionHandler(new CustomizeExecutionHandler()); 其他方法 shutdown：执行完当前任务后，主线程结束，不在添加新的任务，队列中任务还是会正常执行的 shutdownNow：中断所有任务，队列中未执行的线程不再执行，同时会返回未被执行的任务列表，如果在shutdownNow方法后面又execute线程，将会抛出异常 isShutdown：判断线程池是否关闭 awaitTermination(long timeout, TimeUnit unit)：如果有任务正在执行，阻塞线程，在指定时间之后，再去判断线程池是否已经关闭了，否则不阻塞 allowCoreThreadTimeOut(boolean value) ：设置核心线程是否具有超时效果，超时时间由创建线程池时指定 几个要点说明 1、创建的线程数量小于corePoolSize，那么即使设置了超时时间，该参数也不会起作用 2、创建的线程大于corePoolSize，并且小于等于最大线程数，workQueue使用的时LinkedBlockDeue队列，那么maximumPoolSize和keepAliveTime可以被忽略 3、创建的线程大于corePoolSize，并且小于等于最大线程数，workQueue使用的时SynchronousQueue队列，那么maximumPoolSize和keepAliveTime会起作用 执行流程图 执行流程图","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"J.U.C之Fork-Join使用","slug":"J-U-C之Fork-Join使用","date":"2020-07-09T04:24:13.000Z","updated":"2020-07-09T04:25:34.282Z","comments":true,"path":"2020/07/09/J-U-C之Fork-Join使用/","link":"","permalink":"wbc.wiki/2020/07/09/J-U-C%E4%B9%8BFork-Join%E4%BD%BF%E7%94%A8/","excerpt":"","text":"作用 ForkJoinPool继承AbstractExecutorService，提供线程池的功能 常用方法 execute：以异步的形式执行任务，该方法 没有返回值 submit：有返回值，使用ForkJoinTask的get方法获取 invoke：异步执行任务，直接将返回结果返回 shutdown：关闭任务，但不具有中断的效果 shutdownNow：如果跟isInterrupted==true来判断，那么会立即停止当前正在执行的任务，并不允许接收新任务；没有跟isInterrupted==true来判断，那么当前执行的任务会正常运行到结束 isTerminated()：如果关闭后所有任务都已完成则返回true isShutdown：判断任务是否关闭 awaitTermination：等待线程池被销毁的最长时间，具有阻塞性 isCompletedNormally:判断任务是否正常执行完毕 getException：获取任务执行时返回的异常信息 ForkJoinTask执行任务的具体类，但该类是一个抽象类，下面三个类是其子类： RecursiveAction：没有返回值 123456789101112131415161718192021222324252627282930public class RecursiveActionDemo1 extends RecursiveAction &#123; private int beginValue; private int endValue; public RecursiveActionDemo1(int beginValue, int endValue) &#123; this.beginValue = beginValue; this.endValue = endValue; &#125; @Override protected void compute() &#123; System.out.println(Thread.currentThread().getName() + \"-----------开始\"); if (endValue - beginValue &gt; 2) &#123; int middleNum = (beginValue + endValue) / 2; RecursiveActionDemo1 leftAction = new RecursiveActionDemo1(beginValue, middleNum); RecursiveActionDemo1 rightAction = new RecursiveActionDemo1(middleNum+1, endValue); this.invokeAll(leftAction, rightAction); &#125; else &#123; System.out.println(\"打印组合为: \" + beginValue + \"---\" + endValue); &#125; System.out.println(Thread.currentThread().getName() + \"-----------结束\"); &#125; public static void main(String[] args) throws InterruptedException &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); forkJoinPool.submit(new RecursiveActionDemo1(1, 10)); Thread.sleep(5000); &#125;&#125; CountedCompleter：具有返回值 RecursiveTask 12345678910111213public class RecursiveTaskDemo1 extends RecursiveTask&lt;Integer&gt; &#123; @Override protected Integer compute() &#123; return 100; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; RecursiveTaskDemo1 recursiveTaskDemo1 = new RecursiveTaskDemo1(); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Integer&gt; joinTask = forkJoinPool.submit(recursiveTaskDemo1); System.out.println(\"joinTask: \" + joinTask.get()); &#125;&#125; ForkJoinTask有两种方法获取返回值：get和join，前者遇到异常时能够进行捕获，join则直接抛出，执行多个 任务时join获取结果是同步的","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"J.U.C之Phaser移相器使用","slug":"J-U-C之Phaser移相器使用","date":"2020-07-09T04:21:18.000Z","updated":"2020-07-09T04:23:14.050Z","comments":true,"path":"2020/07/09/J-U-C之Phaser移相器使用/","link":"","permalink":"wbc.wiki/2020/07/09/J-U-C%E4%B9%8BPhaser%E7%A7%BB%E7%9B%B8%E5%99%A8%E4%BD%BF%E7%94%A8/","excerpt":"","text":"概念与作用 移相器，可用于线程进行分组同步控制，解决分阶段共同完成任务的需求 常用API arriveAndAwaitAdvance：到达屏障处等待，等待其他线程达到屏障处，满足条件后继续向下一个屏障执行 arriveAndDeregister：动态撤销线程在phaser的注册，表示不参与后面阶段工作 getPhase：获取已经达到第几个屏障 onAdvance：通过新屏障时被调用，如果通过第一个屏障时返回了true，那么后面的phaser不进行工作，取消屏障 1234567 Phaser phaser = new Phaser(2) &#123; protected boolean onAdvance(int phase, int registerdParties) &#123; System.out.println(\"被调用了\"); // true不进行等待 return true; &#125;&#125;; getRegisteredParties：获取注册的parties数目 register: 动态增加parties值，每次加一 bulkRegister：动态增加parties值，可以指定每次增加的数目 getArrivedParties：获取已使用的parties的数目 getUnarrivedParties：获取未使用的parties的数目 arrive：是parties加一，且不再屏障出等待 awaitAdvance(int phase)：如果参数和getPhase方法返回值一样，则在屏障出等待，否则继续执行。 awaitAdvanceInterruptibly(int phase)：表示可中断 awaitAdvanceInterruptibly(int phase,long timeout, TimeUnit unit)：指定栏数等待最大的单位时间，如在指定时间内栏数没有变化，则继续向下运行 forceTermination：是凭证处于终结状态，即屏障失效 isTerminated：判断phaser是否失效 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class PhaserDemo1 &#123; public static Phaser phaser; public static void testA() &#123; System.out.println(Thread.currentThread().getName() + \" One Begin\" + System.currentTimeMillis()); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName() + \" One End\" + System.currentTimeMillis()); phaser.getArrivedParties(); System.out.println(Thread.currentThread().getName() + \" Two Begin\" + System.currentTimeMillis()); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName() + \" Two End\" + System.currentTimeMillis()); &#125; public static void testB() &#123; System.out.println(Thread.currentThread().getName() + \" One Begin\" + System.currentTimeMillis()); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName() + \" One End\" + System.currentTimeMillis()); System.out.println(Thread.currentThread().getName() + \" Two Begin\" + System.currentTimeMillis()); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName() + \" Two End\" + System.currentTimeMillis()); &#125; static class ThreadA extends Thread &#123; private Phaser phaser; public ThreadA(Phaser phaser) &#123; this.phaser = phaser; &#125; @Override public void run() &#123; PhaserDemo1.testA(); &#125; &#125; static class ThreadB extends Thread &#123; private Phaser phaser; public ThreadB(Phaser phaser) &#123; this.phaser = phaser; &#125; @Override public void run() &#123; PhaserDemo1.testA(); &#125; &#125; static class ThreadC extends Thread &#123; private Phaser phaser; public ThreadC(Phaser phaser) &#123; this.phaser = phaser; &#125; @Override public void run() &#123; PhaserDemo1.testB(); &#125; &#125; public static void main(String[] args) &#123; Phaser phaser = new Phaser(3); PhaserDemo1.phaser=phaser; new ThreadA(phaser).start(); new ThreadB(phaser).start(); new ThreadC(phaser).start(); &#125;&#125; 需要注意的是如果parties数大于线程数，将会一直阻塞","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发包","slug":"并发包","permalink":"wbc.wiki/tags/%E5%B9%B6%E5%8F%91%E5%8C%85/"}]},{"title":"Zookeeper选举算法分析: 以FastLeader为例","slug":"Zookeeper选举算法分析-以FastLeader为例","date":"2020-04-28T13:35:04.000Z","updated":"2020-04-28T13:36:01.780Z","comments":true,"path":"2020/04/28/Zookeeper选举算法分析-以FastLeader为例/","link":"","permalink":"wbc.wiki/2020/04/28/Zookeeper%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-%E4%BB%A5FastLeader%E4%B8%BA%E4%BE%8B/","excerpt":"","text":"Zookeeper选举算法分析: 以FastLeader为例选举算法源码入口: org.apache.zookeeper.server.quorum.QuorumPeerMain#initializeAndRun 12345678910111213141516171819202122232425262728 protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServerException &#123; QuorumPeerConfig config = new QuorumPeerConfig(); if (args.length == 1) &#123; config.parse(args[0]); &#125; // Start and schedule the the purge task DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config .getDataDir(), config.getDataLogDir(), config .getSnapRetainCount(), config.getPurgeInterval()); purgeMgr.start(); // 判断是单机还是集群模式 if (args.length == 1 &amp;&amp; config.isDistributed()) &#123; runFromConfig(config); &#125; else &#123; LOG.warn(\"Either no config or no quorum defined in config, running \" + \" in standalone mode\"); // there is only server in the quorum -- run as standalone ZooKeeperServerMain.main(args); &#125; &#125;``` 首先判断一下如果是集群模式的话，则会调用 **org.apache.zookeeper.server.quorum.QuorumPeerMain#runFromConfig**方法这个方法主要是读取配置文件信息对**QuorumPeer**进行初始化。最后开启线程```javaquorumPeer.start() ps:QuorumPeer翻译过来就是仲裁人 接着我们来到org.apache.zookeeper.server.quorum.QuorumPeer#start这个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 public synchronized void start() &#123; if (!getView().containsKey(myid)) &#123; throw new RuntimeException(\"My id \" + myid + \" not in the peer list\"); &#125; // 从本地文件中恢复数据 loadDataBase(); startServerCnxnFactory(); ... startLeaderElection(); super.start(); &#125;``` 这里又调用了loadDataBase这个方法，这个方法主要获取当前的epoch和最新的zxid;接着调用org.apache.zookeeper.server.quorum.QuorumPeer#startLeaderElection方法进行选举初始化。```java synchronized public void startLeaderElection() &#123; try &#123; // 如果当前是LOOKING状态，则投票给自己 if (getPeerState() == ServerState.LOOKING) &#123; currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch()); &#125; &#125; catch(IOException e) &#123; ... &#125; if (electionType == 0) &#123; ... &#125; this.electionAlg = createElectionAlgorithm(electionType); &#125;``` 接着就是使用createElectionAlgorithm，这个方法主要目的就是根据配置文件中配置的选举算法类型，创建选举算法。```java protected Election createElectionAlgorithm(int electionAlgorithm)&#123; Election le=null; //TODO: use a factory rather than a switch switch (electionAlgorithm) &#123; case 0: le = new LeaderElection(this); break; case 1: le = new AuthFastLeaderElection(this); break; case 2: le = new AuthFastLeaderElection(this, true); break; case 3: // 默认是这个 QuorumCnxManager qcm = createCnxnManager(); QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm); if (oldQcm != null) &#123; LOG.warn(\"Clobbering already-set QuorumCnxManager (restarting leader election?)\"); oldQcm.halt(); &#125; QuorumCnxManager.Listener listener = qcm.listener; if(listener != null)&#123; //启动已绑定端口的选举线程，等待集群中其他机器的连接 listener.start(); FastLeaderElection fle = new FastLeaderElection(this, qcm); fle.start(); le = fle; &#125; else &#123; ... &#125; break; default: assert false; &#125; return le;``` 实例化FastLeaderElection，对proposedLeader、proposedZxid、接收队列和发送队列进行初始化。通过FastLeaderElection的start方法启动选举线程，这里也启动了两个队列：发送队列和接收队列.```java void start()&#123; this.wsThread.start(); this.wrThread.start(); &#125; 接着来到org.apache.zookeeper.server.quorum.QuorumPeer#run这个方法里，这里面有段主要的代码： 1234567891011121314151617181920212223242526272829303132333435363738case LOOKING: if (Boolean.getBoolean(\"readonlymode.enabled\")) &#123; final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb); Thread roZkMgr = new Thread() &#123; public void run() &#123; try &#123; sleep(Math.max(2000, tickTime)); if (ServerState.LOOKING.equals(getPeerState())) &#123; roZk.startup(); &#125; &#125; catch (InterruptedException e) &#123; &#125; catch (Exception e) &#123; &#125; &#125; &#125;; try &#123; roZkMgr.start(); reconfigFlagClear(); if (shuttingDownLE) &#123; shuttingDownLE = false; startLeaderElection(); &#125; setCurrentVote(makeLEStrategy().lookForLeader()); &#125; catch (Exception e) &#123; &#125; finally &#123; &#125; &#125; else &#123; try &#123; reconfigFlagClear(); if (shuttingDownLE) &#123; shuttingDownLE = false; startLeaderElection(); &#125; setCurrentVote(makeLEStrategy().lookForLeader()); &#125; catch (Exception e) &#123; &#125; &#125; 上诉代码通过** setCurrentVote(makeLEStrategy().lookForLeader());**进行最终确认选举算法。 这里以FastLeaderElection算法为例，setCurrentVote第二个参数正是org.apache.zookeeper.server.quorum.FastLeaderElection#lookForLeader方法。在这个方法中使用logicalclock.incrementAndGet();来表示epoch，使用 updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch()); 来更新投票结果。 123456synchronized void updateProposal(long leader, long zxid, long epoch)&#123; ... proposedLeader = leader; proposedZxid = zxid; proposedEpoch = epoch;&#125; 使用sendNotifications发送投票结果。 123456789101112131415161718private void sendNotifications() &#123; for (long sid : self.getCurrentAndNextConfigVoters()) &#123; QuorumVerifier qv = self.getQuorumVerifier(); // 创建要发送的消息 ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes()); if(LOG.isDebugEnabled())&#123; ... &#125; // 添加到发送队列 sendqueue.offer(notmsg); &#125;&#125; 继续来看lookForLeader方法，当状态处于LOOKING时，一直循环从接收队列中拿出投票消息，并判断消息是否发送完毕，是则再次发送，否则执行以下逻辑: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 收到投票信息，判断消息是否属于这个集群 else if (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123; switch (n.state) &#123; case LOOKING: // If notification &gt; current, replace and send messages out // 如果当前消息的epoch大于logicalclock，表示这是新的一场投票 if (n.electionEpoch &gt; logicalclock.get()) &#123; // 更新本地epoch logicalclock.set(n.electionEpoch); // 清空原来的接收消息的队列 recvset.clear(); // 检查是否可以对方胜出 if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123; // 更新票据结果为对方票据 updateProposal(n.leader, n.zxid, n.peerEpoch); &#125; else &#123; // 否则票据不变 updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch()); &#125; sendNotifications(); &#125; else if (n.electionEpoch &lt; logicalclock.get()) &#123; if(LOG.isDebugEnabled())&#123; ... &#125; break; &#125; else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123; // epoch相同，则比较zxid和myid updateProposal(n.leader, n.zxid, n.peerEpoch); sendNotifications(); &#125; if(LOG.isDebugEnabled())&#123; ... &#125; // don't care about the version if it's in LOOKING state // 添加到本机投票集合，用作最终选举终结判断 recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch)); if (termPredicate(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch))) &#123; while((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null)&#123; // 一直等待新的通知，直到超时，作用是： if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch))&#123; recvqueue.put(n); break; &#125; &#125; if (n == null) &#123; // 如果当前服务器是leader，那么修改状态为leading self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING: learningState()); Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch); // 将接收队列清空 leaveInstance(endVote); return endVote; &#125; &#125; 上述方法使用到totalOrderPredicate，该方法如下： 12345678910protected boolean totalOrderPredicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch) &#123; if(self.getQuorumVerifier().getWeight(newId) == 0)&#123; return false; &#125; return ((newEpoch &gt; curEpoch) || ((newEpoch == curEpoch) &amp;&amp; ((newZxid &gt; curZxid) || ((newZxid == curZxid) &amp;&amp; (newId &gt; curId)))));&#125; 从这个方法便可以得知：投票的PK是先比较epoch，如果相同则再比较zxid，如果zxid也相同，那么则比较severID。 使用到termPredicate方法判断选举是否结束，默认超过半数server同意 123456789101112131415161718 protected boolean termPredicate(Map&lt;Long, Vote&gt; votes, Vote vote) &#123; SyncedLearnerTracker voteSet = new SyncedLearnerTracker(); voteSet.addQuorumVerifier(self.getQuorumVerifier()); if (self.getLastSeenQuorumVerifier() != null &amp;&amp; self.getLastSeenQuorumVerifier().getVersion() &gt; self .getQuorumVerifier().getVersion()) &#123; voteSet.addQuorumVerifier(self.getLastSeenQuorumVerifier()); &#125; // 把投票项放入set for (Map.Entry&lt;Long, Vote&gt; entry : votes.entrySet()) &#123; if (vote.equals(entry.getValue())) &#123; voteSet.addAck(entry.getKey()); &#125; &#125;// 统计set集合，判断某个server的票数是否超过了一半 return voteSet.hasAllQuorums(); &#125; 选举过程图如下 选举过程图","categories":[{"name":"分布式","slug":"分布式","permalink":"wbc.wiki/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"wbc.wiki/tags/zookeeper/"}]},{"title":"zookeeper知识总结","slug":"zookeeper知识总结","date":"2020-04-28T13:30:46.000Z","updated":"2020-04-28T13:31:56.226Z","comments":true,"path":"2020/04/28/zookeeper知识总结/","link":"","permalink":"wbc.wiki/2020/04/28/zookeeper%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"zookeeper概念、作用 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、命名服务、分布式同步、组服务等。 应用场景： 数据发布/订阅：当数据发生变化则发送watch消息给客户端，让客户端重新读取这个节点的数据。可以实现配置文件动态更新。 负载均衡 命名服务：类似于注册中心 分布式协调/通知：某个节点改变了，将这个变化发送给注册了这个节点的watcher的所有客户端 集群管理：能感知新接节点加入或节点的删除 分布式锁：将znode作废一把锁，能够创建成功的客户端则获取这把锁，删除则释放锁。 保持独占 控制时序 分布式队列 同步队列：利用临时节点，监听节点数目是否已达到要求 队列按照 FIFO 方式进行入队和出队操作：创建持久有序节点，znode 用于消息存储，出队则删除序列号最小的节点。 配置文件解析 dataDir:快照文件存储目录 dataLogDir:日志存储目录 tickTime:zookeeper中最小的时间单元长度 initLimit:默认为10，表示的tickTime值的倍数，用于配置数据同步的时间 syncLimit:默认值为5，表示tickTime的倍数，用于配置leader服务器和follower服务器之间进行心跳检车的最大延时时间。 server.id=host:port1:port2 ：配置集群机器列表。第一个端口用于leader和follower之间的通信和数据同步，第二个端口用进行选举过程的投票通信 节点 DataNode 数据节点，底层是ConcurrentHashMap。 节点类型 持久节点 临时节点 持久有序节点 临时有序节点 节点信息 状态属性 说明 czxid 节点被创建时的事务ID mzxid 节点最后一次被修改时的事务ID ctime 节点被创建时的时间 mtime 节点最后一次被修改时的时间 version 节点的版本号：变更次数 cversion 子节点的版本号 aversion ACL版本号 ephemeralOwner 临时节点的会话sessionID dataLength 数据内容的长度 numChildern 子节点的个数 pzxid 子节点列表最后一次被修改时的事务ID（当子节点列表更改才会修改这个值） 角色 leader foollower observer 工作状态 looking：没有leader，需要进行选举 following：表示当前server的角色是follower leading： 表示当前server的角色是leader observing： 表示当前server的角色是observer 数据同步注册流程： 1、follower和observer向leader注册 2、数据同步 3、同步确认 同步分类 直接差异化同步（DIFF同步）：场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog 先回滚再差异化公布： 场景：旧的的leader存在一条事务不在新的leader服务器上 仅回滚同步（TRUNC同步）：场景：peerLastZxid 大于 maxCommittedLog 全量同步（SNAP同步）： 文件系统 提供一个多层级的节点命名空间（节点称为 znode），每个节点的存放数据上限为1M。 节点类型 持久节点 临时节点：不能存在子节点 持久有序节点 临时有序节点 有序节点节点名称可以同名？ Watcher 机制watcher特性 一次性：watcher被触发了，就会从存储中删除 串行执行：客户端watcher回调是一个串行同步的过程 轻量 异步：watcher通知事件从server发送到client是异步的 注册watcher getData exists getChildren 触发watcher create delete setData watcher事件类型 NodeCreated NodeDeleted NodeDataChanged NodeChildrenChanged event For “/path” event For “/path/child” create(“/path”) NodeCreated 无 delete(“/path”) NodeDeleted 无 setData(“/path”) NodeDataChanged 无 create(“/path/child”) NodeChildrenChanged NodeCreated delete(“/path/child”) NodeChildrenChanged NodeDeleted setData(“/path/child”) 无 NodeDataChanged 客户端注册watcher 客户端注册watcher流程图 服务端处理watcher 服务端接收 Watcher 并存储 Watcher 触发 封装 WatchedEvent 查询 Watcher 没有找到，则客户端没有注册watcher 找到，则中watchtable和watcher2paths中删除对应watcher 调用 process 方法来触发 Watcher 客户端回调watcher 反序列化成watcherEvent对象 取出相关的全部watcher，添加到等待队列，等待EventThread的消费 EventThread线程每次从waiting Events队列中取出一个watcher进行串行同步处理 回调process方法完成回调。 事件监听demo 使用zookeeper原生方法监听watcher事件：zookeeer监听watcher事件 使用curator监听watcher事件：curator监听watcher事件 ACL权限模式 IP：通过IP地址细粒度进行权限控制 Digest: 通过权限标识来进行权限匹配 World:一种特殊的 digest 模式，只有一个权限标识，“world:anyone“，最开放的 Super: 超级用户 授权对象 权限permission CREATE DELETE READ WRITE ADMIN ZAB协议 一种支持崩溃恢复的原子广播协议 2PC提到ZAB协议，我们需要先了解一个2PC（二阶提交）的原理。示例图如下： 事务提交 中断提交 zookeeper的2PC（二阶提交） zookeeper的2PC 崩溃恢复奔溃恢复需要保证两种特性: 已提交的事务不被丢弃：确保那些已经在 Leader 提交的事务最终会被所有服务器提交 已丢弃的事务不再出现：丢弃那些只在 Leader 提出/复制，但没有提交的事务 选举出zxid最大的那个服务器作为leader，这样保证了已提交事务的不会被丢失、被丢弃的消息不会再出现。 包含了上一个epoch周期未提交的事务proposal的服务器再次启动时，不能成为leader，因为集群中的机器包含了更高epoch的事务proposal。 消息广播：改进版本的2pc 与传统2PC相比较，去除了中断逻辑。消息广播协议是居于具有FIFO的TCP协议来进行网络通信的，确保消息接收和发送的顺序性。 消息广播示例图 ZXID 消息广播使用到64位的ZXID来作为事务ID，该ID是全局唯一的、递增的。有高32位epochID和低32位消息计数器组成。每当有新的leader被选举出来时，epochID会进行加一，消息计算器则会重写从0开始计算。 选举myid越大，在leader选举中权重越大。 投票过程： 1、先判断epoch，大的为leader，相等则进入第二步 2、判断zxid: zxid比较大的服务器优先作为leader，相等则判断myid 3、判断myid:如果是首次启动，zxid都为0，那么需要判断myid，myid最大的服务器作为leader 统计投票:如果半数服务器接收到相同的投票信息，那么便认为选举出了leader了 选举算法可以看《Zookeeper选举算法分析: 以FastLeader为例》这一篇 选举需要保证同在logicallock? zookeeper实现分布式锁 多个客户端创建临时有序节点，节点集合中编号最小的节点的持有者，表示获取到锁。 锁用完后，删除节点，表示释放锁。而剩下节点最小的也获取到锁，以此列推。子节点集合中各个节点只监听编号比自己小的节点。 zookeeper实现分布式锁例子 注：原生的方式比较麻烦，可以使用curator提供的API实现分布式锁 zookeeper工作流程 发现：选举出leader 同步：leader和flower进行数据同步 广播：结束事务请求。广播消息 客户端 初始化阶段： 初始化zookeeper对象 设置会话默认watcher：该watcher保存到ClientWatchManager中 构造zookeeper服务器地址列表管理器：HostProvider 创建并初始化客户端网络连接器：ClientCnxn 初始化SendThread和EventThread 会话创建阶段： 启动SendThread和EventThread 获取服务器地址 创建TCP连接 构造ConnectRequest请求 发送请求 响应处理阶段： 接收服务端响应 处理response，得到ConnectResponse对象 连接成功：生成SyncConnected-None事件 查询watcher，将其放到waitingEvent队列 处理事件:EventThread处理waitingEvent中的watcher对象 数据同步先来看下面三个概念： 1、peerLastZxid:该learner服务器最后处理的ZXID 2、minCommittedLog：leader服务器提议缓存队列committedLog的最小ZXID 3、maxCommittedLog：leader服务器提议缓存队列committedLog的最大ZXID DIFF：直接差异化同步 peerLastZxid介于minCommittedLog和maxCommittedLog使用 TRUNC+DIFF:先回滚再差异化同步 leader服务器发现某个learner包含了一条自己没有的事务记录，那么就让learner进行事务回滚，回滚到leader服务器上存在，同时最接近peerLastZxid的ZXID。 TRUNC：仅回滚同步 peerLastZxid大于maxCommittedLog SNAP:全量同步 场景：peerLastZxid小于minCommittedLog或leader服务器没有提议缓存队列，peerLastZxid不等于lastProcessedZxid。","categories":[{"name":"分布式","slug":"分布式","permalink":"wbc.wiki/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"wbc.wiki/tags/zookeeper/"}]},{"title":"Spring拾遗","slug":"Spring拾遗","date":"2020-04-11T10:09:22.000Z","updated":"2020-04-30T00:00:10.042Z","comments":true,"path":"2020/04/11/Spring拾遗/","link":"","permalink":"wbc.wiki/2020/04/11/Spring%E6%8B%BE%E9%81%97/","excerpt":"","text":"一、spring结构 spring结构 主要有核心层、数据访问层、web层、以及AOP、Aspects、Instrumentation组成 核心层： Beans: 包括了控制反转、依赖注入。 core： 封装了最底层的部分，包括资源访问、类型转换等一些工具类 context: 资源绑定、数据验证、国际化、容器生命周期、事件传播等 expression language（EL）：EL表达式语言支持 二、工作原理先上图： springMVC工作流程图.png 说明 用户向服务器发送请求，请求被 springMVC 前端控制器 DispatchServlet 捕获； DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping，将请求映射到处理HandlerExcutionChain； DispatchServlet 根据获得 Handler 选择一个合适的 HandlerAdapter 适配器处理； HandlerAdapter 调用具体的处理器（controller） Handler 对数据处理完成以后将返回一个 ModelAndView（） 对象给 DisPatchServlet; Handler 返回的 ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet 通过ViewResolver 试图解析器将逻辑视图转化为真正的视图 View; DispatcherServle 通过 model 解析出 ModelAndView()中的参数进行解析最终展现出完整的 view 并返回给客户端 三、注解xml定义会覆盖注解？ 在配置文件中通过&lt;context:annotation-config /&gt;来开启注解装配 四、bean的生命周期（重点）参考文章：https://juejin.im/post/5daced865188255a270a0de6 bean生命周期流程 Bean容器在配置文件中找到Spring Bean的定义。 Bean容器使用Java Reflection API创建Bean的实例 如果声明了任何属性，声明的属性会被设置。如果属性本身是Bean，则将对其进行解析和设置。 如果Bean类实现BeanNameAware接口，则将通过传递Bean的名称来调用setBeanName()方法。 如果Bean类实现BeanClassLoaderAware接口，则将通过传递加载此Bean的ClassLoader对象的实例来调用setBeanClassLoader()方法。 如果Bean类实现BeanFactoryAware接口，则将通过传递BeanFactory对象的实例来调用setBeanFactory()方法。 如果有任何与BeanFactory关联的BeanPostProcessors对象已加载Bean，则将在设置Bean属性之前调用postProcessBeforeInitialization()方法。 如果Bean类实现了InitializingBean接口，则在设置了配置文件中定义的所有Bean属性后，将调用afterPropertiesSet()方法。 如果配置文件中的Bean定义包含init-method属性，则该属性的值将解析为Bean类中的方法名称，并将调用该方法。 如果为Bean Factory对象附加了任何Bean 后置处理器，则将调用postProcessAfterInitialization()方法。 如果Bean类实现DisposableBean接口，则当Application不再需要Bean引用时，将调用destroy()方法。 如果配置文件中的Bean定义包含destroy-method属性，那么将调用Bean类中的相应方法定义。 五、AOP面向切面编程。 切面：通知和切点的结合 连接点：应用执行过程中能够插入切面的一个点 通知（Advice）：切面的工作被称为通知 切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点 织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程 关注点（concern）是应用中一个模块的行为，横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能。 spring只支持方法级别的连接点 切面Aspect 由切入点和通知组成，包含了横切逻辑、连接点定义 实现方法： 基于XML Schema 基于@Aspect注解 spring通知类型 before：前置通知，在方法被调用前调用通知功能 after：后置通知，方法完成后调用通知 after-returning：在目标方法成功执行后调用通知 after-throwing：方法抛出异常后调用通知 around：目标方法调用前后都调用通知 实现方式 静态代理：AspectJ，编译时生成AOP代理类，将切面织入了字节码 动态代理：Spring AOP，不修改字节码，临时生成AOP对象 六、IOC 将操作对象的调用权交给了容器，通过容器来实现对象组件的装配和管理。实现原理是工厂模式加反射机制 优点： 减少代码量。 使应用容易测试，单元测试不再需要单例和JNDI查找机制。 最小的代价和最小的侵入性使松散耦合得以实现 作用 便于管理对象的创建和依赖关系的维护 托管了类的产生过程 支持的功能 依赖注入 依赖检查 自动装配 七、BeanFactory 和 ApplicationContext区别ApplicationContext是BeanFactory的子接口 与BeanFactory相比较，ApplicationContext增加了一下功能： 继承MessageSource，因此支持国际化。 统一的资源文件访问方式。 提供在监听器中注册bean的事件。 支持同时加载多个配置文件。 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 BeanFactory是使用延迟加载来注入bean,因此如果没有调用getBean将可能不会发现异常。而ApplicationContext一次性创建了所有的bean。BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。 八、依赖注入 组件之间的依赖关系有容器在应用系统运行期决定，由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。 原则应用组件不应该负责查找资源或者其他依赖的协作对象，容器全权负责组件的装配 优势 查找定位操作与应用代码无关，交由容器管理 不依赖容器API，可以在容器外使用应用对象 实现方式 接口注入,spring4已弃用 构造器注入 setter方法注入 九、SpringBeanbean定义包含配置元数据、生命周期详情、依赖 配置元数据 XML配置文件 注解配置 基于Java的配置 作用域 singleton：每个bean在容器中只存在一个实例 prototype：有多个实例 request: 每次请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 session：每一个session中，一个bean对应一个实例，该作用域仅在基于web的Spring ApplicationContext情形下有效。 global-session：以session相比，这是一个全局的 线程安全性singleton不是线程安全的，prototype可以保证线程安全；如果bean是无状态的，bean也是安全的。 ps: 无状态: 由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态bean 多线程下处理并发问题 ThreadLocal：每个线程都拥有自己变量副本 线程同步机制：只有一份变量，每个线程访问前需要获取锁 生命周期重要的方法 setUp：在容器加载bean时被调用 teardown： 在容器写在类的时候被调用 十、自动装配 Spring通过BeanFactory中注入的方式自动处理bean之间的依赖关系 自动装配的方式 no: 默认的方式，不进行自动装配，通过手动ref来装配bean byType：通过参数的数据类型进行自动装配 byName: 通过bean的名称进行自动装配 constructor: 通过构造函数进行装配 audodetect: 自动探测，优先使用construct，否则使用byType spring还用到 @Autowired 的注解方式进行自动装配，使用前需在配置文件中配置 &lt;context:annotation-config /&gt;属性。它的原理是：利用AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到用@Autowired注解修饰的bean时，会在容器中查询是否有这个bean，有且只有一个那么将会返回，而有多个，则会通过名称去查找，查询不到则抛出异常。 局限性 重写：使用配置定义依赖，则需重写自动装配？ 不能自动装配基本类型 模糊：不如显示装配精确 十一、Spring数据访问spring dao的作用 使jdbc等数据访问即使更容易以一种统一的方式工作 jdbc template 提供便利的方法将数据库数据转换为基本数据类型和对象、执行数据库操作语句、提供数据错误处理等 Spring事务实现方式类型： 编程式i：开发人员通过编程的方式进行事务的管理，灵活但是难维护 声明式：通过注解和XML配置来管理事务，将业务代码是事务管理放分离 事务传播行为： PROPAGATION_REQUIRED:存在事务则加入，否则创建一个新的事务 PROPAGATION_SUPPORT: 存在事务则加入，否则以非事务执行 PROPAGATION_MANDATORY:存在事务则加入，否则抛出异常 PROPAGATION_REQUIRES_NEW: 无论当前是否存在事务，都创建事务 PROPAGATION_NEVER: 以非事务方式执行，当前存在事务则抛出异常 PROPAGATION_NESTED: 当前存在事务，则在嵌套事务中执行，没有则按REQUIRED属性执行 事务隔离 ISOLATION_DEFAULT: 默认，使用数据库隔离机制 ISOLATION_READ_UNCOMMITTED: 未提交读，事务未提交前就可以被其他事务读取，会出现幻读、脏读、不可重复读问题 ISOLATION_READ_COMMIT:一个事务被提交后才能被其他事务读取，会出现幻读、不可重复读 ISOLATION_REPEATABLE_READ:可重复读，多次读取同一个数据都是一致的 ISOLATION_SERIALIABLE:序列化，隔离级别最高，可防止上面出现的问题 ps: 脏读、不可重复读、幻读的概念","categories":[{"name":"Spring","slug":"Spring","permalink":"wbc.wiki/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"wbc.wiki/tags/Spring/"},{"name":"知识总结","slug":"知识总结","permalink":"wbc.wiki/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}]},{"title":"Redis知识总结","slug":"Redis知识总结","date":"2020-04-07T15:15:45.000Z","updated":"2020-07-12T12:43:22.439Z","comments":true,"path":"2020/04/07/Redis知识总结/","link":"","permalink":"wbc.wiki/2020/04/07/Redis%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"Redis一、数据类型 数据类型 1.1 字符串命令： setnx命令：键必须不存在，才可以设置成功。可作为分布式锁的一种实现方案 命令实例： 12345127.0.0.1:6379&gt; set hello worldOK127.0.0.1:6379&gt; get hello&quot;world&quot;127.0.0.1:6379&gt; 时间复杂度: 时间复杂度 内部编码有三种情况： int： 8个字节的长整型 embstr: 小于39个字节的字符串 raw: 大于39个字节的字符串 使用场景： 缓存 计数 共享session 限速 1.2 hash命令： hset、hget hexists hkeys、hvals hincrby 命令实例： 12345678127.0.0.1:6379&gt; hmset dev name &quot;devtool&quot; desc &quot;haha&quot; likes good127.0.0.1:6379&gt; hgetall dev1) &quot;name&quot;2) &quot;devtool&quot;3) &quot;desc&quot;4) &quot;haha&quot;5) &quot;likes&quot;6) &quot;good&quot; 时间复杂度： hash时间复杂度 内部编码： ziplist 压缩列表，元素个数小于hash-max-ziplist-entries配置（默认512个）使用 hashtable,当value大于64个字节或field个数大于512，编码有ziplist变为hashtable 使用场景： 保存对象属性 1.3 列表 一个列表最多可以存储232 -1个元素，可重复 命令： 命令 命令实例： 12345678910111213127.0.0.1:6379&gt; lpush hello world(integer) 1127.0.0.1:6379&gt; lpush hello nice(integer) 2127.0.0.1:6379&gt; lpush hello with(integer) 3127.0.0.1:6379&gt; lpush hello you(integer) 4127.0.0.1:6379&gt; lrange hello 0 101) &quot;you&quot;2) &quot;with&quot;3) &quot;nice&quot;4) &quot;world&quot; br命令不会阻塞导致后面的命令的不执行吗？ 时间复杂度： 时间复杂度 内部编码： ziplist linkedlist quicklist 使用场景： 消息队列 文章列表 组成队列、栈等 lpush+lpop=Stack（栈） lpush+rpop=Queue（队列） lpsh+ltrim=Capped Collection（有限集合） lpush+brpop=Message Queue（消息队列） 1.4 集合常用命令： zadd srem scard spop smembers sinter 交集 sunion 并集 sdiff 差集 命令实例： 12345127.0.0.1:6379&gt; sadd fruit apple127.0.0.1:6379&gt; sadd fruit orange127.0.0.1:6379&gt; SMEMBERS fruit1) &quot;orange&quot;2) &quot;apple&quot; 内部编码 intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时使用 hahstable 使用场景： 标签 随机数 社交需求 ​ 1.5 有序集合命令实例 12345678910111213141516127.0.0.1:6379&gt; zadd language 1 java(integer) 1127.0.0.1:6379&gt; zadd language 2 php(integer) 1127.0.0.1:6379&gt; zadd language 3 python(integer) 1127.0.0.1:6379&gt; zadd language 4 c(integer) 1127.0.0.1:6379&gt; ZRANGE language 0 10 withscores1) &quot;java&quot;2) &quot;1&quot;3) &quot;php&quot;4) &quot;2&quot;5) &quot;python&quot;6) &quot;3&quot;7) &quot;c&quot; 1.6 数据机构对应的内部编码 内部编码 二、Redis单线程模型 Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。 速度快的原因： 内存访问 NIO。使用epoll作为IO多路复用技术的实现 单线程避免了线程切换和竞态产生的消耗 三、Redis其他功能3.1 bitmap命令： setbit key offset value 设置值 gitbit key offset 获取值 bitcount [start][end] 获取指定范围的个数 bitop op destkey key[key….] op可以为and（交集）、or（并集）、not（非）、xor（异或） 3.2 HyperLogLog3.3 发布订阅命令： publish channel message 发布消息 subscribe channel [channel …] 订阅消息 unsubscribe [channel [channel …]] 取消订阅 pubsub channels [pattern] 查看活跃的频道 pubsub numsub [channel …] 查询频道数 3.4 GEO 地理信息定位用来实现基于地理位置信息的应用,例如查找附近的人 3.5 事务 Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。 redis事务的特点： redis 不支持回滚，事务失败时不进行回滚，而是继续执行余下的命令。 如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 如果在一个事务中出现运行错误，那么正确的命令会被执行。 事务的三个阶段： 事务开始 MULTI 命令入队 事务执行 EXEC 四、Redis客户端 Redisson、Jedis、lettuce等等，官方推荐使用Redisson RESP格式 1234567891011*&lt;参数数量&gt; CRLF$&lt;参数1的字节数量&gt; CRLF&lt;参数1&gt; CRLF...$&lt;参数N的字节数量&gt; CRLF&lt;参数N&gt; CRLF 4.1 java 客户端jedis与Redission相比，jedis支持排序、事务、管道、分区等Redis特性。 主要要熟悉其api和jedis连接池的使用 jedis 基本使用 jedis 使用pipeline jedis 使用lua jedis poll Jedis对象个数是有限的，默认是8个 4.2 Redis客户端API命令 client list 列出与Redis服务端相连的所有客户端连接信息 info clients 列出缓冲区信息两者相比较 两种命令的比较 4.3 缓冲区输入缓冲区： qbuf：缓冲区总容量 qbuf-free: 剩余容量 输出缓冲区： obl： 固定缓冲区的长度 oll： 动态缓冲区列表的长度 omem： 使用的字节数 输出缓冲区有三种客户端：普通客户端、发布订阅客户端、slave客户端 4.4 常见异常及产生原因： 无法从连接池获取到连接 客户端读写超时 客户端连接超时 客户端缓冲区异常 Lua脚本正在执行 Redis正在加载持久化文件 Redis使用的内存超过maxmemory配置 客户端连接数过大 五、持久化两种持久化方式：RDB、AOF 5.1 RDB RDB：间隔时间生成数据集快照。适用于灾难恢复，只有一个文件，恢复速度快。父进程通过fork一个子线程来进行保存RDB的工作。由于生成RDB文件不是实时的，因此如果遇到故障，可能会丢失数据，使用fork创建子线程，频繁执行成本高，存在RDB文件格式兼容性问题。 触发RDB持久化过程分为手动触发和自动触发。手动触发命令： save bgsave 自动触发： 使用save相关配置 从节点执行全量复制操作 5.2 AOF AOF：通过文件追加命令的方式生成AOF文件，AOF是以Redis协议格式保存的，新的命令会被追加到文件末尾。AOF可以通过设置fsync策略来决定什么时候写，默认为每秒钟 fsync 一次。与RDB相比较，AOF速度较慢、文件体积较大。 AOF工作流程 6MSofA2hqnGCNZb 5.2.1 命令写入所有的写入命令会追加到aof_buf（缓冲区）中。直接追加文本，写入到缓冲区有个好处是Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。 5.2.2 文件同步AOF缓冲区根据对应的策略向硬盘做同步操作。文件同步策略： 6atIAc9LqDZRFOd write操作会触发延迟写机制,同步硬盘操作依赖于系统调度机制. fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化. 5.2.3 文件重写随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。重写文件可以使其变小，主要是因为：超时、无效命令不再写入、多条命令可以合并成一条。 AOP文件的重写机制分为手动和主动触发两种方式： 手动触发 ：直接调用bgrewriteaof命令。 自动触发 ：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机 auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。 重写过程： rMO1RiY2tU87laA 1、执行AOF重写请求2、fork子线程3、响应其他命令，并且将期间的命令写入到AOF缓冲区4、写入到新AOF文件5、子线程发送信号给父进程6、将AOF重写缓冲区写入到新的AOF文件7、替换旧AOF文件，完成重写 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。 UVkiPLCsbJ9ofDQ 六、性能问题与解决 master不要做持久化工作，例如存快照和AOF日志文件 Master 调用 BGREWRITEAOF 重写 AOF 文件，占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象 为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内 如果部署多个Redis实例，尽量保证同一时刻只有一个子进程在工作 避免在大量写入时做子进程重写操作，这样将导致父进程维护大量页副本，造成内存消耗 不要和其他CPU密集型服务部署在一起，造成CPU过度竞争 不要和其他高硬盘负载的服务部署在一起 开启配置no-appendfsync-on-rewrite，表示在AOF重写期间不做fsync操作。 七、复制 在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡等需求 复制的数据流是单向的，只能由主节点复制到从节点。 复制过程： 保存主节点（master）信息 主从建立socket连接 发送ping命令 权限验证 同步数据集： 同步过程分为：全量复制和部分复制 命令持续复制 八、阻塞内在原因： API或数据结构使用不合理 CPU饱和 持久化阻塞 外在原因： CPU竞争： 进程竞争、绑定CPU（对于开启了持久化或参与复制的主节点不建议绑定CPU） 内存交换 网络问题 九、内存9.1 内存消耗内存消耗可以分为进程自身消耗和子进程消耗info memory命令获取内存相关指标。 Redis进程内消耗主要包括：自身内存+对象内存+缓冲内存+内存碎片 子进程内存消耗 子进程内存消耗主要指执行AOF/RDB重写时Redis创建的子进程内存消耗 9.2 内存管理使用maxmemory参数限制最大可用内存，通过config set maxmemory进行动态修改内存上限 9.3 内存回收策略 删除过期键对象 惰性删除：当访问key时才判断是否过期，存在问题是可能存在大量没有被访问的过期的key 定时任务删除 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。 内存溢出控制策略 noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息。 volatile-lru：根据LRU算法删除设置了超时属性的键 allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性 allkeys-random：随机删除所有键 volatile-random：随机删除过期键 volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据 9.4 内存优化内存优化几个点： 缩减键值对象：key尽量使用简写，value可以进行压缩序列化 尽量使用整数对象以节省内存。注意：使用了LRU淘汰策略会使对象池无效，原因在于LRU字段被共享了，无法获取最后的访问时间。 尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。 不一定把每份数据作为字符串整体存储，可以使用其他数据结构 编码优化：例如使用ziplist编码类型可以大幅降低内存占用、整数集合时尽量使用intset编码且使用intset编码的集合时，尽量保持整数范围一致 减少键的个数 十、缓存设计10.1 缓存更新策略 LRU/LFU/FIFO算法剔除： 超时剔除： 主动更新 cFlaswjIQX1oG4L 10.2 缓存粒度控制缓存全部属性、只缓存部分重要属性 缓存粒度对比 10.3 缓存穿透 指查询一个根本不存在的数据，缓存层和存储层都不会命中 由于缓存层不存在的数据，导致每次请求都要到存储层去查询，增加了后端存储的负载。 优化方法1、缓存空对象：存储不命中后，将空对象作为值保存在缓存层中，可以设置一个较短的过期时间来防止大量的键占用空间。2、布隆过滤器拦截：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉。 布隆过滤器 10.4 无底洞优化 无底洞:投入越多不一定产出越多，即节点越多效率更加慢的现象 主要是减少网络操作次数： 串行命令，逐次执行n个get命令 串行IO：将属于同一个节点的key进行归档 并行IO：将串行IO改为多线程执行 hash_tag实现：hash_tag可以将多个key强制分配到一个节点上 几种优化方案对比： phRo7TJqNLacb6Q 10.5 雪崩优化 雪崩: 如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况，与缓存击穿的区别是，雪崩是指很多key，在同一时间同时失效，击穿是某个key。 优化： 保证缓存层服务高可用性 依赖隔离组件为后端限流并降级：例如可以使用hystrix 提前演练 将失效时间分散开 10.5 热点key重建优化主要是要减少重建缓存的次数。 互斥锁 永不过期 从缓存层面来看，确实没有设置过期时间 从功能层面来看，为每个value设置一个逻辑过期时间，过期是利用单线程去构建缓存 10.6 缓存击穿 缓存中没有数据但是数据库有，导致去数据库取数据，数据库压力增大，与缓存雪崩的区别是缓存穿透一般指查询同一条数据。 优化方案： 设置热点数据永不过期 设置互斥锁 10.7 小结 前面几种情况都有用到互斥锁，原理是，但key不存在的时候，加锁，再从数据库中查询，并将查询结果加入缓存，然后释放锁。而在这过程中其他进程发现有锁则会等待，这样子防止了大量的请求都往数据库查询了。 十一、哨兵11.1 主要功能 集群监控：负责监控 redis master 和 slave 进程是否正常工作。 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。 十二、集群分布式方案基于客户端分配代理十三、分区分类： 客户端分区 代理分区 查询路由 十四、Redis实现分布式锁 使用SETNX命令 使用redlock 安全特性：互斥访问，即永远只有一个 client 能拿到锁 死锁：最终 client 都可能拿到锁，不会出现死锁的情况 容错性：只要大部分 Redis 节点存活就可以正常提供服务 十五、数据一致性解决方案 问题场景 描述 解决 先写缓存，再写数据库，缓存写成功，数据库写失败 缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读 需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存 先写数据库，再写缓存，数据库写成功，缓存写失败 写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据 缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现 需要缓存异步刷新 指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候 确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔 参考 《Redis开发与运维》 redis面试题","categories":[{"name":"Redis","slug":"Redis","permalink":"wbc.wiki/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"wbc.wiki/tags/Redis/"}]},{"title":"java设计模式总结","slug":"java设计模式总结","date":"2020-03-22T08:32:08.000Z","updated":"2020-03-22T08:35:08.534Z","comments":true,"path":"2020/03/22/java设计模式总结/","link":"","permalink":"wbc.wiki/2020/03/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"设计模式总结 本篇文章不对每一个设计模式进行细讲，只对常见的设计模式展开。 一、分类： 创建型模式：工厂方法模式、抽象工厂模式、单例、建造者、原型模式 结构型模式：适配器、装饰器、代理、外观、桥接、组合、享元模式 行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 二、创建型模式2、1 单例模式分为懒汉式和饿汉模式 饿汉式：在使用前就创建好实例 123456789101112public class Singleton &#123; public static Singleton instance=new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 懒汉式：使用到才创建实例 1234567891011121314151617181920public class Singleton &#123; public static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; // 双重检查锁 synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 2、2 简单工厂模式工厂创建实例，而这些实例都实现了同一个接口，通过传递给不同的参数给工厂，工厂以此来创建不同的实例。例子：实体类：水果 1234567@Datapublic class Fruit &#123; private String name; private String color; &#125; 1234@Datapublic class Apple extends Fruit &#123; &#125; 123@Datapublic class Orange extends Fruit &#123;&#125; 接口类： 123456public interface FruitService &#123; String getFruitName();&#125; 实现类：拿AppleService为例子 12345678public class AppleService implements FruitService &#123; @Override public String getFruitName() &#123; return \"apple\"; &#125;&#125; 工厂类： 12345678910111213141516171819public class SimpleFruitFactory &#123; public FruitService getFruit(String name) &#123; if (\"apple\".equals(name)) &#123; return new AppleService(); &#125; else if (\"orange\".equals(name)) &#123; return new OrangeService(); &#125; else &#123; return null; &#125; &#125; public static void main(String[] args) &#123; SimpleFruitFactory factory = new SimpleFruitFactory(); System.out.println(\"the name is \" + factory.getFruit(\"apple\").getFruitName()); &#125;&#125; 2、3 多工厂模式即一个工厂中提供多个工厂方法 2、4 抽象工厂模式模式创建多个工厂类 2、5 建造者模式通过不同方法来创建复合对象。实例： 12345678910111213141516171819202122232425262728293031323334public class BuilderDemo &#123; public static People builder() &#123; return new People(); &#125; @Data static class People &#123; private String name; private int age; public People setPeopleName(String name) &#123; this.setName(name); return this; &#125; public People setPeopleAge(int age) &#123; this.setAge(age); return this; &#125; public void build() &#123; System.out.println(this.toString()); &#125; &#125; public static void main(String[] args) &#123; BuilderDemo.builder() .setPeopleName(\"小明\") .setPeopleAge(10) .build(); &#125;&#125; 三、结构型模式3、1 适配器模式将类或接口转换为期望的形式表示，已达到兼容的效果。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 类的适配器模式：通过继承目标类，实现扩展的接口类（该类包含目标类相同的方法） 目标类： 1234567public class TargeClass &#123; public void say() &#123; System.out.println(\"hello world\"); &#125; &#125; 实现扩展的接口类 1234567public interface Compatible &#123; void say(); void bye();&#125; 12345678910111213public class ClassAdapter extends TargeClass implements Compatible&#123; @Override public void bye() &#123; System.out.println(\"bye\"); &#125; public static void main(String[] args) &#123; ClassAdapter classAdapter = new ClassAdapter(); classAdapter.say(); classAdapter.bye(); &#125;&#125; 对象的适配器模式适配器类不继承目标类，而是持有目标类对象 12345678910111213141516171819public class WrapperAdapter implements Compatible &#123; private TargeClass targeClass; public WrapperAdapter(TargeClass targeClass) &#123; this.targeClass = targeClass; &#125; @Override public void say() &#123; &#125; @Override public void bye() &#123; &#125;&#125; 接口的适配器模式 一个接口中有多个方法需要实现，但是并不是所有的都是需要的，这时可以借助于一个抽象类， 该抽象类实现了该接口， 实现了所有的方法， 不和原始的接口打交道，只和该抽象类取得联系，所以写一个类，继承该抽象类，重写需要的方法 3、1 装饰模式动态地为对象添加一些新的功能,装饰器持有被装饰类的对象，装饰器和被装饰的类实现相同的接口。例子： 接口 12345public interface Decorable &#123; void doSomethings();&#125; 被装饰的类： 123456public class Target implements Decorable &#123; @Override public void doSomethings() &#123; System.out.println(\"Target doSomethings\"); &#125;&#125; 装饰器： 123456789101112131415161718192021public class Decorator implements Decorable &#123; private Target target; public Decorator(Target target) &#123; super(); this.target = target; &#125; @Override public void doSomethings() &#123; System.out.println(\"before decorate\"); target.doSomethings(); System.out.println(\"after decorate\"); &#125; public static void main(String[] args) &#123; Decorable decorable = new Decorator(new Target()); decorable.doSomethings(); &#125;&#125; 四、行为型模式4、1 策略模式定义多个算法，有外部用户决定使用哪个算法，实现接口方法。 接口类： 1234public interface ICalculator &#123; int calculate(int a, int b);&#125; 实现类： 123456public class Plus implements ICalculator &#123; @Override public int calculate(int a, int b) &#123; return a + b; &#125;&#125; 123456public class Subtraction implements ICalculator &#123; @Override public int calculate(int a, int b) &#123; return a - b; &#125;&#125; 实例测试： 1234567public class StrategyTest &#123; public static void main(String[] args) &#123; ICalculator plus = new Plus(); System.out.println(plus.calculate(1,2)); &#125;&#125; 4、2 观察者模式观察者向主题发起订阅，当主题发生改变时，会通知观察者。 定义观察者接口： 12345public interface Observer &#123; void notifyNotice();&#125; 观察者: 123456public class Observer1 implements Observer &#123; @Override public void notifyNotice() &#123; System.out.println(\"1 had receive notices\"); &#125;&#125; 123456public class Observer2 implements Observer &#123; @Override public void notifyNotice() &#123; System.out.println(\"2 had receive notices\"); &#125;&#125; 主题: 123456789101112131415public class Subject &#123; private List&lt;Observer&gt; observerList = new ArrayList(); public void add(Observer observer) &#123; observerList.add(observer); &#125; public void notifyAllObserver() &#123; for (Observer observer : observerList) &#123; observer.notifyNotice(); &#125; &#125;&#125; 测试： 123456789public class ObserverTest &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); subject.add(new Observer1()); subject.add(new Observer2()); subject.notifyAllObserver(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"wbc.wiki/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"wbc.wiki/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java多线程知识复习(一)","slug":"Java多线程知识复习","date":"2020-03-21T12:40:12.000Z","updated":"2020-03-21T12:42:22.726Z","comments":true,"path":"2020/03/21/Java多线程知识复习/","link":"","permalink":"wbc.wiki/2020/03/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"Java多线程复习总结1、基本概念待补充 2、线程局部变量 ThreadLocal用于实现线程内的数据共享。 使用set方法时会先获取当前线程的ThreadLocalMap 对象，而这个对象的key又是一个ThreadLocal对象。每个线程其实都有一份自己独享的 ThreadLocalMap 对象. 12345678ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; 应用场景; 订单流水 3、Java并发编程库：JUC java.util.concurrent 多线程并发库 java.util.concurrent.atomic 提供原子性操作的工具类包 java.util.concurrent.lock 提供锁机制 3、1 java.util.concurrent 多线程并发库1）执行程序： Executors 线程池工厂类： 减少线程的重复创建。提供线程利用率使用Executors创建线程池的用法： 123456789// 创建固定的线程池ExecutorService fPool = Executors.newFixedThreadPool();//创建缓存大小的线程池ExecutorService cPool = Executors.newCachedThreadPool();//创建单一的线程池ExecutorService sPool = Executors.newSingleThreadExecutor();//创建带有定时调度的线程池Executors.newScheduledThreadPool() ExecutorService 使用： execute(Runnable) ： 无返回值 submit(Runnable)：返回一个 Future 对象 submit(Callable)：返回一个 Future 对象 invokeAny(…)：返回其中一个 Callable 对象的结果 invokeAll(…)：返回一系列的 Future 对象 Executors 关闭 shutdown ：关闭之前提交的任务可以继续执行知道结束 shutdownNow：中断大部分线程 corePoolSize和maximumPoolSize判断线程池是否创建新的线程 ForkJoinPool 合并和分叉（线程池）可以将大任务分割成若干子任务，等到所有子任务完成任务后，将结果合并返回。任务类型： RecursiveAction：没有返回值 RecursiveTask：有返回值，使用join方法获取各个任务的结果，最后使用ForkJoinPool.invoke()获取最终的结果 3、2 阻塞队列特点：入队列：队列已满，阻塞直到有空位；出队列：队列为空，阻塞直到有队列不为空。 场景：一个线程生成、另一个线程消费。 BlockingQueue 的方法： 方法\\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove() poll() take() poll(time,unit) 检查方法 element() peek() 不可用 不可用 队列中元素不能为空 BlockingQueue 的实现类： ArrayBlockingQueue：有界的阻塞队列，底层基于数组实现，存储的元素有上限，一般这个上限初始化时就指定了，后面就无法修改了。 DelayQueue：对元素进行持有直到一个特定的延迟到期。队列中元素必须实现java.util.concurrent.Delayed 接口 LinkedBlockingQueue：以链式结果进行元素的存储，默认上限为：Integer.MAX_VALUE PriorityBlockingQueue： 无界阻塞优先级队列，队列中元素必须实现 java.lang.Comparable 接口。 SynchronousQueue：只能存放单个元素 LinkedBlockingQueue：notFull:表示的等待存放的条件队列notEmpty: 表示等待取出的条件队列 offer方法 ArrayBlockingQueue通过全局锁的方式，同时只能有一个线程进行存放元素到队列或一个线程从队列中获取元素 offer方法 12345678910111213141516 public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;​ 123456789101112该方法首先获取锁，通过其构造方法可以知道，这个锁是非公平锁：&#96;&#96;&#96;java public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;&#x3D; 0) throw new IllegalArgumentException(); this.items &#x3D; new Object[capacity]; lock &#x3D; new ReentrantLock(fair); notEmpty &#x3D; lock.newCondition(); notFull &#x3D; lock.newCondition(); &#125; note: 非公平锁：直接尝试占有锁；公平锁，先判断当前线程是否是第一个线程，是则获取锁，否则添加到等待队列上。 然后调用enqueue方法将元素添加到队列上; 12345678910private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 添加完后，通过 notEmpty.signal() 知非空对队列。 notEmpty和notFull是Condition类型的示例. PriorityBlockingQueue 无界优先级队列内部使用到比较器，用来比较元素大小，由于这是无界队列所以这里没有notFul。默认按元素升序。元素需要实现Comparable接口。 1DEFAULT_INITIAL_CAPACITY = 11 //队列默认大小 为什么是11？ offer 方法 1234567891011121314151617181920212223public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; // 元素个数大于了队列容量，则使用tryGrow进行扩容 while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true; &#125; 这里可以看到扩容时调用了tryGrow方法： 12345678910111213141516171819202122232425262728293031private void tryGrow(Object[] array, int oldCap) &#123; lock.unlock(); // must release and then re-acquire main lock Object[] newArray = null; if (allocationSpinLock == 0 &amp;&amp; UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) &#123; try &#123; // 如果oldCap大于等于64，那么队列新的容量则扩容50% int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : // grow faster if small (oldCap &gt;&gt; 1)); if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123; // possible overflow int minCap = oldCap + 1; if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; &#125; if (newCap &gt; oldCap &amp;&amp; queue == array) newArray = new Object[newCap]; &#125; finally &#123; allocationSpinLock = 0; &#125; &#125; if (newArray == null) // back off if another thread is allocating Thread.yield(); lock.lock(); if (newArray != null &amp;&amp; queue == array) &#123; queue = newArray; System.arraycopy(array, 0, newArray, 0, oldCap); &#125;&#125; note： 为什么是64作为阈值？ 为什么要提前释放锁 扩容的时候可以进行入队列操作，所以是用到CAS，只允许一个线程进行扩容，如果扩容失败了，则通过Thread.yield()让出CPU，让改线程重新获取锁。 12if (newArray &#x3D;&#x3D; null) &#x2F;&#x2F; back off if another thread is allocating Thread.yield(); 复制数组是在获取锁后面才执行的，是为了保证复制的数组是最新的。 排序方法： 123456789101112131415private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; while (k &gt; 0) &#123; // 确定父节点元素位置 int parent = (k - 1) &gt;&gt;&gt; 1; //获取父节点的值 Object e = array[parent]; // 如果插入的值比父节点大，那么完成堆的建立 if (key.compareTo((T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = key;&#125; 例子：假设有三个节点0、1、2，值也是0、1、2。1、2分别是0节点的左右子节点，那么如果插入的k=3,这时先找出他要插入位置的父节点，通过(k-1)&gt;&gt;&gt;1可以得出，parent=1,也就是1节点，这个时候将这个插入的值跟其父节点的值进行比较，如果发现是大于父节点的值，那么完成堆的构建，跳出循环。否则与父节点进行交换， poll方法 该方法通过dequeue方法进行出队列，获取元素。 1234567891011121314151617181920private E dequeue() &#123; int n = size - 1; if (n &lt; 0) return null; else &#123; Object[] array = queue; E result = (E) array[0]; // 获取队列尾部元素，然后将原来的位置的指向设置为空 E x = (E) array[n]; array[n] = null; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) // 把元素插入到下标为0的位置上，然后调整成最小堆 siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n; return result; &#125;&#125; note：最小堆构建过程 take操作 123456789101112public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); E result; try &#123; while ( (result = dequeue()) == null) notEmpty.await(); &#125; finally &#123; lock.unlock(); &#125; return result;&#125; 队列没有元素则一直阻塞 DelayQueue 延时无界阻塞队列DelayQueue = BlockingQueue +PriorityQueue + Delayed 3、3 非阻塞队列消费者出队和生产者入队都不会被阻塞。常用方法跟阻塞队列差不多。 悲观锁和乐观锁悲观锁：认为发送了冲突，那么就会破坏数据的一致性，因此使用独占锁禁止冲突发送。乐观锁：认为即使发送了冲突，也不一定造成损坏 CASCAS(V,A,B)，包含了三个值，内存地址V，旧的预期值A，要修改的新值B。当V的值等于A时，才会将V的值更新为B ConcurrentLinkedQueue 非阻塞无界链表队列采用先进先出的入队原则。采用CAS解决当前节点与下一节点之间的安全性链接和对当前节点的赋值。相关入队和出队方法可以参考《Java并发编程的艺术》P161~P167 ConcurrentHashMap 采用“分段锁”策略,有多个segment组成，segment使用的重入锁，每个segment内部又维护hashentity 。默认下允许16个线程并发（最大并发数为 65536？） 构造方法分析得出的结论： Segment 数组的大小 ssize 是由 concurrentLevel 来决定的，但是却不一定等于concurrentLevel，ssize 一定是大于或等于 concurrentLevel 的最小的 2 的次幂。比如：默认情况下concurrentLevel 是 16，则 ssize 为 16；若 concurrentLevel 为 14，ssize 为 16；若 concurrentLevel 为17， 则 ssize 为 32。 为什么 Segment 的数组大小一定是 2 的次幂？其实主要是便于通过按位与的散列算法来定位 Segment 的 index。 分析见《Java并发编程艺术》P158~P159 note:ssize最大值为65536，segmentShift最大值为16？segmentMask最大值为65535 ConcurrentSkipListMap 非阻塞 Hash 跳表集合与TreeMap类型，都是有序的哈希表，主要区别为： ConcurrentSkipListMap是线程安全，TreeMap非线程安全 ConcurrentSkipListMap通过跳表实现，而TreeMap通过红黑树实现 SkipList跳表： ConcurrentSkipListMap 提供了一种线程安全的并发访问的排序映射表,主要用到了 Node 和 Index 两种节点的存储方式， 通过 volatile 关键字实现了并发的操做 原子包AtomicBoolean 原子性布尔方法： compareAndSet(expectedValue, updateValue)：如果比较的值等于expectedValue，那么原子性的将expectedValue更新为updateValue。 getAndSet(boolean b),返回原来的值，并设置新值为b AtomicIntegerAtomicIntegerArray 原子性整型数组题目实现线程的方式有哪些： 继承Thread 实现Runnable 使用Excutor wait和sleep区别：wait会释放锁，sleep会一直持有锁;wait是所有object都有方法，sleep是线程类所有的。 synchronized 和 volatile作用范围：synchronized: 变量、方法、类 volatile： 变量 作用： synchronized 可能会造成线程的阻塞会被编译器优化。volatile：保证可见性，禁止指令重排序（不会被编译器优化） 线程池作用：减少资源消、提高响应速度、增加线程的管理性。 线程池创建过程： 提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。 当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。 资料参考：面试必备：Java线程池解析 控制线程并发数可以使用信号量Semaphore synchronized 和lock对方法加锁的情况分析：如果使用lock对两个方法都加锁了的，那么同时只能有一个线程访问；如果使用synchronized对两个方法都加锁了的，那么同时可以有两个线程访问，因为它们持有同一把锁； 避免死锁的方法： 按顺序进行加锁：使用join，等待另一个线程执行完才执行自己的线程 加锁时限：线程尝试获取锁的时候加上一定的时限， 超过时限则放弃对该锁的请求， 并释放自己占有的锁。例如使用：lock.tryLock(5000, TimeUnit.MILLISECONDS) 线程间的通信 使用共享变量，加上join做配合 使用wait/notify机制","categories":[{"name":"多线程","slug":"多线程","permalink":"wbc.wiki/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Java，多线程","slug":"Java，多线程","permalink":"wbc.wiki/tags/Java%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java基础复习","slug":"Java基础复习","date":"2020-03-21T12:32:28.000Z","updated":"2020-03-21T12:34:52.197Z","comments":true,"path":"2020/03/21/Java基础复习/","link":"","permalink":"wbc.wiki/2020/03/21/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"Java基础1、基础语法1、1 深拷贝和浅拷贝要区别是深拷贝对于对象的引用类型会创建新的对象引用，而浅拷贝直接指向同一个引用。object的clone方法是浅拷贝。 想要实现深拷贝，对象以及被引用的对象都需要实现Cloneable接口 1、2 equals和hashcode如果equals为true，那么hashcode一定相同，反之hashcode相等，equals不一定为true。 equals特性：自反性、传递性 重写equals方法： 1、参数是否为这个对象的引用、 2、使用 instanceof 操作符检查”参数是否为正确的类型 3、是否满足对称性、传递性、一致性 4、重写 hashCode 1、3 参数传递形式Java参数传递都是值传递。分析参考文章：这一次，彻底解决Java的值传递和引用传递 1、4 重载和重写的区别重载：编译时的多态性，发生在一个类中。规则： 方法名一致，参数列表中参数的顺序，类型，个数不同 重载与方法的返回值无关（因编译器无法只根据返回类型来确定调用哪个方法），存在于父类和子类，同类中 可以抛出不同的异常，可以有不同修饰符 重写：运行时多态，子类重写父类的方法。规则： .参数列表、返回类型与父类一致 构造方法、被final、static修饰的方法不能被重写 访问权限不能比父类的方法小 不能抛出新的强制性异常、更广泛的强制性异常 1、5 接口和抽象类的区别与特点抽象类： 抽象类中可以定义构造器 可以有抽象方法和具体方法 接口中的成员全都是 public 的 抽象类中可以定义成员变量 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法 抽象类中可以包含静态方法（该静态方法不能是抽象的，因为静态方法不能被重写） 一个类只能继承一个抽象类 接口类; 接口中不能定义构造器 方法全部都是抽象方法 抽象类中的成员可以是 private、默认、protected、public 接口中定义的成员变量实际上都是常量 接口中不能有静态方法 一个类可以实现多个接口 1、6 String特性 String是不可变的，如果进行了“+”操作，那么将产生新的对象，指向了新的对象 字符串内容相同，认为是代表同一个对象 每次通过new实例一个字符串，即使字符串内容相同，也会产生新的对象 2、Java异常机制2、1 分类 异常exceptionError 编译时异常：在编译时可以体现出来。用 try…catch 块或抛出该异常进行处理 运行时异常：在运行时发生的异常，常见的有下标越界等 错误Error:一般是指与虚拟机相关的问题 2、2 tr…catch..finally的返回值1234567891011121314public static void main(String[] args) &#123; System.out.println(getNum());&#125;public static int getNum()&#123; try &#123; int a=10/0; return a; &#125;catch (Exception e)&#123; return 2; &#125;finally &#123; return 3; &#125;&#125; 上述打印结果是3，如果try语句块中发生了异常，那么它将进行到catch块进行处理，catch块里是一个return语句，而存在finally，所以会先执行finally里面的语句，finally语句又是一个return语句，那么该方法将会被结束，catch的返回结果不能被真正返回. 2、3 throw 和 throws 的区别throw: 作用在方法体内，向外抛出异常实例throws: 声明在方法后面，由调用者处理，抛出的某种类型的异常，抛出的异常不一定会发生 2、4 final、finally、finalize 的区别？final： 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，被其修饰的类不可继承 finally： 异常处理语句结构的一部分，表示总是执行 finalize： Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法 2、5 StringBuilder 、StringBuffer 的区别StringBuilder：非同步，效率高，多线程下不安全StringBuffer：同步，效率低，线程安全 tips: String的“+”号操作编译为到StringBuilder的append,因此在建议在循环中不要直接使用“+”号进行连接字符串，这样会产生大量的StringBuilder对象。 Java基本数据类型及范围 名称 字节数 范围 byte 1 -128～127 short 2 -32768～32767 int 4 -2147483648～2147483647 long 8 -2^63～2^63-1 flot 4 -3.403E38～3.403E38 double 8 -1.798E308～1.798E308 char 2 表示一个字符 boolean 1 true、false 包装类每个基本类型都有对象的包装类。 note: 如果两个包装类Integer进行比较，如果比较的数值在-128 到 127 之间， 那么不会 new 新的 Integer 对象， 而是直接引用常量池中的 Integer 对象。而Integer和int类型进行比较，将会自动拆箱成两个int类型比较。 3、IO3、1 流的分类：从方向划分：输入流、输出流从功能划分：节点流、处理流从处理数据单位划分：字节流、字符流 3、2 流的基本操作4、集合4、1 ArrayList的实现底层是使用一个Object[]数组实现的。 一、构造方法分析1）空参构造 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 其中private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {} //一个空数组 2）带参构造：指定初始值 12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 3) 带参构造：参数为一个Collection子类 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 二、add方法12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 这里调用了ensureCapacityInternal方法，让我们继续看这个方法; 123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; 计算分配的容量，DEFAULT_CAPACITY这个值为10，通过Math.max方法来取得它们之间的最大值。 123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; note:modCount的作用:用来记录集合的修改次数 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 这个方法的主要作用是复制一个新的数组。首先初始新分配的容量newCapacity为原来的容量+原来容量的一般，当与minCapacity比价时，取最大的。然后再与MAX_ARRAY_SIZE进行比较，这个MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8 ，如果比这个值还要大，将进行下面的判断; 1234567 private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 可见newCapacity的值，最多为Integer.MAX_VALUE 三、remove方法1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 首先检查下标是否越界，获取需要删除的值，用来做返回值，如果要删除的元素不是最后一个元素，那么数组中后面的元素整体往前移动一位。 四、clear方法123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 该方法实现比较简单，仅仅是将所有元素置为空了。 4、2 并发集合ConcurrentHashMap 分析： 与普通的HashMap相比，多了个concurrencyLevel属性，内部使用到了锁分段技术，Segment 数组，默认情况下有16个段。 put操作：该操作运行16个线程并发无阻塞操作集合镀锡，通过计算hash来确定Segment对象，借此对象的put方法来完成操作。 get操作：类似于put操作，也是借用Segment对象的get方法来实现的。由于Segment对象对象的数组HashEntity的数量是用volatile声明的，因此总是能正确的获取到数组的大小。而HashEntity的属性也是final，所以该链表对象不会发生改变。 4、3 HashMap和HashTable两者都实现了Map接口。HashMap： 非线程安全、高效、支持键值对都为null的 HashTable: 线程安全，不支持null值和null键 4、4 SortMap和TreeMap4、5 ArrayList和LinkListArrayList: 访问速度快 插入慢 开销不固定 底层是数组实现 LinkList: 随机访问速度较慢 插入快 底层是双向循环列表","categories":[{"name":"Java","slug":"Java","permalink":"wbc.wiki/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"wbc.wiki/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"zookeeper系列教程之一（Mac下安装zookeeper）","slug":"zookeeper系列教程之一（Mac下安装zookeeper）","date":"2020-02-29T07:09:30.000Z","updated":"2020-03-01T13:09:40.507Z","comments":true,"path":"2020/02/29/zookeeper系列教程之一（Mac下安装zookeeper）/","link":"","permalink":"wbc.wiki/2020/02/29/zookeeper%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E4%B8%80%EF%BC%88Mac%E4%B8%8B%E5%AE%89%E8%A3%85zookeeper%EF%BC%89/","excerpt":"","text":"一、 Mac下zookeeper的安装两种下载方式 第一种直接网上下载 下载地址：https://zookeeper.apache.org/releases.html#download 国内的镜像地址：https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/ 注意如果不需要源码包请下载文件名带bin的那个文件，那个是编译好的，否则运行zookeeper时会出现 错误: 找不到或无法加载主类 org.apache.zookeeper.server.quorum.QuorumPeerMain的问题 第二种使用homebrew下载： brew install zookeeper 二、配置1、配置解释 1234567891011121314151617181920212223242526272829# The number of milliseconds of each ticktickTime&#x3D;2000# The number of ticks that the initial # synchronization phase can takeinitLimit&#x3D;10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit&#x3D;5# the directory where the snapshot is stored.# do not use &#x2F;tmp for storage, &#x2F;tmp here is just # example sakes.dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper# the port at which the clients will connectclientPort&#x3D;2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns&#x3D;60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount&#x3D;3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval&#x3D;1server.1&#x3D;127.0.0.1:2888:3888 tickTime：ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime。 initLimit：Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在initLimit时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property) syncLimit：在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property) dataDir：存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能。 clientPort： 客户端连接server的端口，即对外服务端口，默认是2181。 server.x=[hostname]:nnnnn[:nnnnn]：这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。 2、配置修改 单机模式： 伪集群模式 三、启动与连接 1、服务端启动：进入zookeeper的bin目录，在终端下执行如下命令启动 ./zkServer.sh start 当输出Starting zookeeper … STARTED 时表示成功了 2、客户端连接，同样在bin目录下执行命令 ./zkCli.sh 然后就进入到JLine控制台命令交互模式 欢迎关注公众号 欢迎进入京东小店，领券购物更优惠","categories":[{"name":"分布式","slug":"分布式","permalink":"wbc.wiki/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"wbc.wiki/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"zookeeper","slug":"zookeeper","permalink":"wbc.wiki/tags/zookeeper/"}]}]}