{"meta":{"title":"无编程","subtitle":"wubc的个人博客，公众号：后端随笔","description":"技术、生活、工作","author":"wubc","url":"wubc.me","root":"/"},"pages":[{"title":"无编程 | 404","date":"2020-02-29T07:28:36.278Z","updated":"2020-02-29T07:27:41.983Z","comments":true,"path":"404.html","permalink":"wubc.me/404.html","excerpt":"","text":""},{"title":"无编程 | 404","date":"2020-02-29T07:27:41.983Z","updated":"2020-02-29T07:27:41.983Z","comments":true,"path":"404/404.html","permalink":"wubc.me/404/404.html","excerpt":"","text":""},{"title":"404","date":"2020-02-29T07:02:11.000Z","updated":"2020-02-29T07:02:11.876Z","comments":true,"path":"404/index.html","permalink":"wubc.me/404/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-29T07:32:39.181Z","updated":"2020-02-29T04:37:49.936Z","comments":false,"path":"tags/index.html","permalink":"wubc.me/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-29T04:38:14.568Z","updated":"2020-02-29T04:38:14.560Z","comments":false,"path":"categories/index.html","permalink":"wubc.me/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-03-02T13:45:34.901Z","updated":"2020-02-29T09:03:31.695Z","comments":false,"path":"aboutme/index.html","permalink":"wubc.me/aboutme/index.html","excerpt":"","text":"编程让生活更加美好@card{ 从事Java后端开发，本博客记录本人工作内外所学的知识，或生活思考，偶尔瞎写。内容同步到本人公众号“后端随笔”欢迎关注一波。同步经常在京东购物的朋友们可以京东优惠券先领券再购物，更加优惠哟。 } @timeline{ 2015@item{ 1月1日Android开发 } 2018@item{ 7月1日java后端开发 } 未来@item{ —可期 } }"}],"posts":[{"title":"java设计模式总结","slug":"java设计模式总结","date":"2020-03-22T08:32:08.000Z","updated":"2020-03-22T08:35:08.534Z","comments":true,"path":"2020/03/22/java设计模式总结/","link":"","permalink":"wubc.me/2020/03/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"设计模式总结 本篇文章不对每一个设计模式进行细讲，只对常见的设计模式展开。 一、分类： 创建型模式：工厂方法模式、抽象工厂模式、单例、建造者、原型模式 结构型模式：适配器、装饰器、代理、外观、桥接、组合、享元模式 行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 二、创建型模式2、1 单例模式分为懒汉式和饿汉模式 饿汉式：在使用前就创建好实例 123456789101112public class Singleton &#123; public static Singleton instance=new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 懒汉式：使用到才创建实例 1234567891011121314151617181920public class Singleton &#123; public static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; // 双重检查锁 synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 2、2 简单工厂模式工厂创建实例，而这些实例都实现了同一个接口，通过传递给不同的参数给工厂，工厂以此来创建不同的实例。例子：实体类：水果 1234567@Datapublic class Fruit &#123; private String name; private String color; &#125; 1234@Datapublic class Apple extends Fruit &#123; &#125; 123@Datapublic class Orange extends Fruit &#123;&#125; 接口类： 123456public interface FruitService &#123; String getFruitName();&#125; 实现类：拿AppleService为例子 12345678public class AppleService implements FruitService &#123; @Override public String getFruitName() &#123; return \"apple\"; &#125;&#125; 工厂类： 12345678910111213141516171819public class SimpleFruitFactory &#123; public FruitService getFruit(String name) &#123; if (\"apple\".equals(name)) &#123; return new AppleService(); &#125; else if (\"orange\".equals(name)) &#123; return new OrangeService(); &#125; else &#123; return null; &#125; &#125; public static void main(String[] args) &#123; SimpleFruitFactory factory = new SimpleFruitFactory(); System.out.println(\"the name is \" + factory.getFruit(\"apple\").getFruitName()); &#125;&#125; 2、3 多工厂模式即一个工厂中提供多个工厂方法 2、4 抽象工厂模式模式创建多个工厂类 2、5 建造者模式通过不同方法来创建复合对象。实例： 12345678910111213141516171819202122232425262728293031323334public class BuilderDemo &#123; public static People builder() &#123; return new People(); &#125; @Data static class People &#123; private String name; private int age; public People setPeopleName(String name) &#123; this.setName(name); return this; &#125; public People setPeopleAge(int age) &#123; this.setAge(age); return this; &#125; public void build() &#123; System.out.println(this.toString()); &#125; &#125; public static void main(String[] args) &#123; BuilderDemo.builder() .setPeopleName(\"小明\") .setPeopleAge(10) .build(); &#125;&#125; 三、结构型模式3、1 适配器模式将类或接口转换为期望的形式表示，已达到兼容的效果。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 类的适配器模式：通过继承目标类，实现扩展的接口类（该类包含目标类相同的方法） 目标类： 1234567public class TargeClass &#123; public void say() &#123; System.out.println(\"hello world\"); &#125; &#125; 实现扩展的接口类 1234567public interface Compatible &#123; void say(); void bye();&#125; 12345678910111213public class ClassAdapter extends TargeClass implements Compatible&#123; @Override public void bye() &#123; System.out.println(\"bye\"); &#125; public static void main(String[] args) &#123; ClassAdapter classAdapter = new ClassAdapter(); classAdapter.say(); classAdapter.bye(); &#125;&#125; 对象的适配器模式适配器类不继承目标类，而是持有目标类对象 12345678910111213141516171819public class WrapperAdapter implements Compatible &#123; private TargeClass targeClass; public WrapperAdapter(TargeClass targeClass) &#123; this.targeClass = targeClass; &#125; @Override public void say() &#123; &#125; @Override public void bye() &#123; &#125;&#125; 接口的适配器模式 一个接口中有多个方法需要实现，但是并不是所有的都是需要的，这时可以借助于一个抽象类， 该抽象类实现了该接口， 实现了所有的方法， 不和原始的接口打交道，只和该抽象类取得联系，所以写一个类，继承该抽象类，重写需要的方法 3、1 装饰模式动态地为对象添加一些新的功能,装饰器持有被装饰类的对象，装饰器和被装饰的类实现相同的接口。例子： 接口 12345public interface Decorable &#123; void doSomethings();&#125; 被装饰的类： 123456public class Target implements Decorable &#123; @Override public void doSomethings() &#123; System.out.println(\"Target doSomethings\"); &#125;&#125; 装饰器： 123456789101112131415161718192021public class Decorator implements Decorable &#123; private Target target; public Decorator(Target target) &#123; super(); this.target = target; &#125; @Override public void doSomethings() &#123; System.out.println(\"before decorate\"); target.doSomethings(); System.out.println(\"after decorate\"); &#125; public static void main(String[] args) &#123; Decorable decorable = new Decorator(new Target()); decorable.doSomethings(); &#125;&#125; 四、行为型模式4、1 策略模式定义多个算法，有外部用户决定使用哪个算法，实现接口方法。 接口类： 1234public interface ICalculator &#123; int calculate(int a, int b);&#125; 实现类： 123456public class Plus implements ICalculator &#123; @Override public int calculate(int a, int b) &#123; return a + b; &#125;&#125; 123456public class Subtraction implements ICalculator &#123; @Override public int calculate(int a, int b) &#123; return a - b; &#125;&#125; 实例测试： 1234567public class StrategyTest &#123; public static void main(String[] args) &#123; ICalculator plus = new Plus(); System.out.println(plus.calculate(1,2)); &#125;&#125; 4、2 观察者模式观察者向主题发起订阅，当主题发生改变时，会通知观察者。 定义观察者接口： 12345public interface Observer &#123; void notifyNotice();&#125; 观察者: 123456public class Observer1 implements Observer &#123; @Override public void notifyNotice() &#123; System.out.println(\"1 had receive notices\"); &#125;&#125; 123456public class Observer2 implements Observer &#123; @Override public void notifyNotice() &#123; System.out.println(\"2 had receive notices\"); &#125;&#125; 主题: 123456789101112131415public class Subject &#123; private List&lt;Observer&gt; observerList = new ArrayList(); public void add(Observer observer) &#123; observerList.add(observer); &#125; public void notifyAllObserver() &#123; for (Observer observer : observerList) &#123; observer.notifyNotice(); &#125; &#125;&#125; 测试： 123456789public class ObserverTest &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); subject.add(new Observer1()); subject.add(new Observer2()); subject.notifyAllObserver(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"wubc.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"wubc.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java多线程知识复习(一)","slug":"Java多线程知识复习","date":"2020-03-21T12:40:12.000Z","updated":"2020-03-21T12:42:22.726Z","comments":true,"path":"2020/03/21/Java多线程知识复习/","link":"","permalink":"wubc.me/2020/03/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"Java多线程复习总结1、基本概念待补充 2、线程局部变量 ThreadLocal用于实现线程内的数据共享。 使用set方法时会先获取当前线程的ThreadLocalMap 对象，而这个对象的key又是一个ThreadLocal对象。每个线程其实都有一份自己独享的 ThreadLocalMap 对象. 12345678ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; 应用场景; 订单流水 3、Java并发编程库：JUC java.util.concurrent 多线程并发库 java.util.concurrent.atomic 提供原子性操作的工具类包 java.util.concurrent.lock 提供锁机制 3、1 java.util.concurrent 多线程并发库1）执行程序： Executors 线程池工厂类： 减少线程的重复创建。提供线程利用率使用Executors创建线程池的用法： 123456789// 创建固定的线程池ExecutorService fPool = Executors.newFixedThreadPool();//创建缓存大小的线程池ExecutorService cPool = Executors.newCachedThreadPool();//创建单一的线程池ExecutorService sPool = Executors.newSingleThreadExecutor();//创建带有定时调度的线程池Executors.newScheduledThreadPool() ExecutorService 使用： execute(Runnable) ： 无返回值 submit(Runnable)：返回一个 Future 对象 submit(Callable)：返回一个 Future 对象 invokeAny(…)：返回其中一个 Callable 对象的结果 invokeAll(…)：返回一系列的 Future 对象 Executors 关闭 shutdown ：关闭之前提交的任务可以继续执行知道结束 shutdownNow：中断大部分线程 corePoolSize和maximumPoolSize判断线程池是否创建新的线程 ForkJoinPool 合并和分叉（线程池）可以将大任务分割成若干子任务，等到所有子任务完成任务后，将结果合并返回。任务类型： RecursiveAction：没有返回值 RecursiveTask：有返回值，使用join方法获取各个任务的结果，最后使用ForkJoinPool.invoke()获取最终的结果 3、2 阻塞队列特点：入队列：队列已满，阻塞直到有空位；出队列：队列为空，阻塞直到有队列不为空。 场景：一个线程生成、另一个线程消费。 BlockingQueue 的方法： 方法\\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove() poll() take() poll(time,unit) 检查方法 element() peek() 不可用 不可用 队列中元素不能为空 BlockingQueue 的实现类： ArrayBlockingQueue：有界的阻塞队列，底层基于数组实现，存储的元素有上限，一般这个上限初始化时就指定了，后面就无法修改了。 DelayQueue：对元素进行持有直到一个特定的延迟到期。队列中元素必须实现java.util.concurrent.Delayed 接口 LinkedBlockingQueue：以链式结果进行元素的存储，默认上限为：Integer.MAX_VALUE PriorityBlockingQueue： 无界阻塞优先级队列，队列中元素必须实现 java.lang.Comparable 接口。 SynchronousQueue：只能存放单个元素 LinkedBlockingQueue：notFull:表示的等待存放的条件队列notEmpty: 表示等待取出的条件队列 offer方法 ArrayBlockingQueue通过全局锁的方式，同时只能有一个线程进行存放元素到队列或一个线程从队列中获取元素 offer方法 12345678910111213141516 public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;​ 123456789101112该方法首先获取锁，通过其构造方法可以知道，这个锁是非公平锁：&#96;&#96;&#96;java public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;&#x3D; 0) throw new IllegalArgumentException(); this.items &#x3D; new Object[capacity]; lock &#x3D; new ReentrantLock(fair); notEmpty &#x3D; lock.newCondition(); notFull &#x3D; lock.newCondition(); &#125; note: 非公平锁：直接尝试占有锁；公平锁，先判断当前线程是否是第一个线程，是则获取锁，否则添加到等待队列上。 然后调用enqueue方法将元素添加到队列上; 12345678910private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 添加完后，通过 notEmpty.signal() 知非空对队列。 notEmpty和notFull是Condition类型的示例. PriorityBlockingQueue 无界优先级队列内部使用到比较器，用来比较元素大小，由于这是无界队列所以这里没有notFul。默认按元素升序。元素需要实现Comparable接口。 1DEFAULT_INITIAL_CAPACITY = 11 //队列默认大小 为什么是11？ offer 方法 1234567891011121314151617181920212223public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; // 元素个数大于了队列容量，则使用tryGrow进行扩容 while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true; &#125; 这里可以看到扩容时调用了tryGrow方法： 12345678910111213141516171819202122232425262728293031private void tryGrow(Object[] array, int oldCap) &#123; lock.unlock(); // must release and then re-acquire main lock Object[] newArray = null; if (allocationSpinLock == 0 &amp;&amp; UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) &#123; try &#123; // 如果oldCap大于等于64，那么队列新的容量则扩容50% int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : // grow faster if small (oldCap &gt;&gt; 1)); if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123; // possible overflow int minCap = oldCap + 1; if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; &#125; if (newCap &gt; oldCap &amp;&amp; queue == array) newArray = new Object[newCap]; &#125; finally &#123; allocationSpinLock = 0; &#125; &#125; if (newArray == null) // back off if another thread is allocating Thread.yield(); lock.lock(); if (newArray != null &amp;&amp; queue == array) &#123; queue = newArray; System.arraycopy(array, 0, newArray, 0, oldCap); &#125;&#125; note： 为什么是64作为阈值？ 为什么要提前释放锁 扩容的时候可以进行入队列操作，所以是用到CAS，只允许一个线程进行扩容，如果扩容失败了，则通过Thread.yield()让出CPU，让改线程重新获取锁。 12if (newArray &#x3D;&#x3D; null) &#x2F;&#x2F; back off if another thread is allocating Thread.yield(); 复制数组是在获取锁后面才执行的，是为了保证复制的数组是最新的。 排序方法： 123456789101112131415private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; while (k &gt; 0) &#123; // 确定父节点元素位置 int parent = (k - 1) &gt;&gt;&gt; 1; //获取父节点的值 Object e = array[parent]; // 如果插入的值比父节点大，那么完成堆的建立 if (key.compareTo((T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = key;&#125; 例子：假设有三个节点0、1、2，值也是0、1、2。1、2分别是0节点的左右子节点，那么如果插入的k=3,这时先找出他要插入位置的父节点，通过(k-1)&gt;&gt;&gt;1可以得出，parent=1,也就是1节点，这个时候将这个插入的值跟其父节点的值进行比较，如果发现是大于父节点的值，那么完成堆的构建，跳出循环。否则与父节点进行交换， poll方法 该方法通过dequeue方法进行出队列，获取元素。 1234567891011121314151617181920private E dequeue() &#123; int n = size - 1; if (n &lt; 0) return null; else &#123; Object[] array = queue; E result = (E) array[0]; // 获取队列尾部元素，然后将原来的位置的指向设置为空 E x = (E) array[n]; array[n] = null; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) // 把元素插入到下标为0的位置上，然后调整成最小堆 siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n; return result; &#125;&#125; note：最小堆构建过程 take操作 123456789101112public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); E result; try &#123; while ( (result = dequeue()) == null) notEmpty.await(); &#125; finally &#123; lock.unlock(); &#125; return result;&#125; 队列没有元素则一直阻塞 DelayQueue 延时无界阻塞队列DelayQueue = BlockingQueue +PriorityQueue + Delayed 3、3 非阻塞队列消费者出队和生产者入队都不会被阻塞。常用方法跟阻塞队列差不多。 悲观锁和乐观锁悲观锁：认为发送了冲突，那么就会破坏数据的一致性，因此使用独占锁禁止冲突发送。乐观锁：认为即使发送了冲突，也不一定造成损坏 CASCAS(V,A,B)，包含了三个值，内存地址V，旧的预期值A，要修改的新值B。当V的值等于A时，才会将V的值更新为B ConcurrentLinkedQueue 非阻塞无界链表队列采用先进先出的入队原则。采用CAS解决当前节点与下一节点之间的安全性链接和对当前节点的赋值。相关入队和出队方法可以参考《Java并发编程的艺术》P161~P167 ConcurrentHashMap 采用“分段锁”策略,有多个segment组成，segment使用的重入锁，每个segment内部又维护hashentity 。默认下允许16个线程并发（最大并发数为 65536？） 构造方法分析得出的结论： Segment 数组的大小 ssize 是由 concurrentLevel 来决定的，但是却不一定等于concurrentLevel，ssize 一定是大于或等于 concurrentLevel 的最小的 2 的次幂。比如：默认情况下concurrentLevel 是 16，则 ssize 为 16；若 concurrentLevel 为 14，ssize 为 16；若 concurrentLevel 为17， 则 ssize 为 32。 为什么 Segment 的数组大小一定是 2 的次幂？其实主要是便于通过按位与的散列算法来定位 Segment 的 index。 分析见《Java并发编程艺术》P158~P159 note:ssize最大值为65536，segmentShift最大值为16？segmentMask最大值为65535 ConcurrentSkipListMap 非阻塞 Hash 跳表集合与TreeMap类型，都是有序的哈希表，主要区别为： ConcurrentSkipListMap是线程安全，TreeMap非线程安全 ConcurrentSkipListMap通过跳表实现，而TreeMap通过红黑树实现 SkipList跳表： ConcurrentSkipListMap 提供了一种线程安全的并发访问的排序映射表,主要用到了 Node 和 Index 两种节点的存储方式， 通过 volatile 关键字实现了并发的操做 原子包AtomicBoolean 原子性布尔方法： compareAndSet(expectedValue, updateValue)：如果比较的值等于expectedValue，那么原子性的将expectedValue更新为updateValue。 getAndSet(boolean b),返回原来的值，并设置新值为b AtomicIntegerAtomicIntegerArray 原子性整型数组题目实现线程的方式有哪些： 继承Thread 实现Runnable 使用Excutor wait和sleep区别：wait会释放锁，sleep会一直持有锁;wait是所有object都有方法，sleep是线程类所有的。 synchronized 和 volatile作用范围：synchronized: 变量、方法、类 volatile： 变量 作用： synchronized 可能会造成线程的阻塞会被编译器优化。volatile：保证可见性，禁止指令重排序（不会被编译器优化） 线程池作用：减少资源消、提高响应速度、增加线程的管理性。 线程池创建过程： 提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。 当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。 资料参考：面试必备：Java线程池解析 控制线程并发数可以使用信号量Semaphore synchronized 和lock对方法加锁的情况分析：如果使用lock对两个方法都加锁了的，那么同时只能有一个线程访问；如果使用synchronized对两个方法都加锁了的，那么同时可以有两个线程访问，因为它们持有同一把锁； 避免死锁的方法： 按顺序进行加锁：使用join，等待另一个线程执行完才执行自己的线程 加锁时限：线程尝试获取锁的时候加上一定的时限， 超过时限则放弃对该锁的请求， 并释放自己占有的锁。例如使用：lock.tryLock(5000, TimeUnit.MILLISECONDS) 线程间的通信 使用共享变量，加上join做配合 使用wait/notify机制","categories":[{"name":"多线程","slug":"多线程","permalink":"wubc.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Java，多线程","slug":"Java，多线程","permalink":"wubc.me/tags/Java%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java基础复习","slug":"Java基础复习","date":"2020-03-21T12:32:28.000Z","updated":"2020-03-21T12:34:52.197Z","comments":true,"path":"2020/03/21/Java基础复习/","link":"","permalink":"wubc.me/2020/03/21/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"Java基础1、基础语法1、1 深拷贝和浅拷贝要区别是深拷贝对于对象的引用类型会创建新的对象引用，而浅拷贝直接指向同一个引用。object的clone方法是浅拷贝。 想要实现深拷贝，对象以及被引用的对象都需要实现Cloneable接口 1、2 equals和hashcode如果equals为true，那么hashcode一定相同，反之hashcode相等，equals不一定为true。 equals特性：自反性、传递性 重写equals方法： 1、参数是否为这个对象的引用、 2、使用 instanceof 操作符检查”参数是否为正确的类型 3、是否满足对称性、传递性、一致性 4、重写 hashCode 1、3 参数传递形式Java参数传递都是值传递。分析参考文章：这一次，彻底解决Java的值传递和引用传递 1、4 重载和重写的区别重载：编译时的多态性，发生在一个类中。规则： 方法名一致，参数列表中参数的顺序，类型，个数不同 重载与方法的返回值无关（因编译器无法只根据返回类型来确定调用哪个方法），存在于父类和子类，同类中 可以抛出不同的异常，可以有不同修饰符 重写：运行时多态，子类重写父类的方法。规则： .参数列表、返回类型与父类一致 构造方法、被final、static修饰的方法不能被重写 访问权限不能比父类的方法小 不能抛出新的强制性异常、更广泛的强制性异常 1、5 接口和抽象类的区别与特点抽象类： 抽象类中可以定义构造器 可以有抽象方法和具体方法 接口中的成员全都是 public 的 抽象类中可以定义成员变量 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法 抽象类中可以包含静态方法（该静态方法不能是抽象的，因为静态方法不能被重写） 一个类只能继承一个抽象类 接口类; 接口中不能定义构造器 方法全部都是抽象方法 抽象类中的成员可以是 private、默认、protected、public 接口中定义的成员变量实际上都是常量 接口中不能有静态方法 一个类可以实现多个接口 1、6 String特性 String是不可变的，如果进行了“+”操作，那么将产生新的对象，指向了新的对象 字符串内容相同，认为是代表同一个对象 每次通过new实例一个字符串，即使字符串内容相同，也会产生新的对象 2、Java异常机制2、1 分类 异常exceptionError 编译时异常：在编译时可以体现出来。用 try…catch 块或抛出该异常进行处理 运行时异常：在运行时发生的异常，常见的有下标越界等 错误Error:一般是指与虚拟机相关的问题 2、2 tr…catch..finally的返回值1234567891011121314public static void main(String[] args) &#123; System.out.println(getNum());&#125;public static int getNum()&#123; try &#123; int a=10/0; return a; &#125;catch (Exception e)&#123; return 2; &#125;finally &#123; return 3; &#125;&#125; 上述打印结果是3，如果try语句块中发生了异常，那么它将进行到catch块进行处理，catch块里是一个return语句，而存在finally，所以会先执行finally里面的语句，finally语句又是一个return语句，那么该方法将会被结束，catch的返回结果不能被真正返回. 2、3 throw 和 throws 的区别throw: 作用在方法体内，向外抛出异常实例throws: 声明在方法后面，由调用者处理，抛出的某种类型的异常，抛出的异常不一定会发生 2、4 final、finally、finalize 的区别？final： 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，被其修饰的类不可继承 finally： 异常处理语句结构的一部分，表示总是执行 finalize： Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法 2、5 StringBuilder 、StringBuffer 的区别StringBuilder：非同步，效率高，多线程下不安全StringBuffer：同步，效率低，线程安全 tips: String的“+”号操作编译为到StringBuilder的append,因此在建议在循环中不要直接使用“+”号进行连接字符串，这样会产生大量的StringBuilder对象。 Java基本数据类型及范围 名称 字节数 范围 byte 1 -128～127 short 2 -32768～32767 int 4 -2147483648～2147483647 long 8 -2^63～2^63-1 flot 4 -3.403E38～3.403E38 double 8 -1.798E308～1.798E308 char 2 表示一个字符 boolean 1 true、false 包装类每个基本类型都有对象的包装类。 note: 如果两个包装类Integer进行比较，如果比较的数值在-128 到 127 之间， 那么不会 new 新的 Integer 对象， 而是直接引用常量池中的 Integer 对象。而Integer和int类型进行比较，将会自动拆箱成两个int类型比较。 3、IO3、1 流的分类：从方向划分：输入流、输出流从功能划分：节点流、处理流从处理数据单位划分：字节流、字符流 3、2 流的基本操作4、集合4、1 ArrayList的实现底层是使用一个Object[]数组实现的。 一、构造方法分析1）空参构造 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 其中private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {} //一个空数组 2）带参构造：指定初始值 12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 3) 带参构造：参数为一个Collection子类 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 二、add方法12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 这里调用了ensureCapacityInternal方法，让我们继续看这个方法; 123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; 计算分配的容量，DEFAULT_CAPACITY这个值为10，通过Math.max方法来取得它们之间的最大值。 123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; note:modCount的作用:用来记录集合的修改次数 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 这个方法的主要作用是复制一个新的数组。首先初始新分配的容量newCapacity为原来的容量+原来容量的一般，当与minCapacity比价时，取最大的。然后再与MAX_ARRAY_SIZE进行比较，这个MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8 ，如果比这个值还要大，将进行下面的判断; 1234567 private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 可见newCapacity的值，最多为Integer.MAX_VALUE 三、remove方法1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 首先检查下标是否越界，获取需要删除的值，用来做返回值，如果要删除的元素不是最后一个元素，那么数组中后面的元素整体往前移动一位。 四、clear方法123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 该方法实现比较简单，仅仅是将所有元素置为空了。 4、2 并发集合ConcurrentHashMap 分析： 与普通的HashMap相比，多了个concurrencyLevel属性，内部使用到了锁分段技术，Segment 数组，默认情况下有16个段。 put操作：该操作运行16个线程并发无阻塞操作集合镀锡，通过计算hash来确定Segment对象，借此对象的put方法来完成操作。 get操作：类似于put操作，也是借用Segment对象的get方法来实现的。由于Segment对象对象的数组HashEntity的数量是用volatile声明的，因此总是能正确的获取到数组的大小。而HashEntity的属性也是final，所以该链表对象不会发生改变。 4、3 HashMap和HashTable两者都实现了Map接口。HashMap： 非线程安全、高效、支持键值对都为null的 HashTable: 线程安全，不支持null值和null键 4、4 SortMap和TreeMap4、5 ArrayList和LinkListArrayList: 访问速度快 插入慢 开销不固定 底层是数组实现 LinkList: 随机访问速度较慢 插入快 底层是双向循环列表","categories":[{"name":"Java","slug":"Java","permalink":"wubc.me/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"wubc.me/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"zookeeper系列教程之一（Mac下安装zookeeper）","slug":"zookeeper系列教程之一（Mac下安装zookeeper）","date":"2020-02-29T07:09:30.000Z","updated":"2020-03-01T13:09:40.507Z","comments":true,"path":"2020/02/29/zookeeper系列教程之一（Mac下安装zookeeper）/","link":"","permalink":"wubc.me/2020/02/29/zookeeper%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E4%B8%80%EF%BC%88Mac%E4%B8%8B%E5%AE%89%E8%A3%85zookeeper%EF%BC%89/","excerpt":"","text":"一、 Mac下zookeeper的安装两种下载方式 第一种直接网上下载 下载地址：https://zookeeper.apache.org/releases.html#download 国内的镜像地址：https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/ 注意如果不需要源码包请下载文件名带bin的那个文件，那个是编译好的，否则运行zookeeper时会出现 错误: 找不到或无法加载主类 org.apache.zookeeper.server.quorum.QuorumPeerMain的问题 第二种使用homebrew下载： brew install zookeeper 二、配置1、配置解释 1234567891011121314151617181920212223242526272829# The number of milliseconds of each ticktickTime&#x3D;2000# The number of ticks that the initial # synchronization phase can takeinitLimit&#x3D;10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit&#x3D;5# the directory where the snapshot is stored.# do not use &#x2F;tmp for storage, &#x2F;tmp here is just # example sakes.dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper# the port at which the clients will connectclientPort&#x3D;2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns&#x3D;60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount&#x3D;3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval&#x3D;1server.1&#x3D;127.0.0.1:2888:3888 tickTime：ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime。 initLimit：Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在initLimit时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property) syncLimit：在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property) dataDir：存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能。 clientPort： 客户端连接server的端口，即对外服务端口，默认是2181。 server.x=[hostname]:nnnnn[:nnnnn]：这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。 2、配置修改 单机模式： 伪集群模式 三、启动与连接 1、服务端启动：进入zookeeper的bin目录，在终端下执行如下命令启动 ./zkServer.sh start 当输出Starting zookeeper … STARTED 时表示成功了 2、客户端连接，同样在bin目录下执行命令 ./zkCli.sh 然后就进入到JLine控制台命令交互模式 欢迎关注公众号 欢迎进入京东小店，领券购物更优惠","categories":[{"name":"分布式","slug":"分布式","permalink":"wubc.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"wubc.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"zookeeper","slug":"zookeeper","permalink":"wubc.me/tags/zookeeper/"}]}]}