{"meta":{"title":"无编程","subtitle":"wubc的个人博客，公众号：后端随笔","description":"技术、生活、工作","author":"wubc","url":"wubc.me","root":"/"},"pages":[{"title":"无编程 | 404","date":"2020-02-29T07:28:36.278Z","updated":"2020-02-29T07:27:41.983Z","comments":true,"path":"404.html","permalink":"wubc.me/404.html","excerpt":"","text":""},{"title":"无编程 | 404","date":"2020-02-29T07:27:41.983Z","updated":"2020-02-29T07:27:41.983Z","comments":true,"path":"404/404.html","permalink":"wubc.me/404/404.html","excerpt":"","text":""},{"title":"404","date":"2020-02-29T07:02:11.000Z","updated":"2020-02-29T07:02:11.876Z","comments":true,"path":"404/index.html","permalink":"wubc.me/404/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-03-02T13:45:34.901Z","updated":"2020-02-29T09:03:31.695Z","comments":false,"path":"aboutme/index.html","permalink":"wubc.me/aboutme/index.html","excerpt":"","text":"编程让生活更加美好@card{ 从事Java后端开发，本博客记录本人工作内外所学的知识，或生活思考，偶尔瞎写。内容同步到本人公众号“后端随笔”欢迎关注一波。同步经常在京东购物的朋友们可以京东优惠券先领券再购物，更加优惠哟。 } @timeline{ 2015@item{ 1月1日Android开发 } 2018@item{ 7月1日java后端开发 } 未来@item{ —可期 } }"},{"title":"","date":"2020-02-29T04:38:14.568Z","updated":"2020-02-29T04:38:14.560Z","comments":false,"path":"categories/index.html","permalink":"wubc.me/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-06T09:08:48.631Z","updated":"2020-04-06T08:36:41.804Z","comments":true,"path":"data/butterfly.json","permalink":"wubc.me/data/butterfly.json","excerpt":"","text":"{\"menu\":{\"Home\":\"/ || fa fa-home\",\"Archives\":\"/archives/ || fa fa-archive\",\"Tags\":\"/tags/ || fa fa-tags\",\"Categories\":\"/categories/ || fa fa-folder-open\",\"Link\":\"/link/ || fa fa-link\",\"About\":\"/about/ || fa fa-heart\",\"List||fa fa-list\":[\"Music || /music/ || fa fa-music\",\"Movie || /movies/ || fa fa-film\"]},\"favicon\":\"/img/favicon.ico\",\"highlight_theme\":\"light\",\"highlight_copy\":true,\"highlight_lang\":true,\"highlight_shrink\":false,\"code_word_wrap\":false,\"copy\":{\"enable\":true,\"copyright\":false},\"social\":{\"fa fa-github\":\"https://github.com/jerryc127\",\"fa fa-envelope\":\"mailto:xxxxxxxx@gmail.com\",\"fa fa-rss\":\"/atom.xml\"},\"algolia_search\":{\"enable\":false,\"hits\":{\"per_page\":6},\"labels\":{\"input_placeholder\":\"Search for Posts\",\"hits_empty\":\"We didn't find any results for the search: ${query}\",\"hits_stats\":\"${hits} results found in ${time} ms\"}},\"local_search\":{\"enable\":false,\"labels\":{\"input_placeholder\":\"Search for Posts\",\"hits_empty\":\"We didn't find any results for the search: ${query}\"}},\"mathjax\":{\"enable\":false,\"per_page\":false},\"katex\":{\"enable\":false,\"per_page\":false,\"hide_scrollbar\":true},\"mermaid\":{\"enable\":false,\"theme\":\"default\"},\"avatar\":{\"img\":\"/img/avatar.png\",\"effect\":false},\"index_img\":null,\"default_top_img\":\"/img/index.jpg\",\"archive_img\":null,\"tag_img\":null,\"category_img\":null,\"cover\":{\"index_enable\":true,\"aside_enable\":true,\"archives_enable\":true,\"position\":\"both\",\"default_cover\":[\"/img/post.jpg\"]},\"lodding_bg\":{\"flink\":\"/img/friend_404.gif\",\"post_page\":\"/img/404.jpg\"},\"error_404\":{\"enable\":false,\"subtitle\":\"Page Not Found\",\"background\":null},\"post_meta\":{\"page\":{\"date_type\":\"created\",\"categories\":true,\"tags\":false},\"post\":{\"date_type\":\"both\",\"categories\":true,\"tags\":true}},\"wordcount\":{\"enable\":false},\"toc\":{\"enable\":true,\"number\":true},\"auto_open_sidebar\":{\"enable\":true},\"post_copyright\":{\"enable\":true,\"decode\":false,\"license\":\"CC BY-NC-SA 4.0\",\"license_url\":\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"},\"auto_excerpt\":{\"enable\":true,\"length\":150},\"addThis\":{\"enable\":false,\"pubid\":null},\"sharejs\":{\"enable\":true,\"sites\":\"facebook,twitter,wechat,weibo,qq\"},\"addtoany\":{\"enable\":false,\"item\":[\"facebook\",\"twitter\",\"wechat\",\"sina_weibo\",\"facebook_messenger\",\"email\",\"copy_link\"]},\"disqus\":{\"enable\":false,\"shortname\":null,\"count\":false},\"disqusjs\":{\"enable\":false,\"shortname\":null,\"siteName\":null,\"apikey\":null,\"api\":\"https://disqus.skk.moe/disqus/\",\"admin\":null,\"adminLabel\":null,\"count\":true},\"laibili\":{\"enable\":false,\"uid\":null},\"gitalk\":{\"enable\":false,\"client_id\":null,\"client_secret\":null,\"repo\":null,\"owner\":null,\"admin\":null,\"language\":\"zh-CN\",\"perPage\":10,\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"createIssueManually\":false,\"count\":true},\"valine\":{\"enable\":false,\"appId\":null,\"appKey\":null,\"notify\":false,\"verify\":false,\"pageSize\":10,\"avatar\":\"monsterid\",\"lang\":\"en\",\"placeholder\":\"Please leave your footprints\",\"guest_info\":\"nick,mail,link\",\"recordIP\":false,\"serverURLs\":null,\"bg\":\"/img/comment_bg.png\",\"count\":true},\"utterances\":{\"enable\":false,\"repo\":null,\"issue_term\":\"pathname\",\"light_theme\":\"github-light\",\"dark_theme\":\"photon-dark\"},\"since\":2020,\"footer_custom_text\":null,\"footer_copyright\":{\"enable\":true},\"ICP\":{\"enable\":false,\"url\":null,\"text\":null,\"icon\":\"/img/icp.png\"},\"baidu_analytics\":null,\"google_analytics\":null,\"tencent_analytics\":null,\"google_adsense\":{\"enable\":false,\"js\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\",\"client\":null,\"enable_page_level_ads\":true},\"google_site_verification\":null,\"bing_site_verification\":null,\"baidu_site_verification\":null,\"qihu_site_verification\":null,\"reward\":{\"enable\":true,\"QR_code\":[{\"itemlist\":{\"img\":\"/img/wechat.jpg\",\"text\":\"微信\"}},{\"itemlist\":{\"img\":\"/img/alipay.jpg\",\"text\":\"支付寶\"}}]},\"related_post\":{\"enable\":true,\"limit\":6,\"date_type\":\"created\"},\"index_site_info_top\":null,\"index_top_img_height\":null,\"category_ui\":null,\"tag_ui\":null,\"background\":null,\"footer_bg\":false,\"canvas_ribbon\":{\"enable\":false,\"size\":150,\"alpha\":0.6,\"zIndex\":-1,\"click_to_change\":false,\"mobile\":false},\"canvas_ribbon_piao\":{\"enable\":false,\"mobile\":false},\"canvas_nest\":{\"enable\":false,\"color\":\"0,0,255\",\"opacity\":0.7,\"zIndex\":-1,\"count\":99,\"mobile\":false},\"activate_power_mode\":{\"enable\":false,\"colorful\":true,\"shake\":true},\"fireworks\":{\"enable\":false},\"click_heart\":{\"enable\":false},\"ClickShowText\":{\"enable\":false,\"text\":[\"本人\",\"超帥\"],\"fontSize\":\"15px\"},\"display_mode\":\"light\",\"beautify\":{\"enable\":false,\"title-prefix-icon\":\"\\\\f0c1\",\"title-prefix-icon-color\":\"#F47466\"},\"font\":{\"enable\":false,\"font-family\":\"Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, MicrMicrosoft YaHei\\\", Helvetica Neue, Helvetica, Arial, sans-serif\",\"code-font\":\"consolas, Menlo, \\\"PingFang SC\\\", \\\"Microsoft YaHei\\\", monospace, Helvetica Neue For Number\"},\"blog_title_font\":{\"font_link\":\"https://fonts.googleapis.com/css?family=Titillium+Web\",\"font-family\":\"Titillium Web, PingFang SC, Hiragino Sans GB, \\\"Microsoft YaHei\\\", Helvetica Neue, Helvetica, Arial, sans-serif\"},\"hr\":{\"enable\":false,\"icon\":\"\\\\f21c\",\"icon-top\":\"-20px\"},\"subtitle\":{\"enable\":true,\"effect\":true,\"loop\":false,\"source\":false,\"sub\":[\"今日事&#44;今日畢\",\"Never put off till tomorrow what you can do today\"]},\"fontawesome_v5\":{\"enable\":false},\"aside\":{\"enable\":true,\"mobile\":true,\"position\":\"right\",\"card_author\":true,\"card_announcement\":true,\"card_recent_post\":true,\"card_categories\":true,\"card_tags\":true,\"card_archives\":true,\"card_webinfo\":true},\"announcement\":{\"content\":\"感謝訪問本站，若喜歡請收藏 ^_^\"},\"busuanzi\":{\"site_uv\":true,\"site_pv\":true,\"page_pv\":true},\"runtimeshow\":{\"enable\":true,\"start_date\":\"6/7/2018 00:00:00\"},\"translate\":{\"enable\":true,\"default\":\"繁\",\"defaultEncoding\":2,\"translateDelay\":0,\"cookieDomain\":\"https://xxx/\",\"msgToTraditionalChinese\":\"繁\",\"msgToSimplifiedChinese\":\"簡\"},\"readmode\":{\"enable\":true},\"darkmode\":{\"enable\":true,\"button\":true,\"autoChangeMode\":1},\"medium_zoom\":{\"enable\":false},\"fancybox\":{\"enable\":true},\"snackbar\":{\"enable\":false,\"position\":\"bottom-left\",\"bg_light\":\"#49b1f5\",\"bg_dark\":\"#2d3035\"},\"baidu_push\":{\"enable\":false},\"instantpage\":{\"enable\":true},\"pangu\":{\"enable\":false,\"field\":\"page\"},\"note\":{\"style\":\"flat\",\"icons\":true,\"border_radius\":3,\"light_bg_offset\":0},\"lazyload\":{\"enable\":true},\"canonical\":true,\"disable_baidu_transformation\":true,\"twitter_meta\":true,\"Open_Graph_meta\":true,\"fragment_cache\":true,\"CDN_USE\":{\"css\":[\"/css/index.css\"],\"js\":[\"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js\",\"/js/utils.js\",\"/js/main.js\"]},\"CDN\":{\"blueimp_md5\":\"https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js\",\"gitalk\":\"https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js\",\"gitalk_css\":\"https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css\",\"valine\":\"https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js\",\"disqusjs\":\"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqus.js\",\"disqusjs_css\":\"https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css\",\"utterances\":\"https://utteranc.es/client.js\",\"addtoany\":\"https://static.addtoany.com/menu/page.js\",\"sharejs\":\"https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js\",\"sharejs_css\":\"https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css\",\"local_search\":\"/js/search/local-search.js\",\"algolia_js\":\"/js/search/algolia.js\",\"algolia_search\":\"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js\",\"algolia_search_css\":\"https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css\",\"mathjax\":\"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML\",\"katex\":\"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css\",\"katex_copytex\":\"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js\",\"katex_copytex_css\":\"https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css\",\"mermaid\":\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\",\"busuanzi\":\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\",\"canvas_ribbon\":\"/js/third-party/canvas-ribbon.js\",\"canvas_ribbon_piao\":\"/js/third-party/piao.js\",\"canvas_nest\":\"/js/third-party/canvas-nest.js\",\"lazyload\":\"https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js\",\"instantpage\":\"https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js\",\"typed\":\"https://cdn.jsdelivr.net/npm/typed.js\",\"js_cookies\":\"https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js\",\"pangu\":\"https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js\",\"fancybox_css\":\"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css\",\"fancybox\":\"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js\",\"medium_zoom\":\"https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js\",\"snackbar_css\":\"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css\",\"snackbar\":\"https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js\",\"anime\":\"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js\",\"activate_power_mode\":\"/js/third-party/activate-power-mode.js\",\"fireworks\":\"/js/third-party/fireworks.js\",\"click_heart\":\"/js/third-party/click_heart.js\",\"ClickShowText\":\"/js/third-party/ClickShowText.js\",\"fontawesome_v4\":\"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css\",\"fontawesome_v5\":\"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css\",\"translate\":\"/js/tw_cn.js\"}}"},{"title":"","date":"2020-02-29T07:32:39.181Z","updated":"2020-02-29T04:37:49.936Z","comments":false,"path":"tags/index.html","permalink":"wubc.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Zookeeper选举算法分析: 以FastLeader为例","slug":"Zookeeper选举算法分析-以FastLeader为例","date":"2020-04-28T13:35:04.000Z","updated":"2020-04-28T13:36:01.780Z","comments":true,"path":"2020/04/28/Zookeeper选举算法分析-以FastLeader为例/","link":"","permalink":"wubc.me/2020/04/28/Zookeeper%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-%E4%BB%A5FastLeader%E4%B8%BA%E4%BE%8B/","excerpt":"","text":"Zookeeper选举算法分析: 以FastLeader为例选举算法源码入口: org.apache.zookeeper.server.quorum.QuorumPeerMain#initializeAndRun 12345678910111213141516171819202122232425262728 protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServerException &#123; QuorumPeerConfig config = new QuorumPeerConfig(); if (args.length == 1) &#123; config.parse(args[0]); &#125; // Start and schedule the the purge task DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config .getDataDir(), config.getDataLogDir(), config .getSnapRetainCount(), config.getPurgeInterval()); purgeMgr.start(); // 判断是单机还是集群模式 if (args.length == 1 &amp;&amp; config.isDistributed()) &#123; runFromConfig(config); &#125; else &#123; LOG.warn(\"Either no config or no quorum defined in config, running \" + \" in standalone mode\"); // there is only server in the quorum -- run as standalone ZooKeeperServerMain.main(args); &#125; &#125;``` 首先判断一下如果是集群模式的话，则会调用 **org.apache.zookeeper.server.quorum.QuorumPeerMain#runFromConfig**方法这个方法主要是读取配置文件信息对**QuorumPeer**进行初始化。最后开启线程```javaquorumPeer.start() ps:QuorumPeer翻译过来就是仲裁人 接着我们来到org.apache.zookeeper.server.quorum.QuorumPeer#start这个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 public synchronized void start() &#123; if (!getView().containsKey(myid)) &#123; throw new RuntimeException(\"My id \" + myid + \" not in the peer list\"); &#125; // 从本地文件中恢复数据 loadDataBase(); startServerCnxnFactory(); ... startLeaderElection(); super.start(); &#125;``` 这里又调用了loadDataBase这个方法，这个方法主要获取当前的epoch和最新的zxid;接着调用org.apache.zookeeper.server.quorum.QuorumPeer#startLeaderElection方法进行选举初始化。```java synchronized public void startLeaderElection() &#123; try &#123; // 如果当前是LOOKING状态，则投票给自己 if (getPeerState() == ServerState.LOOKING) &#123; currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch()); &#125; &#125; catch(IOException e) &#123; ... &#125; if (electionType == 0) &#123; ... &#125; this.electionAlg = createElectionAlgorithm(electionType); &#125;``` 接着就是使用createElectionAlgorithm，这个方法主要目的就是根据配置文件中配置的选举算法类型，创建选举算法。```java protected Election createElectionAlgorithm(int electionAlgorithm)&#123; Election le=null; //TODO: use a factory rather than a switch switch (electionAlgorithm) &#123; case 0: le = new LeaderElection(this); break; case 1: le = new AuthFastLeaderElection(this); break; case 2: le = new AuthFastLeaderElection(this, true); break; case 3: // 默认是这个 QuorumCnxManager qcm = createCnxnManager(); QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm); if (oldQcm != null) &#123; LOG.warn(\"Clobbering already-set QuorumCnxManager (restarting leader election?)\"); oldQcm.halt(); &#125; QuorumCnxManager.Listener listener = qcm.listener; if(listener != null)&#123; //启动已绑定端口的选举线程，等待集群中其他机器的连接 listener.start(); FastLeaderElection fle = new FastLeaderElection(this, qcm); fle.start(); le = fle; &#125; else &#123; ... &#125; break; default: assert false; &#125; return le;``` 实例化FastLeaderElection，对proposedLeader、proposedZxid、接收队列和发送队列进行初始化。通过FastLeaderElection的start方法启动选举线程，这里也启动了两个队列：发送队列和接收队列.```java void start()&#123; this.wsThread.start(); this.wrThread.start(); &#125; 接着来到org.apache.zookeeper.server.quorum.QuorumPeer#run这个方法里，这里面有段主要的代码： 1234567891011121314151617181920212223242526272829303132333435363738case LOOKING: if (Boolean.getBoolean(\"readonlymode.enabled\")) &#123; final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb); Thread roZkMgr = new Thread() &#123; public void run() &#123; try &#123; sleep(Math.max(2000, tickTime)); if (ServerState.LOOKING.equals(getPeerState())) &#123; roZk.startup(); &#125; &#125; catch (InterruptedException e) &#123; &#125; catch (Exception e) &#123; &#125; &#125; &#125;; try &#123; roZkMgr.start(); reconfigFlagClear(); if (shuttingDownLE) &#123; shuttingDownLE = false; startLeaderElection(); &#125; setCurrentVote(makeLEStrategy().lookForLeader()); &#125; catch (Exception e) &#123; &#125; finally &#123; &#125; &#125; else &#123; try &#123; reconfigFlagClear(); if (shuttingDownLE) &#123; shuttingDownLE = false; startLeaderElection(); &#125; setCurrentVote(makeLEStrategy().lookForLeader()); &#125; catch (Exception e) &#123; &#125; &#125; 上诉代码通过** setCurrentVote(makeLEStrategy().lookForLeader());**进行最终确认选举算法。 这里以FastLeaderElection算法为例，setCurrentVote第二个参数正是org.apache.zookeeper.server.quorum.FastLeaderElection#lookForLeader方法。在这个方法中使用logicalclock.incrementAndGet();来表示epoch，使用 updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch()); 来更新投票结果。 123456synchronized void updateProposal(long leader, long zxid, long epoch)&#123; ... proposedLeader = leader; proposedZxid = zxid; proposedEpoch = epoch;&#125; 使用sendNotifications发送投票结果。 123456789101112131415161718private void sendNotifications() &#123; for (long sid : self.getCurrentAndNextConfigVoters()) &#123; QuorumVerifier qv = self.getQuorumVerifier(); // 创建要发送的消息 ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes()); if(LOG.isDebugEnabled())&#123; ... &#125; // 添加到发送队列 sendqueue.offer(notmsg); &#125;&#125; 继续来看lookForLeader方法，当状态处于LOOKING时，一直循环从接收队列中拿出投票消息，并判断消息是否发送完毕，是则再次发送，否则执行以下逻辑: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 收到投票信息，判断消息是否属于这个集群 else if (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123; switch (n.state) &#123; case LOOKING: // If notification &gt; current, replace and send messages out // 如果当前消息的epoch大于logicalclock，表示这是新的一场投票 if (n.electionEpoch &gt; logicalclock.get()) &#123; // 更新本地epoch logicalclock.set(n.electionEpoch); // 清空原来的接收消息的队列 recvset.clear(); // 检查是否可以对方胜出 if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123; // 更新票据结果为对方票据 updateProposal(n.leader, n.zxid, n.peerEpoch); &#125; else &#123; // 否则票据不变 updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch()); &#125; sendNotifications(); &#125; else if (n.electionEpoch &lt; logicalclock.get()) &#123; if(LOG.isDebugEnabled())&#123; ... &#125; break; &#125; else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123; // epoch相同，则比较zxid和myid updateProposal(n.leader, n.zxid, n.peerEpoch); sendNotifications(); &#125; if(LOG.isDebugEnabled())&#123; ... &#125; // don't care about the version if it's in LOOKING state // 添加到本机投票集合，用作最终选举终结判断 recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch)); if (termPredicate(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch))) &#123; while((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null)&#123; // 一直等待新的通知，直到超时，作用是： if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch))&#123; recvqueue.put(n); break; &#125; &#125; if (n == null) &#123; // 如果当前服务器是leader，那么修改状态为leading self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING: learningState()); Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch); // 将接收队列清空 leaveInstance(endVote); return endVote; &#125; &#125; 上述方法使用到totalOrderPredicate，该方法如下： 12345678910protected boolean totalOrderPredicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch) &#123; if(self.getQuorumVerifier().getWeight(newId) == 0)&#123; return false; &#125; return ((newEpoch &gt; curEpoch) || ((newEpoch == curEpoch) &amp;&amp; ((newZxid &gt; curZxid) || ((newZxid == curZxid) &amp;&amp; (newId &gt; curId)))));&#125; 从这个方法便可以得知：投票的PK是先比较epoch，如果相同则再比较zxid，如果zxid也相同，那么则比较severID。 使用到termPredicate方法判断选举是否结束，默认超过半数server同意 123456789101112131415161718 protected boolean termPredicate(Map&lt;Long, Vote&gt; votes, Vote vote) &#123; SyncedLearnerTracker voteSet = new SyncedLearnerTracker(); voteSet.addQuorumVerifier(self.getQuorumVerifier()); if (self.getLastSeenQuorumVerifier() != null &amp;&amp; self.getLastSeenQuorumVerifier().getVersion() &gt; self .getQuorumVerifier().getVersion()) &#123; voteSet.addQuorumVerifier(self.getLastSeenQuorumVerifier()); &#125; // 把投票项放入set for (Map.Entry&lt;Long, Vote&gt; entry : votes.entrySet()) &#123; if (vote.equals(entry.getValue())) &#123; voteSet.addAck(entry.getKey()); &#125; &#125;// 统计set集合，判断某个server的票数是否超过了一半 return voteSet.hasAllQuorums(); &#125; 选举过程图如下 选举过程图","categories":[{"name":"分布式","slug":"分布式","permalink":"wubc.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"wubc.me/tags/zookeeper/"}]},{"title":"zookeeper知识总结","slug":"zookeeper知识总结","date":"2020-04-28T13:30:46.000Z","updated":"2020-04-28T13:31:56.226Z","comments":true,"path":"2020/04/28/zookeeper知识总结/","link":"","permalink":"wubc.me/2020/04/28/zookeeper%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"zookeeper概念、作用 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、命名服务、分布式同步、组服务等。 应用场景： 数据发布/订阅：当数据发生变化则发送watch消息给客户端，让客户端重新读取这个节点的数据。可以实现配置文件动态更新。 负载均衡 命名服务：类似于注册中心 分布式协调/通知：某个节点改变了，将这个变化发送给注册了这个节点的watcher的所有客户端 集群管理：能感知新接节点加入或节点的删除 分布式锁：将znode作废一把锁，能够创建成功的客户端则获取这把锁，删除则释放锁。 保持独占 控制时序 分布式队列 同步队列：利用临时节点，监听节点数目是否已达到要求 队列按照 FIFO 方式进行入队和出队操作：创建持久有序节点，znode 用于消息存储，出队则删除序列号最小的节点。 配置文件解析 dataDir:快照文件存储目录 dataLogDir:日志存储目录 tickTime:zookeeper中最小的时间单元长度 initLimit:默认为10，表示的tickTime值的倍数，用于配置数据同步的时间 syncLimit:默认值为5，表示tickTime的倍数，用于配置leader服务器和follower服务器之间进行心跳检车的最大延时时间。 server.id=host:port1:port2 ：配置集群机器列表。第一个端口用于leader和follower之间的通信和数据同步，第二个端口用进行选举过程的投票通信 节点 DataNode 数据节点，底层是ConcurrentHashMap。 节点类型 持久节点 临时节点 持久有序节点 临时有序节点 节点信息 状态属性 说明 czxid 节点被创建时的事务ID mzxid 节点最后一次被修改时的事务ID ctime 节点被创建时的时间 mtime 节点最后一次被修改时的时间 version 节点的版本号：变更次数 cversion 子节点的版本号 aversion ACL版本号 ephemeralOwner 临时节点的会话sessionID dataLength 数据内容的长度 numChildern 子节点的个数 pzxid 子节点列表最后一次被修改时的事务ID（当子节点列表更改才会修改这个值） 角色 leader foollower observer 工作状态 looking：没有leader，需要进行选举 following：表示当前server的角色是follower leading： 表示当前server的角色是leader observing： 表示当前server的角色是observer 数据同步注册流程： 1、follower和observer向leader注册 2、数据同步 3、同步确认 同步分类 直接差异化同步（DIFF同步）：场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog 先回滚再差异化公布： 场景：旧的的leader存在一条事务不在新的leader服务器上 仅回滚同步（TRUNC同步）：场景：peerLastZxid 大于 maxCommittedLog 全量同步（SNAP同步）： 文件系统 提供一个多层级的节点命名空间（节点称为 znode），每个节点的存放数据上限为1M。 节点类型 持久节点 临时节点：不能存在子节点 持久有序节点 临时有序节点 有序节点节点名称可以同名？ Watcher 机制watcher特性 一次性：watcher被触发了，就会从存储中删除 串行执行：客户端watcher回调是一个串行同步的过程 轻量 异步：watcher通知事件从server发送到client是异步的 注册watcher getData exists getChildren 触发watcher create delete setData watcher事件类型 NodeCreated NodeDeleted NodeDataChanged NodeChildrenChanged event For “/path” event For “/path/child” create(“/path”) NodeCreated 无 delete(“/path”) NodeDeleted 无 setData(“/path”) NodeDataChanged 无 create(“/path/child”) NodeChildrenChanged NodeCreated delete(“/path/child”) NodeChildrenChanged NodeDeleted setData(“/path/child”) 无 NodeDataChanged 客户端注册watcher 客户端注册watcher流程图 服务端处理watcher 服务端接收 Watcher 并存储 Watcher 触发 封装 WatchedEvent 查询 Watcher 没有找到，则客户端没有注册watcher 找到，则中watchtable和watcher2paths中删除对应watcher 调用 process 方法来触发 Watcher 客户端回调watcher 反序列化成watcherEvent对象 取出相关的全部watcher，添加到等待队列，等待EventThread的消费 EventThread线程每次从waiting Events队列中取出一个watcher进行串行同步处理 回调process方法完成回调。 事件监听demo 使用zookeeper原生方法监听watcher事件：zookeeer监听watcher事件 使用curator监听watcher事件：curator监听watcher事件 ACL权限模式 IP：通过IP地址细粒度进行权限控制 Digest: 通过权限标识来进行权限匹配 World:一种特殊的 digest 模式，只有一个权限标识，“world:anyone“，最开放的 Super: 超级用户 授权对象 权限permission CREATE DELETE READ WRITE ADMIN ZAB协议 一种支持崩溃恢复的原子广播协议 2PC提到ZAB协议，我们需要先了解一个2PC（二阶提交）的原理。示例图如下： 事务提交 中断提交 zookeeper的2PC（二阶提交） zookeeper的2PC 崩溃恢复奔溃恢复需要保证两种特性: 已提交的事务不被丢弃：确保那些已经在 Leader 提交的事务最终会被所有服务器提交 已丢弃的事务不再出现：丢弃那些只在 Leader 提出/复制，但没有提交的事务 选举出zxid最大的那个服务器作为leader，这样保证了已提交事务的不会被丢失、被丢弃的消息不会再出现。 包含了上一个epoch周期未提交的事务proposal的服务器再次启动时，不能成为leader，因为集群中的机器包含了更高epoch的事务proposal。 消息广播：改进版本的2pc 与传统2PC相比较，去除了中断逻辑。消息广播协议是居于具有FIFO的TCP协议来进行网络通信的，确保消息接收和发送的顺序性。 消息广播示例图 ZXID 消息广播使用到64位的ZXID来作为事务ID，该ID是全局唯一的、递增的。有高32位epochID和低32位消息计数器组成。每当有新的leader被选举出来时，epochID会进行加一，消息计算器则会重写从0开始计算。 选举myid越大，在leader选举中权重越大。 投票过程： 1、先判断epoch，大的为leader，相等则进入第二步 2、判断zxid: zxid比较大的服务器优先作为leader，相等则判断myid 3、判断myid:如果是首次启动，zxid都为0，那么需要判断myid，myid最大的服务器作为leader 统计投票:如果半数服务器接收到相同的投票信息，那么便认为选举出了leader了 选举算法可以看《Zookeeper选举算法分析: 以FastLeader为例》这一篇 选举需要保证同在logicallock? zookeeper实现分布式锁 多个客户端创建临时有序节点，节点集合中编号最小的节点的持有者，表示获取到锁。 锁用完后，删除节点，表示释放锁。而剩下节点最小的也获取到锁，以此列推。子节点集合中各个节点只监听编号比自己小的节点。 zookeeper实现分布式锁例子 注：原生的方式比较麻烦，可以使用curator提供的API实现分布式锁 zookeeper工作流程 发现：选举出leader 同步：leader和flower进行数据同步 广播：结束事务请求。广播消息 客户端 初始化阶段： 初始化zookeeper对象 设置会话默认watcher：该watcher保存到ClientWatchManager中 构造zookeeper服务器地址列表管理器：HostProvider 创建并初始化客户端网络连接器：ClientCnxn 初始化SendThread和EventThread 会话创建阶段： 启动SendThread和EventThread 获取服务器地址 创建TCP连接 构造ConnectRequest请求 发送请求 响应处理阶段： 接收服务端响应 处理response，得到ConnectResponse对象 连接成功：生成SyncConnected-None事件 查询watcher，将其放到waitingEvent队列 处理事件:EventThread处理waitingEvent中的watcher对象 数据同步先来看下面三个概念： 1、peerLastZxid:该learner服务器最后处理的ZXID 2、minCommittedLog：leader服务器提议缓存队列committedLog的最小ZXID 3、maxCommittedLog：leader服务器提议缓存队列committedLog的最大ZXID DIFF：直接差异化同步 peerLastZxid介于minCommittedLog和maxCommittedLog使用 TRUNC+DIFF:先回滚再差异化同步 leader服务器发现某个learner包含了一条自己没有的事务记录，那么就让learner进行事务回滚，回滚到leader服务器上存在，同时最接近peerLastZxid的ZXID。 TRUNC：仅回滚同步 peerLastZxid大于maxCommittedLog SNAP:全量同步 场景：peerLastZxid小于minCommittedLog或leader服务器没有提议缓存队列，peerLastZxid不等于lastProcessedZxid。","categories":[{"name":"分布式","slug":"分布式","permalink":"wubc.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"wubc.me/tags/zookeeper/"}]},{"title":"Spring拾遗","slug":"Spring拾遗","date":"2020-04-11T10:09:22.000Z","updated":"2020-04-11T13:09:11.641Z","comments":true,"path":"2020/04/11/Spring拾遗/","link":"","permalink":"wubc.me/2020/04/11/Spring%E6%8B%BE%E9%81%97/","excerpt":"","text":"一、spring结构 spring结构 主要有核心层、数据访问层、web层、以及AOP、Aspects、Instrumentation组成 核心层： Beans: 包括了控制反转、依赖注入。 core： 封装了最底层的部分，包括资源访问、类型转换等一些工具类 context: 资源绑定、数据验证、国际化、容器生命周期、事件传播等 expression language（EL）：EL表达式语言支持 二、工作原理先上图： springMVC工作流程图.png 说明 用户向服务器发送请求，请求被 springMVC 前端控制器 DispatchServlet 捕获； DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping，将请求映射到处理HandlerExcutionChain； DispatchServlet 根据获得 Handler 选择一个合适的 HandlerAdapter 适配器处理； HandlerAdapter 调用具体的处理器（controller） Handler 对数据处理完成以后将返回一个 ModelAndView（） 对象给 DisPatchServlet; Handler 返回的 ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet 通过ViewResolver 试图解析器将逻辑视图转化为真正的视图 View; DispatcherServle 通过 model 解析出 ModelAndView()中的参数进行解析最终展现出完整的 view 并返回给客户端 三、注解xml定义会覆盖注解？ 在配置文件中通过&lt;context:annotation-config /&gt;来开启注解装配 四、bean的生命周期（重点）参考文章：https://juejin.im/post/5daced865188255a270a0de6 bean生命周期流程 Bean容器在配置文件中找到Spring Bean的定义。 Bean容器使用Java Reflection API创建Bean的实例 如果声明了任何属性，声明的属性会被设置。如果属性本身是Bean，则将对其进行解析和设置。 如果Bean类实现BeanNameAware接口，则将通过传递Bean的名称来调用setBeanName()方法。 如果Bean类实现BeanClassLoaderAware接口，则将通过传递加载此Bean的ClassLoader对象的实例来调用setBeanClassLoader()方法。 如果Bean类实现BeanFactoryAware接口，则将通过传递BeanFactory对象的实例来调用setBeanFactory()方法。 如果有任何与BeanFactory关联的BeanPostProcessors对象已加载Bean，则将在设置Bean属性之前调用postProcessBeforeInitialization()方法。 如果Bean类实现了InitializingBean接口，则在设置了配置文件中定义的所有Bean属性后，将调用afterPropertiesSet()方法。 如果配置文件中的Bean定义包含init-method属性，则该属性的值将解析为Bean类中的方法名称，并将调用该方法。 如果为Bean Factory对象附加了任何Bean 后置处理器，则将调用postProcessAfterInitialization()方法。 如果Bean类实现DisposableBean接口，则当Application不再需要Bean引用时，将调用destroy()方法。 如果配置文件中的Bean定义包含destroy-method属性，那么将调用Bean类中的相应方法定义。 五、AOP面向切面编程。 切面：通知和切点的结合 连接点：应用执行过程中能够插入切面的一个点 通知（Advice）：切面的工作被称为通知 切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点 织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程 关注点（concern）是应用中一个模块的行为，横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能。 spring只支持方法级别的连接点 切面Aspect 由切入点和通知组成，包含了横切逻辑、连接点定义 实现方法： 基于XML Schema 基于@Aspect注解 spring通知类型 before：前置通知，在方法被调用前调用通知功能 after：后置通知，方法完成后调用通知 after-returning：在目标方法成功执行后调用通知 after-throwing：方法抛出异常后调用通知 around：目标方法调用前后都调用通知 实现方式 静态代理：AspectJ，编译时生成AOP代理类，将切面织入了字节码 动态代理：Spring AOP，不修改字节码，临时生成AOP对象 六、IOC 将操作对象的调用权交给了容器，通过容器来实现对象组件的装配和管理。实现原理是工厂模式加反射机制 优点： 减少代码量。 使应用容易测试，单元测试不再需要单例和JNDI查找机制。 最小的代价和最小的侵入性使松散耦合得以实现 作用 便于管理对象的创建和依赖关系的维护 托管了类的产生过程 支持的功能 依赖注入 依赖检查 自动装配 七、BeanFactory 和 ApplicationContext区别ApplicationContext是BeanFactory的子接口 与BeanFactory相比较，ApplicationContext增加了一下功能： 继承MessageSource，因此支持国际化。 统一的资源文件访问方式。 提供在监听器中注册bean的事件。 支持同时加载多个配置文件。 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 BeanFactory是使用延迟加载来注入bean,因此如果没有调用getBean将可能不会发现异常。而ApplicationContext一次性创建了所有的bean。BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。 八、依赖注入 组件之间的依赖关系有容器在应用系统运行期决定，由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。 原则应用组件不应该负责查找资源或者其他依赖的协作对象，容器全权负责组件的装配 优势 查找定位操作与应用代码无关，交由容器管理 不依赖容器API，可以在容器外使用应用对象 实现方式 接口注入,spring4已弃用 构造器注入 setter方法注入 九、SpringBeanbean定义包含配置元数据、生命周期详情、依赖 配置元数据 XML配置文件 注解配置 基于Java的配置 作用域 singleton：每个bean在容器中只存在一个实例 prototype：有多个实例 request: 每次请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 session：每一个session中，一个bean对应一个实例，该作用域仅在基于web的Spring ApplicationContext情形下有效。 global-session：以session相比，这是一个全局的 线程安全性singleton不是线程安全的，prototype可以保证线程安全；如果bean是无状态的，bean也是安全的。 ps: 无状态: 由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态bean 多线程下处理并发问题 ThreadLocal：每个线程都拥有自己变量副本 线程同步机制：只有一份变量，每个线程访问前需要获取锁 生命周期重要的方法 setUp：在容器加载bean时被调用 teardown： 在容器写在类的时候被调用 十、自动装配 Spring通过BeanFactory中注入的方式自动处理bean之间的依赖关系 自动装配的方式 no: 默认的方式，不进行自动装配，通过手动ref来装配bean byType：通过参数的数据类型进行自动装配 byName: 通过bean的名称进行自动装配 constructor: 通过构造函数进行装配 audodetect: 自动探测，优先使用construct，否则使用byType spring还用到 @Autowired 的注解方式进行自动装配，使用前需在配置文件中配置 &lt;context:annotation-config /&gt;属性。它的原理是：利用AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到用@Autowired注解修饰的bean时，会在容器中查询是否有这个bean，有且只有一个那么将会返回，而有多个，则会通过名称去查找，查询不到则抛出异常。 局限性 重写：使用配置定义依赖，则需重写自动装配？ 不能自动装配基本类型 模糊：不如显示装配精确 十一、Spring数据访问spring dao的作用 使jdbc等数据访问即使更容易以一种统一的方式工作 jdbc template 提供便利的方法将数据库数据转换为基本数据类型和对象、执行数据库操作语句、提供数据错误处理等 Spring事务实现方式类型： 编程式i：开发人员通过编程的方式进行事务的管理，灵活但是难维护 声明式：通过注解和XML配置来管理事务，将业务代码是事务管理放分离 事务传播行为： PROPAGATION_REQUIRED:存在事务则加入，否则创建一个新的事务 PROPAGATION_SUPPORT: 存在事务则加入，否则以非事务执行 PROPAGATION_MANDATORY:存在事务则加入，否则抛出异常 PROPAGATION_REQUIRES_NEW: 无论当前是否存在事务，都创建事务 PROPAGATION_NEVER: 以非事务方式执行，当前存在事务则抛出异常 PROPAGATION_NESTED: 当前存在事务，则在嵌套事务中执行，没有则按REQUIRED属性执行 事务隔离 ISOLATION_DEFAULT: 默认，使用数据库隔离机制 ISOLATION_READ_UNCOMMITTED: 未提交读，事务未提交前就可以被其他事务读取，会出现幻读、脏读、不可重复读问题 ISOLATION_READ_COMMIT:一个事务被提交后才能被其他事务读取，会出现幻读、不可重复读 ISOLATION_REPEATABLE_READ:可重复读，多次读取同一个数据都是一致的 ISOLATION_SERIALIABLE:序列化，隔离级别最高，可防止上面出现的问题 ps: 脏读、不可重复读、幻读的概念","categories":[{"name":"Spring","slug":"Spring","permalink":"wubc.me/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"wubc.me/tags/Spring/"},{"name":"知识总结","slug":"知识总结","permalink":"wubc.me/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}]},{"title":"Redis知识总结","slug":"Redis知识总结","date":"2020-04-07T15:15:45.000Z","updated":"2020-04-08T13:11:34.334Z","comments":true,"path":"2020/04/07/Redis知识总结/","link":"","permalink":"wubc.me/2020/04/07/Redis%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"Redis一、数据类型 数据类型 1.1 字符串命令： setnx命令：键必须不存在，才可以设置成功。可作为分布式锁的一种实现方案 命令实例： 12345127.0.0.1:6379&gt; set hello worldOK127.0.0.1:6379&gt; get hello&quot;world&quot;127.0.0.1:6379&gt; 时间复杂度: 时间复杂度 内部编码有三种情况： int： 8个字节的长整型 embstr: 小于39个字节的字符串 raw: 大于39个字节的字符串 使用场景： 缓存 计数 共享session 限速 1.2 hash命令： hset、hget hexists hkeys、hvals hincrby 命令实例： 12345678127.0.0.1:6379&gt; hmset dev name &quot;devtool&quot; desc &quot;haha&quot; likes good127.0.0.1:6379&gt; hgetall dev1) &quot;name&quot;2) &quot;devtool&quot;3) &quot;desc&quot;4) &quot;haha&quot;5) &quot;likes&quot;6) &quot;good&quot; 时间复杂度： hash时间复杂度 内部编码： ziplist 压缩列表，元素个数小于hash-max-ziplist-entries配置（默认512个）使用 hashtable,当value大于64个字节或field个数大于512，编码有ziplist变为hashtable 使用场景： 保存对象属性 1.3 列表 一个列表最多可以存储232 -1个元素，可重复 命令： 命令 命令实例： 12345678910111213127.0.0.1:6379&gt; lpush hello world(integer) 1127.0.0.1:6379&gt; lpush hello nice(integer) 2127.0.0.1:6379&gt; lpush hello with(integer) 3127.0.0.1:6379&gt; lpush hello you(integer) 4127.0.0.1:6379&gt; lrange hello 0 101) &quot;you&quot;2) &quot;with&quot;3) &quot;nice&quot;4) &quot;world&quot; br命令不会阻塞导致后面的命令的不执行吗？ 时间复杂度： 时间复杂度 内部编码： ziplist linkedlist quicklist 使用场景： 消息队列 文章列表 组成队列、栈等 lpush+lpop=Stack（栈） lpush+rpop=Queue（队列） lpsh+ltrim=Capped Collection（有限集合） lpush+brpop=Message Queue（消息队列） 1.4 集合常用命令： zadd srem scard spop smembers sinter 交集 sunion 并集 sdiff 差集 命令实例： 12345127.0.0.1:6379&gt; sadd fruit apple127.0.0.1:6379&gt; sadd fruit orange127.0.0.1:6379&gt; SMEMBERS fruit1) &quot;orange&quot;2) &quot;apple&quot; 内部编码 intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时使用 hahstable 使用场景： 标签 随机数 社交需求 1.5 有序集合命令实例 12345678910111213141516127.0.0.1:6379&gt; zadd language 1 java(integer) 1127.0.0.1:6379&gt; zadd language 2 php(integer) 1127.0.0.1:6379&gt; zadd language 3 python(integer) 1127.0.0.1:6379&gt; zadd language 4 c(integer) 1127.0.0.1:6379&gt; ZRANGE language 0 10 withscores1) &quot;java&quot;2) &quot;1&quot;3) &quot;php&quot;4) &quot;2&quot;5) &quot;python&quot;6) &quot;3&quot;7) &quot;c&quot; 1.6 数据机构对应的内部编码 内部编码 二、Redis单线程模型 Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。 速度快的原因： 内存访问 NIO。使用epoll作为IO多路复用技术的实现 单线程避免了线程切换和竞态产生的消耗 三、Redis其他功能3.1 bitmap命令： setbit key offset value 设置值 gitbit key offset 获取值 bitcount [start][end] 获取指定范围的个数 bitop op destkey key[key….] op可以为and（交集）、or（并集）、not（非）、xor（异或） 3.2 HyperLogLog3.3 发布订阅命令： publish channel message 发布消息 subscribe channel [channel …] 订阅消息 unsubscribe [channel [channel …]] 取消订阅 pubsub channels [pattern] 查看活跃的频道 pubsub numsub [channel …] 查询频道数 3.4 GEO 地理信息定位用来实现基于地理位置信息的应用,例如查找附近的人 3.5 事务 Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。 redis事务的特点： redis 不支持回滚，事务失败时不进行回滚，而是继续执行余下的命令。 如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 如果在一个事务中出现运行错误，那么正确的命令会被执行。 事务的三个阶段： 事务开始 MULTI 命令入队 事务执行 EXEC 四、Redis客户端 Redisson、Jedis、lettuce等等，官方推荐使用Redisson RESP格式 1234567891011*&lt;参数数量&gt; CRLF$&lt;参数1的字节数量&gt; CRLF&lt;参数1&gt; CRLF...$&lt;参数N的字节数量&gt; CRLF&lt;参数N&gt; CRLF 4.1 java 客户端jedis与Redission相比，jedis支持排序、事务、管道、分区等Redis特性。 主要要熟悉其api和jedis连接池的使用 jedis 基本使用 jedis 使用pipeline jedis 使用lua jedis poll Jedis对象个数是有限的，默认是8个 4.2 Redis客户端API命令 client list 列出与Redis服务端相连的所有客户端连接信息 info clients 列出缓冲区信息两者相比较 两种命令的比较 4.3 缓冲区输入缓冲区： qbuf：缓冲区总容量 qbuf-free: 剩余容量 输出缓冲区： obl： 固定缓冲区的长度 oll： 动态缓冲区列表的长度 omem： 使用的字节数 输出缓冲区有三种客户端：普通客户端、发布订阅客户端、slave客户端 4.4 常见异常及产生原因： 无法从连接池获取到连接 客户端读写超时 客户端连接超时 客户端缓冲区异常 Lua脚本正在执行 Redis正在加载持久化文件 Redis使用的内存超过maxmemory配置 客户端连接数过大 五、持久化两种持久化方式：RDB、AOF 5.1 RDB RDB：间隔时间生成数据集快照。适用于灾难恢复，只有一个文件，恢复速度快。父进程通过fork一个子线程来进行保存RDB的工作。由于生成RDB文件不是实时的，因此如果遇到故障，可能会丢失数据，使用fork创建子线程，频繁执行成本高，存在RDB文件格式兼容性问题。 触发RDB持久化过程分为手动触发和自动触发。手动触发命令： save bgsave 自动触发： 使用save相关配置 从节点执行全量复制操作 5.2 AOF AOF：通过文件追加命令的方式生成AOF文件，AOF是以Redis协议格式保存的，新的命令会被追加到文件末尾。AOF可以通过设置fsync策略来决定什么时候写，默认为每秒钟 fsync 一次。与RDB相比较，AOF速度较慢、文件体积较大。 AOF工作流程 6MSofA2hqnGCNZb 5.2.1 命令写入所有的写入命令会追加到aof_buf（缓冲区）中。直接追加文本，写入到缓冲区有个好处是Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。 5.2.2 文件同步AOF缓冲区根据对应的策略向硬盘做同步操作。文件同步策略： 6atIAc9LqDZRFOd write操作会触发延迟写机制,同步硬盘操作依赖于系统调度机制. fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化. 5.2.3 文件重写随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。重写文件可以使其变小，主要是因为：超时、无效命令不再写入、多条命令可以合并成一条。 AOP文件的重写机制分为手动和主动触发两种方式： 手动触发 ：直接调用bgrewriteaof命令。 自动触发 ：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机 auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。 重写过程： rMO1RiY2tU87laA 1、执行AOF重写请求2、fork子线程3、响应其他命令，并且将期间的命令写入到AOF缓冲区4、写入到新AOF文件5、子线程发送信号给父进程6、将AOF重写缓冲区写入到新的AOF文件7、替换旧AOF文件，完成重写 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。 UVkiPLCsbJ9ofDQ 六、性能问题与解决 master不要做持久化工作，例如存快照和AOF日志文件 Master 调用 BGREWRITEAOF 重写 AOF 文件，占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象 为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内 如果部署多个Redis实例，尽量保证同一时刻只有一个子进程在工作 避免在大量写入时做子进程重写操作，这样将导致父进程维护大量页副本，造成内存消耗 不要和其他CPU密集型服务部署在一起，造成CPU过度竞争 不要和其他高硬盘负载的服务部署在一起 开启配置no-appendfsync-on-rewrite，表示在AOF重写期间不做fsync操作。 七、复制 在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡等需求 复制的数据流是单向的，只能由主节点复制到从节点。 复制过程： 保存主节点（master）信息 主从建立socket连接 发送ping命令 权限验证 同步数据集： 同步过程分为：全量复制和部分复制 命令持续复制 八、阻塞内在原因： API或数据结构使用不合理 CPU饱和 持久化阻塞 外在原因： CPU竞争： 进程竞争、绑定CPU（对于开启了持久化或参与复制的主节点不建议绑定CPU） 内存交换 网络问题 九、内存9.1 内存消耗内存消耗可以分为进程自身消耗和子进程消耗info memory命令获取内存相关指标。 Redis进程内消耗主要包括：自身内存+对象内存+缓冲内存+内存碎片 子进程内存消耗 子进程内存消耗主要指执行AOF/RDB重写时Redis创建的子进程内存消耗 9.2 内存管理使用maxmemory参数限制最大可用内存，通过config set maxmemory进行动态修改内存上限 9.3 内存回收策略 删除过期键对象 惰性删除：当访问key时才判断是否过期，存在问题是可能存在大量没有被访问的过期的key 定时任务删除 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。 内存溢出控制策略 noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息。 volatile-lru：根据LRU算法删除设置了超时属性的键 allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性 allkeys-random：随机删除所有键 volatile-random：随机删除过期键 volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据 9.4 内存优化内存优化几个点： 缩减键值对象：key尽量使用简写，value可以进行压缩序列化 尽量使用整数对象以节省内存。注意：使用了LRU淘汰策略会使对象池无效，原因在于LRU字段被共享了，无法获取最后的访问时间。 尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。 不一定把每份数据作为字符串整体存储，可以使用其他数据结构 编码优化：例如使用ziplist编码类型可以大幅降低内存占用、整数集合时尽量使用intset编码且使用intset编码的集合时，尽量保持整数范围一致 减少键的个数 十、缓存设计10.1 缓存更新策略 LRU/LFU/FIFO算法剔除： 超时剔除： 主动更新 cFlaswjIQX1oG4L 10.2 缓存粒度控制缓存全部属性、只缓存部分重要属性 缓存粒度对比 10.3 缓存穿透 指查询一个根本不存在的数据，缓存层和存储层都不会命中 由于缓存层不存在的数据，导致每次请求都要到存储层去查询，增加了后端存储的负载。 优化方法1、缓存空对象：存储不命中后，将空对象作为值保存在缓存层中，可以设置一个较短的过期时间来防止大量的键占用空间。2、布隆过滤器拦截：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉。 布隆过滤器 10.4 无底洞优化 无底洞:投入越多不一定产出越多，即节点越多效率更加慢的现象 主要是减少网络操作次数： 串行命令，逐次执行n个get命令 串行IO：将属于同一个节点的key进行归档 并行IO：将串行IO改为多线程执行 hash_tag实现：hash_tag可以将多个key强制分配到一个节点上 几种优化方案对比： phRo7TJqNLacb6Q 10.5 雪崩优化 雪崩: 如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。 优化： 保证缓存层服务高可用性 依赖隔离组件为后端限流并降级：例如可以使用hystrix 提前演练 10.5 热点key重建优化主要是要减少重建缓存的次数。 互斥锁 永不过期 从缓存层面来看，确实没有设置过期时间 从功能层面来看，为每个value设置一个逻辑过期时间，过期是利用单线程去构建缓存 10.6 缓存击穿 缓存中没有数据但是数据库有，导致去数据库取数据，数据库压力增大，与缓存雪崩的区别是缓存穿透一般指查询同一条数据。 优化方案： 设置热点数据永不过期 设置互斥锁 10.7 小结 前面几种情况都有用到互斥锁，原理是，但key不存在的时候，加锁，再从数据库中查询，并将查询结果加入缓存，然后释放锁。而在这过程中其他进程发现有锁则会等待，这样子防止了大量的请求都往数据库查询了。 十一、哨兵11.1 主要功能 集群监控：负责监控 redis master 和 slave 进程是否正常工作。 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。 十二、集群分布式方案基于客户端分配代理十三、分区分类： 客户端分区 代理分区 查询路由 十四、Redis实现分布式锁 使用SETNX命令 使用redlock 安全特性：互斥访问，即永远只有一个 client 能拿到锁 死锁：最终 client 都可能拿到锁，不会出现死锁的情况 容错性：只要大部分 Redis 节点存活就可以正常提供服务 十五、数据一致性解决方案 问题场景 描述 解决 先写缓存，再写数据库，缓存写成功，数据库写失败 缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读 需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存 先写数据库，再写缓存，数据库写成功，缓存写失败 写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据 缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现 需要缓存异步刷新 指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候 确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔 参考 《Redis开发与运维》 redis面试题","categories":[{"name":"Redis","slug":"Redis","permalink":"wubc.me/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"wubc.me/tags/Redis/"}]},{"title":"java设计模式总结","slug":"java设计模式总结","date":"2020-03-22T08:32:08.000Z","updated":"2020-03-22T08:35:08.534Z","comments":true,"path":"2020/03/22/java设计模式总结/","link":"","permalink":"wubc.me/2020/03/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"设计模式总结 本篇文章不对每一个设计模式进行细讲，只对常见的设计模式展开。 一、分类： 创建型模式：工厂方法模式、抽象工厂模式、单例、建造者、原型模式 结构型模式：适配器、装饰器、代理、外观、桥接、组合、享元模式 行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 二、创建型模式2、1 单例模式分为懒汉式和饿汉模式 饿汉式：在使用前就创建好实例 123456789101112public class Singleton &#123; public static Singleton instance=new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 懒汉式：使用到才创建实例 1234567891011121314151617181920public class Singleton &#123; public static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; // 双重检查锁 synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 2、2 简单工厂模式工厂创建实例，而这些实例都实现了同一个接口，通过传递给不同的参数给工厂，工厂以此来创建不同的实例。例子：实体类：水果 1234567@Datapublic class Fruit &#123; private String name; private String color; &#125; 1234@Datapublic class Apple extends Fruit &#123; &#125; 123@Datapublic class Orange extends Fruit &#123;&#125; 接口类： 123456public interface FruitService &#123; String getFruitName();&#125; 实现类：拿AppleService为例子 12345678public class AppleService implements FruitService &#123; @Override public String getFruitName() &#123; return \"apple\"; &#125;&#125; 工厂类： 12345678910111213141516171819public class SimpleFruitFactory &#123; public FruitService getFruit(String name) &#123; if (\"apple\".equals(name)) &#123; return new AppleService(); &#125; else if (\"orange\".equals(name)) &#123; return new OrangeService(); &#125; else &#123; return null; &#125; &#125; public static void main(String[] args) &#123; SimpleFruitFactory factory = new SimpleFruitFactory(); System.out.println(\"the name is \" + factory.getFruit(\"apple\").getFruitName()); &#125;&#125; 2、3 多工厂模式即一个工厂中提供多个工厂方法 2、4 抽象工厂模式模式创建多个工厂类 2、5 建造者模式通过不同方法来创建复合对象。实例： 12345678910111213141516171819202122232425262728293031323334public class BuilderDemo &#123; public static People builder() &#123; return new People(); &#125; @Data static class People &#123; private String name; private int age; public People setPeopleName(String name) &#123; this.setName(name); return this; &#125; public People setPeopleAge(int age) &#123; this.setAge(age); return this; &#125; public void build() &#123; System.out.println(this.toString()); &#125; &#125; public static void main(String[] args) &#123; BuilderDemo.builder() .setPeopleName(\"小明\") .setPeopleAge(10) .build(); &#125;&#125; 三、结构型模式3、1 适配器模式将类或接口转换为期望的形式表示，已达到兼容的效果。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 类的适配器模式：通过继承目标类，实现扩展的接口类（该类包含目标类相同的方法） 目标类： 1234567public class TargeClass &#123; public void say() &#123; System.out.println(\"hello world\"); &#125; &#125; 实现扩展的接口类 1234567public interface Compatible &#123; void say(); void bye();&#125; 12345678910111213public class ClassAdapter extends TargeClass implements Compatible&#123; @Override public void bye() &#123; System.out.println(\"bye\"); &#125; public static void main(String[] args) &#123; ClassAdapter classAdapter = new ClassAdapter(); classAdapter.say(); classAdapter.bye(); &#125;&#125; 对象的适配器模式适配器类不继承目标类，而是持有目标类对象 12345678910111213141516171819public class WrapperAdapter implements Compatible &#123; private TargeClass targeClass; public WrapperAdapter(TargeClass targeClass) &#123; this.targeClass = targeClass; &#125; @Override public void say() &#123; &#125; @Override public void bye() &#123; &#125;&#125; 接口的适配器模式 一个接口中有多个方法需要实现，但是并不是所有的都是需要的，这时可以借助于一个抽象类， 该抽象类实现了该接口， 实现了所有的方法， 不和原始的接口打交道，只和该抽象类取得联系，所以写一个类，继承该抽象类，重写需要的方法 3、1 装饰模式动态地为对象添加一些新的功能,装饰器持有被装饰类的对象，装饰器和被装饰的类实现相同的接口。例子： 接口 12345public interface Decorable &#123; void doSomethings();&#125; 被装饰的类： 123456public class Target implements Decorable &#123; @Override public void doSomethings() &#123; System.out.println(\"Target doSomethings\"); &#125;&#125; 装饰器： 123456789101112131415161718192021public class Decorator implements Decorable &#123; private Target target; public Decorator(Target target) &#123; super(); this.target = target; &#125; @Override public void doSomethings() &#123; System.out.println(\"before decorate\"); target.doSomethings(); System.out.println(\"after decorate\"); &#125; public static void main(String[] args) &#123; Decorable decorable = new Decorator(new Target()); decorable.doSomethings(); &#125;&#125; 四、行为型模式4、1 策略模式定义多个算法，有外部用户决定使用哪个算法，实现接口方法。 接口类： 1234public interface ICalculator &#123; int calculate(int a, int b);&#125; 实现类： 123456public class Plus implements ICalculator &#123; @Override public int calculate(int a, int b) &#123; return a + b; &#125;&#125; 123456public class Subtraction implements ICalculator &#123; @Override public int calculate(int a, int b) &#123; return a - b; &#125;&#125; 实例测试： 1234567public class StrategyTest &#123; public static void main(String[] args) &#123; ICalculator plus = new Plus(); System.out.println(plus.calculate(1,2)); &#125;&#125; 4、2 观察者模式观察者向主题发起订阅，当主题发生改变时，会通知观察者。 定义观察者接口： 12345public interface Observer &#123; void notifyNotice();&#125; 观察者: 123456public class Observer1 implements Observer &#123; @Override public void notifyNotice() &#123; System.out.println(\"1 had receive notices\"); &#125;&#125; 123456public class Observer2 implements Observer &#123; @Override public void notifyNotice() &#123; System.out.println(\"2 had receive notices\"); &#125;&#125; 主题: 123456789101112131415public class Subject &#123; private List&lt;Observer&gt; observerList = new ArrayList(); public void add(Observer observer) &#123; observerList.add(observer); &#125; public void notifyAllObserver() &#123; for (Observer observer : observerList) &#123; observer.notifyNotice(); &#125; &#125;&#125; 测试： 123456789public class ObserverTest &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); subject.add(new Observer1()); subject.add(new Observer2()); subject.notifyAllObserver(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"wubc.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"wubc.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java多线程知识复习(一)","slug":"Java多线程知识复习","date":"2020-03-21T12:40:12.000Z","updated":"2020-03-21T12:42:22.726Z","comments":true,"path":"2020/03/21/Java多线程知识复习/","link":"","permalink":"wubc.me/2020/03/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"Java多线程复习总结1、基本概念待补充 2、线程局部变量 ThreadLocal用于实现线程内的数据共享。 使用set方法时会先获取当前线程的ThreadLocalMap 对象，而这个对象的key又是一个ThreadLocal对象。每个线程其实都有一份自己独享的 ThreadLocalMap 对象. 12345678ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; 应用场景; 订单流水 3、Java并发编程库：JUC java.util.concurrent 多线程并发库 java.util.concurrent.atomic 提供原子性操作的工具类包 java.util.concurrent.lock 提供锁机制 3、1 java.util.concurrent 多线程并发库1）执行程序： Executors 线程池工厂类： 减少线程的重复创建。提供线程利用率使用Executors创建线程池的用法： 123456789// 创建固定的线程池ExecutorService fPool = Executors.newFixedThreadPool();//创建缓存大小的线程池ExecutorService cPool = Executors.newCachedThreadPool();//创建单一的线程池ExecutorService sPool = Executors.newSingleThreadExecutor();//创建带有定时调度的线程池Executors.newScheduledThreadPool() ExecutorService 使用： execute(Runnable) ： 无返回值 submit(Runnable)：返回一个 Future 对象 submit(Callable)：返回一个 Future 对象 invokeAny(…)：返回其中一个 Callable 对象的结果 invokeAll(…)：返回一系列的 Future 对象 Executors 关闭 shutdown ：关闭之前提交的任务可以继续执行知道结束 shutdownNow：中断大部分线程 corePoolSize和maximumPoolSize判断线程池是否创建新的线程 ForkJoinPool 合并和分叉（线程池）可以将大任务分割成若干子任务，等到所有子任务完成任务后，将结果合并返回。任务类型： RecursiveAction：没有返回值 RecursiveTask：有返回值，使用join方法获取各个任务的结果，最后使用ForkJoinPool.invoke()获取最终的结果 3、2 阻塞队列特点：入队列：队列已满，阻塞直到有空位；出队列：队列为空，阻塞直到有队列不为空。 场景：一个线程生成、另一个线程消费。 BlockingQueue 的方法： 方法\\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove() poll() take() poll(time,unit) 检查方法 element() peek() 不可用 不可用 队列中元素不能为空 BlockingQueue 的实现类： ArrayBlockingQueue：有界的阻塞队列，底层基于数组实现，存储的元素有上限，一般这个上限初始化时就指定了，后面就无法修改了。 DelayQueue：对元素进行持有直到一个特定的延迟到期。队列中元素必须实现java.util.concurrent.Delayed 接口 LinkedBlockingQueue：以链式结果进行元素的存储，默认上限为：Integer.MAX_VALUE PriorityBlockingQueue： 无界阻塞优先级队列，队列中元素必须实现 java.lang.Comparable 接口。 SynchronousQueue：只能存放单个元素 LinkedBlockingQueue：notFull:表示的等待存放的条件队列notEmpty: 表示等待取出的条件队列 offer方法 ArrayBlockingQueue通过全局锁的方式，同时只能有一个线程进行存放元素到队列或一个线程从队列中获取元素 offer方法 12345678910111213141516 public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;​ 123456789101112该方法首先获取锁，通过其构造方法可以知道，这个锁是非公平锁：&#96;&#96;&#96;java public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;&#x3D; 0) throw new IllegalArgumentException(); this.items &#x3D; new Object[capacity]; lock &#x3D; new ReentrantLock(fair); notEmpty &#x3D; lock.newCondition(); notFull &#x3D; lock.newCondition(); &#125; note: 非公平锁：直接尝试占有锁；公平锁，先判断当前线程是否是第一个线程，是则获取锁，否则添加到等待队列上。 然后调用enqueue方法将元素添加到队列上; 12345678910private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 添加完后，通过 notEmpty.signal() 知非空对队列。 notEmpty和notFull是Condition类型的示例. PriorityBlockingQueue 无界优先级队列内部使用到比较器，用来比较元素大小，由于这是无界队列所以这里没有notFul。默认按元素升序。元素需要实现Comparable接口。 1DEFAULT_INITIAL_CAPACITY = 11 //队列默认大小 为什么是11？ offer 方法 1234567891011121314151617181920212223public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; // 元素个数大于了队列容量，则使用tryGrow进行扩容 while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true; &#125; 这里可以看到扩容时调用了tryGrow方法： 12345678910111213141516171819202122232425262728293031private void tryGrow(Object[] array, int oldCap) &#123; lock.unlock(); // must release and then re-acquire main lock Object[] newArray = null; if (allocationSpinLock == 0 &amp;&amp; UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) &#123; try &#123; // 如果oldCap大于等于64，那么队列新的容量则扩容50% int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : // grow faster if small (oldCap &gt;&gt; 1)); if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123; // possible overflow int minCap = oldCap + 1; if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; &#125; if (newCap &gt; oldCap &amp;&amp; queue == array) newArray = new Object[newCap]; &#125; finally &#123; allocationSpinLock = 0; &#125; &#125; if (newArray == null) // back off if another thread is allocating Thread.yield(); lock.lock(); if (newArray != null &amp;&amp; queue == array) &#123; queue = newArray; System.arraycopy(array, 0, newArray, 0, oldCap); &#125;&#125; note： 为什么是64作为阈值？ 为什么要提前释放锁 扩容的时候可以进行入队列操作，所以是用到CAS，只允许一个线程进行扩容，如果扩容失败了，则通过Thread.yield()让出CPU，让改线程重新获取锁。 12if (newArray &#x3D;&#x3D; null) &#x2F;&#x2F; back off if another thread is allocating Thread.yield(); 复制数组是在获取锁后面才执行的，是为了保证复制的数组是最新的。 排序方法： 123456789101112131415private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; while (k &gt; 0) &#123; // 确定父节点元素位置 int parent = (k - 1) &gt;&gt;&gt; 1; //获取父节点的值 Object e = array[parent]; // 如果插入的值比父节点大，那么完成堆的建立 if (key.compareTo((T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = key;&#125; 例子：假设有三个节点0、1、2，值也是0、1、2。1、2分别是0节点的左右子节点，那么如果插入的k=3,这时先找出他要插入位置的父节点，通过(k-1)&gt;&gt;&gt;1可以得出，parent=1,也就是1节点，这个时候将这个插入的值跟其父节点的值进行比较，如果发现是大于父节点的值，那么完成堆的构建，跳出循环。否则与父节点进行交换， poll方法 该方法通过dequeue方法进行出队列，获取元素。 1234567891011121314151617181920private E dequeue() &#123; int n = size - 1; if (n &lt; 0) return null; else &#123; Object[] array = queue; E result = (E) array[0]; // 获取队列尾部元素，然后将原来的位置的指向设置为空 E x = (E) array[n]; array[n] = null; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) // 把元素插入到下标为0的位置上，然后调整成最小堆 siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n; return result; &#125;&#125; note：最小堆构建过程 take操作 123456789101112public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); E result; try &#123; while ( (result = dequeue()) == null) notEmpty.await(); &#125; finally &#123; lock.unlock(); &#125; return result;&#125; 队列没有元素则一直阻塞 DelayQueue 延时无界阻塞队列DelayQueue = BlockingQueue +PriorityQueue + Delayed 3、3 非阻塞队列消费者出队和生产者入队都不会被阻塞。常用方法跟阻塞队列差不多。 悲观锁和乐观锁悲观锁：认为发送了冲突，那么就会破坏数据的一致性，因此使用独占锁禁止冲突发送。乐观锁：认为即使发送了冲突，也不一定造成损坏 CASCAS(V,A,B)，包含了三个值，内存地址V，旧的预期值A，要修改的新值B。当V的值等于A时，才会将V的值更新为B ConcurrentLinkedQueue 非阻塞无界链表队列采用先进先出的入队原则。采用CAS解决当前节点与下一节点之间的安全性链接和对当前节点的赋值。相关入队和出队方法可以参考《Java并发编程的艺术》P161~P167 ConcurrentHashMap 采用“分段锁”策略,有多个segment组成，segment使用的重入锁，每个segment内部又维护hashentity 。默认下允许16个线程并发（最大并发数为 65536？） 构造方法分析得出的结论： Segment 数组的大小 ssize 是由 concurrentLevel 来决定的，但是却不一定等于concurrentLevel，ssize 一定是大于或等于 concurrentLevel 的最小的 2 的次幂。比如：默认情况下concurrentLevel 是 16，则 ssize 为 16；若 concurrentLevel 为 14，ssize 为 16；若 concurrentLevel 为17， 则 ssize 为 32。 为什么 Segment 的数组大小一定是 2 的次幂？其实主要是便于通过按位与的散列算法来定位 Segment 的 index。 分析见《Java并发编程艺术》P158~P159 note:ssize最大值为65536，segmentShift最大值为16？segmentMask最大值为65535 ConcurrentSkipListMap 非阻塞 Hash 跳表集合与TreeMap类型，都是有序的哈希表，主要区别为： ConcurrentSkipListMap是线程安全，TreeMap非线程安全 ConcurrentSkipListMap通过跳表实现，而TreeMap通过红黑树实现 SkipList跳表： ConcurrentSkipListMap 提供了一种线程安全的并发访问的排序映射表,主要用到了 Node 和 Index 两种节点的存储方式， 通过 volatile 关键字实现了并发的操做 原子包AtomicBoolean 原子性布尔方法： compareAndSet(expectedValue, updateValue)：如果比较的值等于expectedValue，那么原子性的将expectedValue更新为updateValue。 getAndSet(boolean b),返回原来的值，并设置新值为b AtomicIntegerAtomicIntegerArray 原子性整型数组题目实现线程的方式有哪些： 继承Thread 实现Runnable 使用Excutor wait和sleep区别：wait会释放锁，sleep会一直持有锁;wait是所有object都有方法，sleep是线程类所有的。 synchronized 和 volatile作用范围：synchronized: 变量、方法、类 volatile： 变量 作用： synchronized 可能会造成线程的阻塞会被编译器优化。volatile：保证可见性，禁止指令重排序（不会被编译器优化） 线程池作用：减少资源消、提高响应速度、增加线程的管理性。 线程池创建过程： 提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。 当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。 资料参考：面试必备：Java线程池解析 控制线程并发数可以使用信号量Semaphore synchronized 和lock对方法加锁的情况分析：如果使用lock对两个方法都加锁了的，那么同时只能有一个线程访问；如果使用synchronized对两个方法都加锁了的，那么同时可以有两个线程访问，因为它们持有同一把锁； 避免死锁的方法： 按顺序进行加锁：使用join，等待另一个线程执行完才执行自己的线程 加锁时限：线程尝试获取锁的时候加上一定的时限， 超过时限则放弃对该锁的请求， 并释放自己占有的锁。例如使用：lock.tryLock(5000, TimeUnit.MILLISECONDS) 线程间的通信 使用共享变量，加上join做配合 使用wait/notify机制","categories":[{"name":"多线程","slug":"多线程","permalink":"wubc.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Java，多线程","slug":"Java，多线程","permalink":"wubc.me/tags/Java%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java基础复习","slug":"Java基础复习","date":"2020-03-21T12:32:28.000Z","updated":"2020-03-21T12:34:52.197Z","comments":true,"path":"2020/03/21/Java基础复习/","link":"","permalink":"wubc.me/2020/03/21/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"Java基础1、基础语法1、1 深拷贝和浅拷贝要区别是深拷贝对于对象的引用类型会创建新的对象引用，而浅拷贝直接指向同一个引用。object的clone方法是浅拷贝。 想要实现深拷贝，对象以及被引用的对象都需要实现Cloneable接口 1、2 equals和hashcode如果equals为true，那么hashcode一定相同，反之hashcode相等，equals不一定为true。 equals特性：自反性、传递性 重写equals方法： 1、参数是否为这个对象的引用、 2、使用 instanceof 操作符检查”参数是否为正确的类型 3、是否满足对称性、传递性、一致性 4、重写 hashCode 1、3 参数传递形式Java参数传递都是值传递。分析参考文章：这一次，彻底解决Java的值传递和引用传递 1、4 重载和重写的区别重载：编译时的多态性，发生在一个类中。规则： 方法名一致，参数列表中参数的顺序，类型，个数不同 重载与方法的返回值无关（因编译器无法只根据返回类型来确定调用哪个方法），存在于父类和子类，同类中 可以抛出不同的异常，可以有不同修饰符 重写：运行时多态，子类重写父类的方法。规则： .参数列表、返回类型与父类一致 构造方法、被final、static修饰的方法不能被重写 访问权限不能比父类的方法小 不能抛出新的强制性异常、更广泛的强制性异常 1、5 接口和抽象类的区别与特点抽象类： 抽象类中可以定义构造器 可以有抽象方法和具体方法 接口中的成员全都是 public 的 抽象类中可以定义成员变量 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法 抽象类中可以包含静态方法（该静态方法不能是抽象的，因为静态方法不能被重写） 一个类只能继承一个抽象类 接口类; 接口中不能定义构造器 方法全部都是抽象方法 抽象类中的成员可以是 private、默认、protected、public 接口中定义的成员变量实际上都是常量 接口中不能有静态方法 一个类可以实现多个接口 1、6 String特性 String是不可变的，如果进行了“+”操作，那么将产生新的对象，指向了新的对象 字符串内容相同，认为是代表同一个对象 每次通过new实例一个字符串，即使字符串内容相同，也会产生新的对象 2、Java异常机制2、1 分类 异常exceptionError 编译时异常：在编译时可以体现出来。用 try…catch 块或抛出该异常进行处理 运行时异常：在运行时发生的异常，常见的有下标越界等 错误Error:一般是指与虚拟机相关的问题 2、2 tr…catch..finally的返回值1234567891011121314public static void main(String[] args) &#123; System.out.println(getNum());&#125;public static int getNum()&#123; try &#123; int a=10/0; return a; &#125;catch (Exception e)&#123; return 2; &#125;finally &#123; return 3; &#125;&#125; 上述打印结果是3，如果try语句块中发生了异常，那么它将进行到catch块进行处理，catch块里是一个return语句，而存在finally，所以会先执行finally里面的语句，finally语句又是一个return语句，那么该方法将会被结束，catch的返回结果不能被真正返回. 2、3 throw 和 throws 的区别throw: 作用在方法体内，向外抛出异常实例throws: 声明在方法后面，由调用者处理，抛出的某种类型的异常，抛出的异常不一定会发生 2、4 final、finally、finalize 的区别？final： 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，被其修饰的类不可继承 finally： 异常处理语句结构的一部分，表示总是执行 finalize： Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法 2、5 StringBuilder 、StringBuffer 的区别StringBuilder：非同步，效率高，多线程下不安全StringBuffer：同步，效率低，线程安全 tips: String的“+”号操作编译为到StringBuilder的append,因此在建议在循环中不要直接使用“+”号进行连接字符串，这样会产生大量的StringBuilder对象。 Java基本数据类型及范围 名称 字节数 范围 byte 1 -128～127 short 2 -32768～32767 int 4 -2147483648～2147483647 long 8 -2^63～2^63-1 flot 4 -3.403E38～3.403E38 double 8 -1.798E308～1.798E308 char 2 表示一个字符 boolean 1 true、false 包装类每个基本类型都有对象的包装类。 note: 如果两个包装类Integer进行比较，如果比较的数值在-128 到 127 之间， 那么不会 new 新的 Integer 对象， 而是直接引用常量池中的 Integer 对象。而Integer和int类型进行比较，将会自动拆箱成两个int类型比较。 3、IO3、1 流的分类：从方向划分：输入流、输出流从功能划分：节点流、处理流从处理数据单位划分：字节流、字符流 3、2 流的基本操作4、集合4、1 ArrayList的实现底层是使用一个Object[]数组实现的。 一、构造方法分析1）空参构造 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 其中private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {} //一个空数组 2）带参构造：指定初始值 12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 3) 带参构造：参数为一个Collection子类 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 二、add方法12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 这里调用了ensureCapacityInternal方法，让我们继续看这个方法; 123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; 计算分配的容量，DEFAULT_CAPACITY这个值为10，通过Math.max方法来取得它们之间的最大值。 123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; note:modCount的作用:用来记录集合的修改次数 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 这个方法的主要作用是复制一个新的数组。首先初始新分配的容量newCapacity为原来的容量+原来容量的一般，当与minCapacity比价时，取最大的。然后再与MAX_ARRAY_SIZE进行比较，这个MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8 ，如果比这个值还要大，将进行下面的判断; 1234567 private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 可见newCapacity的值，最多为Integer.MAX_VALUE 三、remove方法1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 首先检查下标是否越界，获取需要删除的值，用来做返回值，如果要删除的元素不是最后一个元素，那么数组中后面的元素整体往前移动一位。 四、clear方法123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 该方法实现比较简单，仅仅是将所有元素置为空了。 4、2 并发集合ConcurrentHashMap 分析： 与普通的HashMap相比，多了个concurrencyLevel属性，内部使用到了锁分段技术，Segment 数组，默认情况下有16个段。 put操作：该操作运行16个线程并发无阻塞操作集合镀锡，通过计算hash来确定Segment对象，借此对象的put方法来完成操作。 get操作：类似于put操作，也是借用Segment对象的get方法来实现的。由于Segment对象对象的数组HashEntity的数量是用volatile声明的，因此总是能正确的获取到数组的大小。而HashEntity的属性也是final，所以该链表对象不会发生改变。 4、3 HashMap和HashTable两者都实现了Map接口。HashMap： 非线程安全、高效、支持键值对都为null的 HashTable: 线程安全，不支持null值和null键 4、4 SortMap和TreeMap4、5 ArrayList和LinkListArrayList: 访问速度快 插入慢 开销不固定 底层是数组实现 LinkList: 随机访问速度较慢 插入快 底层是双向循环列表","categories":[{"name":"Java","slug":"Java","permalink":"wubc.me/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"wubc.me/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"zookeeper系列教程之一（Mac下安装zookeeper）","slug":"zookeeper系列教程之一（Mac下安装zookeeper）","date":"2020-02-29T07:09:30.000Z","updated":"2020-03-01T13:09:40.507Z","comments":true,"path":"2020/02/29/zookeeper系列教程之一（Mac下安装zookeeper）/","link":"","permalink":"wubc.me/2020/02/29/zookeeper%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E4%B8%80%EF%BC%88Mac%E4%B8%8B%E5%AE%89%E8%A3%85zookeeper%EF%BC%89/","excerpt":"","text":"一、 Mac下zookeeper的安装两种下载方式 第一种直接网上下载 下载地址：https://zookeeper.apache.org/releases.html#download 国内的镜像地址：https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/ 注意如果不需要源码包请下载文件名带bin的那个文件，那个是编译好的，否则运行zookeeper时会出现 错误: 找不到或无法加载主类 org.apache.zookeeper.server.quorum.QuorumPeerMain的问题 第二种使用homebrew下载： brew install zookeeper 二、配置1、配置解释 1234567891011121314151617181920212223242526272829# The number of milliseconds of each ticktickTime&#x3D;2000# The number of ticks that the initial # synchronization phase can takeinitLimit&#x3D;10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit&#x3D;5# the directory where the snapshot is stored.# do not use &#x2F;tmp for storage, &#x2F;tmp here is just # example sakes.dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper# the port at which the clients will connectclientPort&#x3D;2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns&#x3D;60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount&#x3D;3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval&#x3D;1server.1&#x3D;127.0.0.1:2888:3888 tickTime：ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime。 initLimit：Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在initLimit时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property) syncLimit：在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property) dataDir：存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能。 clientPort： 客户端连接server的端口，即对外服务端口，默认是2181。 server.x=[hostname]:nnnnn[:nnnnn]：这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。 2、配置修改 单机模式： 伪集群模式 三、启动与连接 1、服务端启动：进入zookeeper的bin目录，在终端下执行如下命令启动 ./zkServer.sh start 当输出Starting zookeeper … STARTED 时表示成功了 2、客户端连接，同样在bin目录下执行命令 ./zkCli.sh 然后就进入到JLine控制台命令交互模式 欢迎关注公众号 欢迎进入京东小店，领券购物更优惠","categories":[{"name":"分布式","slug":"分布式","permalink":"wubc.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"wubc.me/tags/zookeeper/"},{"name":"分布式","slug":"分布式","permalink":"wubc.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]}]}